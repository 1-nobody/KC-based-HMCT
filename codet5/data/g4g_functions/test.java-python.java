static int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
static long doublefactorial ( long n ) { if ( n == 0 || n == 1 ) return 1 ; return n * doublefactorial ( n - 2 ) ; }
static int countSquares ( int row , int column ) { int topLeft = Math . min ( row , column ) - 1 ; int bottomRight = 8 - Math . max ( row , column ) ; int topRight = Math . min ( row , 9 - column ) - 1 ; int bottomLeft = 8 - Math . max ( row , 9 - column ) ; return ( topLeft + topRight + bottomRight + bottomLeft ) ; }
static int perfectSquare ( String s ) { int n = s . length ( ) ; int ans = - 1 ; String num = " " ; for ( int i = 1 ; i < ( 1 << n ) ; i ++ ) { String str = " " ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( ( i >> j ) & 1 ) == 1 ) { str += s . charAt ( j ) ; } } if ( str . charAt ( 0 ) != '0' ) { int temp = 0 ; for ( int j = 0 ; j < str . length ( ) ; j ++ ) temp = temp * 10 + ( int ) ( str . charAt ( j ) - '0' ) ; int k = ( int ) Math . sqrt ( temp ) ; if ( k * k == temp ) { if ( ans < ( int ) str . length ( ) ) { ans = ( int ) str . length ( ) ; num = str ; } } } } if ( ans == - 1 ) return ans ; else { System . out . print ( num + " ▁ " ) ; return n - ans ; } }
static int eggDrop ( int n , int k ) { int dp [ ] [ ] = new int [ k + 1 ] [ n + 1 ] ; int x = 0 ; while ( dp [ x ] [ n ] < k ) { x ++ ; for ( int i = 1 ; i <= n ; i ++ ) dp [ x ] [ i ] = dp [ x - 1 ] [ i - 1 ] + dp [ x - 1 ] [ i ] + 1 ; } return x ; }
static int binarySearchCount ( int arr [ ] , int n , int key ) { int left = 0 , right = n ; int mid = 0 ; while ( left < right ) { mid = ( right + left ) >> 1 ; if ( arr [ mid ] == key ) { while ( mid + 1 < n && arr [ mid + 1 ] == key ) mid ++ ; break ; } else if ( arr [ mid ] > key ) right = mid ; else left = mid + 1 ; } while ( mid > - 1 && arr [ mid ] > key ) mid -- ; return mid + 1 ; }
static long getClosest ( int a , int b , int x ) { long num = ( long ) Math . pow ( a , b ) ; int floor = ( int ) ( num / x ) ; long numOnLeft = x * floor ; long numOnRight = x * ( floor + 1 ) ; if ( ( num - numOnLeft ) < ( numOnRight - num ) ) { return numOnLeft ; } else { return numOnRight ; } }
static int findSum ( int N ) { return ( N * ( N + 1 ) * ( 2 * N - 5 ) + 4 * N ) / 2 ; }
static void Loss ( int SP , int P ) { float loss = 0 ; loss = ( float ) ( 2 * P * P * SP ) / ( 100 * 100 - P * P ) ; System . out . println ( " Loss ▁ = ▁ " + loss ) ; }
static int maxCount ( int n , int a [ ] ) { HashMap < Integer , Integer > freq = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { if ( freq . containsKey ( a [ i ] ) ) freq . put ( a [ i ] , freq . get ( a [ i ] ) + 1 ) ; else freq . put ( a [ i ] , 1 ) ; } int ans = 0 ; for ( Integer key : freq . keySet ( ) ) { if ( freq . containsKey ( key + 1 ) ) ans = Math . max ( ans , freq . get ( key ) + freq . get ( key + 1 ) ) ; } return ans ; }
static int getMaxLength ( int arr [ ] , int n ) { int start = 0 ; int preCnt = 0 ; while ( start < n && arr [ start ] == 1 ) { preCnt ++ ; start ++ ; } int end = n - 1 ; int suffCnt = 0 ; while ( end >= 0 && arr [ end ] == 1 ) { suffCnt ++ ; end -- ; } if ( start > end ) return n ; int midCnt = 0 ; int result = 0 ; for ( int i = start ; i <= end ; i ++ ) { if ( arr [ i ] == 1 ) { midCnt ++ ; result = Math . max ( result , midCnt ) ; } else { midCnt = 0 ; } } return Math . max ( result , preCnt + suffCnt ) ; }
static void printWords ( int h , int m ) { String nums [ ] = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " , " ten " , " eleven " , " twelve " , " thirteen " , " fourteen " , " fifteen " , " sixteen " , " seventeen " , " eighteen " , " nineteen " , " twenty " , " twenty ▁ one " , " twenty ▁ two " , " twenty ▁ three " , " twenty ▁ four " , " twenty ▁ five " , " twenty ▁ six " , " twenty ▁ seven " , " twenty ▁ eight " , " twenty ▁ nine " , } ; if ( m == 0 ) System . out . println ( nums [ h ] + " ▁ o ' ▁ clock ▁ " ) ; else if ( m == 1 ) System . out . println ( " one ▁ minute ▁ past ▁ " + nums [ h ] ) ; else if ( m == 59 ) System . out . println ( " one ▁ minute ▁ to ▁ " + nums [ ( h % 12 ) + 1 ] ) ; else if ( m == 15 ) System . out . println ( " quarter ▁ past ▁ " + nums [ h ] ) ; else if ( m == 30 ) System . out . println ( " half ▁ past ▁ " + nums [ h ] ) ; else if ( m == 45 ) System . out . println ( " quarter ▁ to ▁ " + nums [ ( h % 12 ) + 1 ] ) ; else if ( m <= 30 ) System . out . println ( nums [ m ] + " ▁ minutes ▁ past ▁ " + nums [ h ] ) ; else if ( m > 30 ) System . out . println ( nums [ 60 - m ] + " ▁ minutes ▁ to ▁ " + nums [ ( h % 12 ) + 1 ] ) ; }
static void printMaxValPair ( Vector < Long > v , int n ) { Collections . sort ( v ) ; long N = v . get ( ( int ) n - 1 ) ; if ( N % 2 == 1 ) { long first_maxima = N / 2 ; long second_maxima = first_maxima + 1 ; long ans1 = ( long ) 3e18 , ans2 = ( long ) 3e18 ; long from_left = - 1 , from_right = - 1 ; long from = - 1 ; for ( long i = 0 ; i < n ; ++ i ) { if ( v . get ( ( int ) i ) > first_maxima ) { from = i ; break ; } else { long diff = first_maxima - v . get ( ( int ) i ) ; if ( diff < ans1 ) { ans1 = diff ; from_left = v . get ( ( int ) i ) ; } } } from_right = v . get ( ( int ) from ) ; long diff1 = first_maxima - from_left ; long diff2 = from_right - second_maxima ; if ( diff1 < diff2 ) System . out . println ( N + " ▁ " + from_left ) ; else System . out . println ( N + " ▁ " + from_right ) ; } else { long maxima = N / 2 ; long ans1 = ( int ) 3e18 ; long R = - 1 ; for ( long i = 0 ; i < n - 1 ; ++ i ) { long diff = Math . abs ( v . get ( ( int ) i ) - maxima ) ; if ( diff < ans1 ) { ans1 = diff ; R = v . get ( ( int ) i ) ; } } System . out . println ( N + " ▁ " + R ) ; } }
static int findProduct ( int arr [ ] , int n ) { int prod = 1 ; HashSet < Integer > s = new HashSet < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! s . contains ( arr [ i ] ) ) { prod *= arr [ i ] ; s . add ( arr [ i ] ) ; } } return prod ; }
static int maxSum ( int p0 , int p1 , int a [ ] , int pos , int n ) { if ( pos == n ) { if ( p0 == p1 ) return p0 ; else return 0 ; } int ans = maxSum ( p0 , p1 , a , pos + 1 , n ) ; ans = Math . max ( ans , maxSum ( p0 + a [ pos ] , p1 , a , pos + 1 , n ) ) ; ans = Math . max ( ans , maxSum ( p0 , p1 + a [ pos ] , a , pos + 1 , n ) ) ; return ans ; }
static int decideWinner ( int [ ] a , int n ) { int count0 = 0 ; int count1 = 0 ; int count2 = 0 ; int count3 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 4 == 0 ) count0 ++ ; else if ( a [ i ] % 4 == 1 ) count1 ++ ; else if ( a [ i ] % 4 == 2 ) count2 ++ ; else if ( a [ i ] % 4 == 3 ) count3 ++ ; } if ( count0 % 2 == 0 && count1 % 2 == 0 && count2 % 2 == 0 && count3 == 0 ) return 1 ; else return 2 ; }
static int sumPairs ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + ( arr [ i ] * ( 2 * n ) ) ; } return sum ; }
static int getMinVal ( int p , int q ) { if ( q % p == 0 ) return p ; return - 1 ; }
static float find_Area ( float a ) { float R = a * ( float ) ( 2.0 - Math . sqrt ( 2 ) ) ; float area = ( float ) ( ( 3.14 * R * R ) / 2.0 ) ; return area ; }
public static int getSum ( int arr [ ] , int n ) { int i , sum = 0 ; Set < Integer > hashSet = new HashSet < > ( ) ; for ( i = 0 ; i < n ; i ++ ) hashSet . add ( arr [ i ] ) ; for ( i = 0 ; i < n ; i ++ ) { double sqrtCurrent = Math . sqrt ( arr [ i ] ) ; if ( Math . floor ( sqrtCurrent ) != Math . ceil ( sqrtCurrent ) ) continue ; if ( hashSet . contains ( ( int ) sqrtCurrent ) ) { sum += ( sqrtCurrent * sqrtCurrent ) ; } } return sum ; }
static int maxSum ( int arr [ ] , int n ) { int res = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { int curr_sum = 0 ; for ( int j = 0 ; j < n ; j ++ ) { int index = ( i + j ) % n ; curr_sum += j * arr [ index ] ; } res = Math . max ( res , curr_sum ) ; } return res ; }
static void findSubSeq ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int count [ ] = new int [ n ] ; int prev [ ] = new int [ n ] ; int i , j ; for ( i = 0 ; i < n ; i ++ ) count [ i ] = 1 ; for ( j = 0 ; j < n ; j ++ ) prev [ j ] = - 1 ; int max = 0 ; int maxprev = - 1 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i - 1 ; j >= 0 ; j -- ) { if ( arr [ i ] % arr [ j ] == 0 && count [ j ] + 1 > count [ i ] ) { count [ i ] = count [ j ] + 1 ; prev [ i ] = j ; } } if ( max < count [ i ] ) { max = count [ i ] ; maxprev = i ; } } i = maxprev ; while ( i >= 0 ) { if ( arr [ i ] != - 1 ) System . out . print ( arr [ i ] + " ▁ " ) ; i = prev [ i ] ; } }
static int minCost ( int [ ] [ ] graph , int n ) { int cost1 = 0 , cost2 = 0 ; boolean [ ] start = new boolean [ n + 1 ] ; boolean [ ] end = new boolean [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { int a = graph [ i ] [ 0 ] ; int b = graph [ i ] [ 1 ] ; int c = graph [ i ] [ 2 ] ; if ( start [ a ] || end [ b ] ) { cost2 += c ; start [ b ] = true ; end [ a ] = true ; } else { cost1 += c ; start [ a ] = true ; end [ b ] = true ; } } return Math . min ( cost1 , cost2 ) ; }
static double minRevolutions ( double r , int x1 , int y1 , int x2 , int y2 ) { double d = Math . sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ) ; return Math . ceil ( d / ( 2 * r ) ) ; }
static float findArea ( float a , float b , float c ) { if ( a < 0 || b < 0 || c < 0 || ( a + b <= c ) || a + c <= b || b + c <= a ) { System . out . println ( " Not ▁ a ▁ valid ▁ triangle " ) ; System . exit ( 0 ) ; } float s = ( a + b + c ) / 2 ; return ( float ) Math . sqrt ( s * ( s - a ) * ( s - b ) * ( s - c ) ) ; }
static double printProbability ( int L , int n ) { int p = ( 1 << ( n - 1 ) ) ; return 1.0 - ( ( double ) n ) / ( ( double ) p ) ; }
static int countRotations ( String n ) { int len = n . length ( ) ; if ( len == 1 ) { int oneDigit = n . charAt ( 0 ) - '0' ; if ( oneDigit % 4 == 0 ) return 1 ; return 0 ; } int twoDigit , count = 0 ; for ( int i = 0 ; i < ( len - 1 ) ; i ++ ) { twoDigit = ( n . charAt ( i ) - '0' ) * 10 + ( n . charAt ( i + 1 ) - '0' ) ; if ( twoDigit % 4 == 0 ) count ++ ; } twoDigit = ( n . charAt ( len - 1 ) - '0' ) * 10 + ( n . charAt ( 0 ) - '0' ) ; if ( twoDigit % 4 == 0 ) count ++ ; return count ; }
static boolean checkFibinnary ( int n ) { int prev_last = 0 ; while ( n != 0 ) { if ( ( n & 1 ) != 0 && prev_last != 0 ) return false ; prev_last = n & 1 ; n >>= 1 ; } return true ; }
static int sumMaxOccurring ( int arr [ ] [ ] ) { Map < Integer , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( mp . containsKey ( arr [ i ] [ j ] ) ) { mp . put ( arr [ i ] [ j ] , mp . get ( arr [ i ] [ j ] ) + 1 ) ; } else { mp . put ( arr [ i ] [ j ] , 1 ) ; } } } int sum = 0 ; int maxFreq = Integer . MIN_VALUE ; for ( Map . Entry < Integer , Integer > itr : mp . entrySet ( ) ) { if ( itr . getValue ( ) > maxFreq ) { maxFreq = itr . getValue ( ) ; } } for ( Map . Entry < Integer , Integer > itr : mp . entrySet ( ) ) { if ( itr . getValue ( ) == maxFreq ) { sum += ( itr . getKey ( ) ) * ( itr . getValue ( ) ) ; } } return sum ; }
static void solveQuery ( int n , int q , int qi [ ] , int qj [ ] ) { int [ ] arr = new int [ MAX ] ; for ( int i = 0 ; i <= n ; i ++ ) arr [ i ] = 0 ; for ( int k = 0 ; k < q ; k ++ ) { int flag = 0 ; if ( qj [ k ] < qi [ k ] ) { int temp = qi [ k ] ; qi [ k ] = qj [ k ] ; qj [ k ] = temp ; } if ( arr [ qi [ k ] ] != 0 || arr [ qj [ k ] ] != 0 ) flag = 1 ; else if ( qi [ k ] == qj [ k ] ) flag = 1 ; else { for ( int i = 1 ; i < qi [ k ] ; i ++ ) { if ( arr [ i ] != 0 && arr [ i ] < qj [ k ] && qi [ k ] < arr [ i ] ) { flag = 1 ; break ; } } if ( flag == 0 ) { for ( int i = qi [ k ] + 1 ; i < qj [ k ] ; i ++ ) { if ( arr [ i ] != 0 && arr [ i ] > qj [ k ] ) { flag = 1 ; break ; } } } } if ( flag == 0 ) { System . out . println ( " YES " ) ; arr [ qi [ k ] ] = qj [ k ] ; arr [ qj [ k ] ] = qi [ k ] ; } else System . out . println ( " NO " ) ; } }
static void printEgyptian ( int nr , int dr ) { if ( dr == 0 || nr == 0 ) { return ; } if ( dr % nr == 0 ) { System . out . print ( "1 / " + dr / nr ) ; return ; } if ( nr % dr == 0 ) { System . out . print ( nr / dr ) ; return ; } if ( nr > dr ) { System . out . print ( nr / dr + " ▁ + ▁ " ) ; printEgyptian ( nr % dr , dr ) ; return ; } int n = dr / nr + 1 ; System . out . print ( "1 / " + n + " ▁ + ▁ " ) ; printEgyptian ( nr * n - dr , dr * n ) ; }
public static double calculateSum ( double n ) { return 2 * ( Math . pow ( n , 6 ) + 15 * Math . pow ( n , 4 ) + 15 * Math . pow ( n , 2 ) + 1 ) ; }
static int numOfWhiteHats ( int arr [ ] , int n ) { int freq [ ] = new int [ n + 1 ] ; Arrays . fill ( freq , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] >= n ) return - 1 ; freq [ arr [ i ] ] ++ ; } int diffFreq = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) if ( freq [ i ] > 0 ) diffFreq ++ ; if ( diffFreq == 1 && freq [ n - 1 ] == n ) return n ; if ( diffFreq == 1 && freq [ 0 ] == n ) return 0 ; if ( diffFreq != 2 ) return - 1 ; int k ; for ( k = n - 1 ; k >= 1 ; k -- ) if ( freq [ k ] > 0 ) break ; if ( freq [ k - 1 ] == k && freq [ k ] + k == n ) return freq [ k - 1 ] ; else return - 1 ; }
static double solve ( int s ) { double area = ( 1.732 * Math . pow ( s , 2 ) ) / 8 ; return area ; }
static int countWays ( int [ ] arr , int n ) { int max_val = 0 ; for ( int i = 0 ; i < n ; i ++ ) max_val = Math . max ( max_val , arr [ i ] ) ; int [ ] freq = new int [ max_val + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) freq [ arr [ i ] ] ++ ; int ans = 0 ; ans += freq [ 0 ] * ( freq [ 0 ] - 1 ) * ( freq [ 0 ] - 2 ) / 6 ; for ( int i = 1 ; i <= max_val ; i ++ ) ans += freq [ 0 ] * freq [ i ] * ( freq [ i ] - 1 ) / 2 ; for ( int i = 1 ; 2 * i <= max_val ; i ++ ) ans += freq [ i ] * ( freq [ i ] - 1 ) / 2 * freq [ 2 * i ] ; for ( int i = 1 ; i <= max_val ; i ++ ) { for ( int j = i + 1 ; i + j <= max_val ; j ++ ) ans += freq [ i ] * freq [ j ] * freq [ i + j ] ; } return ans ; }
static void print_max ( int a [ ] , int n , int k ) { int [ ] max_upto = new int [ n ] ; Stack < Integer > s = new Stack < > ( ) ; s . push ( 0 ) ; for ( int i = 1 ; i < n ; i ++ ) { while ( ! s . empty ( ) && a [ s . peek ( ) ] < a [ i ] ) { max_upto [ s . peek ( ) ] = i - 1 ; s . pop ( ) ; } s . push ( i ) ; } while ( ! s . empty ( ) ) { max_upto [ s . peek ( ) ] = n - 1 ; s . pop ( ) ; } int j = 0 ; for ( int i = 0 ; i <= n - k ; i ++ ) { while ( j < i || max_upto [ j ] < i + k - 1 ) { j ++ ; } System . out . print ( a [ j ] + " ▁ " ) ; } System . out . println ( ) ; }
static int smallestIndexsum ( int arr [ ] , int n ) { int i = n - 1 ; while ( i >= 0 && arr [ i ] % 2 == 1 ) i -- ; int sum = 0 ; for ( int j = 0 ; j <= i ; j ++ ) sum += arr [ j ] ; return sum ; }
static int minRotation ( int input , int unlock_code ) { int rotation = 0 ; int input_digit , code_digit ; while ( input > 0 || unlock_code > 0 ) { input_digit = input % 10 ; code_digit = unlock_code % 10 ; rotation += Math . min ( Math . abs ( input_digit - code_digit ) , 10 - Math . abs ( input_digit - code_digit ) ) ; input /= 10 ; unlock_code /= 10 ; } return rotation ; }
static void divisibilityCheck ( List < Integer > arr , int n ) { List < Integer > s = new ArrayList < Integer > ( ) ; int max_ele = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { s . add ( arr . get ( i ) ) ; max_ele = Math . max ( max_ele , arr . get ( i ) ) ; } LinkedHashSet < Integer > res = new LinkedHashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr . get ( i ) != 0 ) for ( int j = arr . get ( i ) * 2 ; j <= max_ele ; j += arr . get ( i ) ) { if ( s . contains ( j ) ) res . add ( j ) ; } } List < Integer > list = new ArrayList < Integer > ( res ) ; Collections . reverse ( list ) ; for ( Integer temp : list ) System . out . print ( temp + " ▁ " ) ; }
static int findMaxCock ( int ar [ ] [ ] ) { if ( R < 3 || C < 3 ) return - 1 ; int max_sum = Integer . MIN_VALUE ; for ( int i = 0 ; i < R - 2 ; i ++ ) { for ( int j = 0 ; j < C - 2 ; j ++ ) { int sum = ( ar [ i ] [ j ] + ar [ i ] [ j + 2 ] ) + ( ar [ i + 1 ] [ j + 1 ] ) + ( ar [ i + 2 ] [ j ] + ar [ i + 2 ] [ j + 1 ] + ar [ i + 2 ] [ j + 2 ] ) ; max_sum = Math . max ( max_sum , sum ) ; } } return max_sum ; }
static int aliquotSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i < n ; i ++ ) if ( n % i == 0 ) sum += i ; return sum ; }
static int minOperations ( int [ ] a , int n , int k ) { HashMap < Integer , Boolean > map = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( map . containsKey ( a [ i ] ) && map . get ( a [ i ] ) ) return 0 ; map . put ( a [ i ] , true ) ; } int [ ] b = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) b [ i ] = a [ i ] ^ k ; map . clear ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] != b [ i ] ) map . put ( b [ i ] , true ) ; } for ( int i = 0 ; i < n ; i ++ ) if ( map . containsKey ( a [ i ] ) && map . get ( a [ i ] ) ) return 1 ; map . clear ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( map . containsKey ( b [ i ] ) && map . get ( b [ i ] ) ) return 2 ; map . put ( b [ i ] , true ) ; } return - 1 ; }
static boolean bit_check ( int n ) { if ( ( n & ( n - 1 ) ) == 0 ) return true ; return false ; }
public static int sumOfSeries ( int n ) { int sum = 0 ; for ( int x = 1 ; x <= n ; x ++ ) sum += x * x * x ; return sum ; }
static int count ( int n ) { if ( n < 4 ) return - 1 ; int rem = n % 4 ; if ( rem == 0 ) return n / 4 ; if ( rem == 1 ) { if ( n < 9 ) return - 1 ; return ( n - 9 ) / 4 + 1 ; } if ( rem == 2 ) return ( n - 6 ) / 4 + 1 ; if ( rem == 3 ) { if ( n < 15 ) return - 1 ; return ( n - 15 ) / 4 + 2 ; } return 0 ; }
static int countSquares ( int m , int n ) { if ( n < m ) { int temp = m ; m = n ; n = temp ; } return n * ( n + 1 ) * ( 3 * m - n + 1 ) / 6 ; }
static int fib ( int n ) { int i = n - 1 ; int x = ( int ) ( ( Math . pow ( p , i ) - Math . pow ( q , i ) ) / ( p - q ) ) ; return x ; }
static int count ( int n ) { if ( n == 0 ) return 1 ; if ( n == 1 ) return 1 ; else return ( n * count ( n - 1 ) ) + ( ( n - 1 ) * count ( n - 2 ) ) ; }
static int findNumber ( int n ) { int num = n - 1 ; num = 2 * ( int ) Math . pow ( 4 , num ) ; num = ( int ) Math . floor ( num / 3.0 ) ; return num ; }
static void sortString ( String str ) { int letters [ ] = new int [ MAX_CHAR ] ; for ( char x : str . toCharArray ( ) ) { letters [ x - ' a ' ] ++ ; } for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { for ( int j = 0 ; j < letters [ i ] ; j ++ ) { System . out . print ( ( char ) ( i + ' a ' ) ) ; } } }
static int binomialCoeffSum ( int n ) { int C [ ] [ ] = new int [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= Math . min ( i , n ) ; j ++ ) { if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } int sum = 0 ; for ( int i = 0 ; i <= n ; i ++ ) sum += C [ n ] [ i ] ; return sum ; }
static int minCost ( int [ ] cost , int n ) { int totalCost = 0 ; int boardingBus = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( cost [ boardingBus ] > cost [ i ] ) { totalCost += ( ( i - boardingBus ) * cost [ boardingBus ] ) ; boardingBus = i ; } } totalCost += ( ( n - boardingBus ) * cost [ boardingBus ] ) ; return totalCost ; }
static int findLength ( String str , int n ) { int ans = 0 ; for ( int i = 0 ; i <= n - 2 ; i ++ ) { int l = i , r = i + 1 ; int lsum = 0 , rsum = 0 ; while ( r < n && l >= 0 ) { lsum += str . charAt ( l ) - '0' ; rsum += str . charAt ( r ) - '0' ; if ( lsum == rsum ) { ans = Math . max ( ans , r - l + 1 ) ; } l -- ; r ++ ; } } return ans ; }
static void Divide ( int a , int b ) { long dividend = ( long ) a ; long divisor = ( long ) b ; long sign = ( dividend < 0 ) ^ ( divisor < 0 ) ? - 1 : 1 ; dividend = Math . abs ( dividend ) ; divisor = Math . abs ( divisor ) ; if ( divisor == 0 ) { System . out . println ( " Cannot ▁ Divide ▁ by ▁ 0" ) ; return ; } if ( dividend == 0 ) { System . out . println ( a + " ▁ / ▁ " + b + " ▁ is ▁ equal ▁ to ▁ : ▁ " + 0 ) ; return ; } if ( divisor == 1 ) { System . out . println ( a + " ▁ / ▁ " + b + " ▁ is ▁ equal ▁ to ▁ : ▁ " + sign * dividend ) ; return ; } System . out . println ( a + " ▁ / ▁ " + b + " ▁ is ▁ equal ▁ to ▁ : ▁ " + Math . floor ( sign * ( Math . exp ( Math . log ( dividend ) - Math . log ( divisor ) ) ) ) ) ; }
static String getCount ( int N ) { if ( N % 2 == 1 ) return "0" ; String result = "9" ; for ( int i = 1 ; i <= N / 2 - 1 ; i ++ ) result += "0" ; return result ; }
static int maxOnesIndex ( int arr [ ] , int n ) { int max_count = 0 ; int max_index = 0 ; int prev_zero = - 1 ; int prev_prev_zero = - 1 ; for ( int curr = 0 ; curr < n ; ++ curr ) { if ( arr [ curr ] == 0 ) { if ( curr - prev_prev_zero > max_count ) { max_count = curr - prev_prev_zero ; max_index = prev_zero ; } prev_prev_zero = prev_zero ; prev_zero = curr ; } } if ( n - prev_prev_zero > max_count ) max_index = prev_zero ; return max_index ; }
static void removeDuplicates ( int arr [ ] , int n ) { int st = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < n - 2 && arr [ i ] == arr [ i + 1 ] && arr [ i ] == arr [ i + 2 ] ) continue ; else { arr [ st ] = arr [ i ] ; st ++ ; } } System . out . print ( " { " ) ; for ( int i = 0 ; i < st ; i ++ ) { System . out . print ( arr [ i ] ) ; if ( i != st - 1 ) System . out . print ( " , ▁ " ) ; } System . out . print ( " } " ) ; }
static void shufleArray ( int [ ] a , int n ) { int temp ; n = n / 2 ; for ( int start = n + 1 , j = n + 1 , done = 0 , i ; done < 2 * n - 2 ; done ++ ) { if ( start == j ) { start -- ; j -- ; } i = j > n ? j - n : j ; j = j > n ? 2 * i : 2 * i - 1 ; temp = a [ start ] ; a [ start ] = a [ j ] ; a [ j ] = temp ; } }
static int countSolutions ( int a ) { int count = Integer . bitCount ( a ) ; count = ( int ) Math . pow ( 2 , count ) ; return count ; }
static int evenFibSum ( int limit ) { if ( limit < 2 ) return 0 ; long ef1 = 0 , ef2 = 2 ; long sum = ef1 + ef2 ; while ( ef2 <= limit ) { long ef3 = 4 * ef2 + ef1 ; if ( ef3 > limit ) break ; ef1 = ef2 ; ef2 = ef3 ; sum += ef2 ; } return ( int ) sum ; }
static void printPrevGreater ( int [ ] arr , int n ) { TreeSet < Integer > ts = new TreeSet < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { Integer c = ts . ceiling ( arr [ i ] ) ; if ( c == null ) System . out . print ( - 1 + " ▁ " ) ; else System . out . print ( c + " ▁ " ) ; ts . add ( arr [ i ] ) ; } }
static int countSolutions ( int a ) { int count = 0 ; for ( int i = 0 ; i <= a ; i ++ ) { if ( a == ( i + ( a ^ i ) ) ) count ++ ; } return count ; }
static int maxCost ( int a [ ] , int n , int l , int r ) { int mx = 0 , k ; for ( int i = 0 ; i < n ; ++ i ) mx = Math . max ( mx , a [ i ] ) ; int [ ] count = new int [ mx + 1 ] ; for ( int i = 0 ; i < count . length ; i ++ ) count [ i ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) count [ a [ i ] ] ++ ; int [ ] res = new int [ mx + 1 ] ; res [ 0 ] = 0 ; l = Math . min ( l , r ) ; for ( int num = 1 ; num <= mx ; num ++ ) { k = Math . max ( num - l - 1 , 0 ) ; res [ num ] = Math . max ( res [ num - 1 ] , num * count [ num ] + res [ k ] ) ; } return res [ mx ] ; }
static int sum ( int n ) { if ( n == 1 ) { return 2 ; } else { return ( n * ( n + 1 ) + sum ( n - 1 ) ) ; } }
static int nonDecNums ( int n ) { int [ ] [ ] a = new int [ n + 1 ] [ 10 ] ; for ( int i = 0 ; i <= 9 ; i ++ ) a [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) a [ i ] [ 9 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 8 ; j >= 0 ; j -- ) a [ i ] [ j ] = a [ i - 1 ] [ j ] + a [ i ] [ j + 1 ] ; return a [ n ] [ 0 ] ; }
static void newvol ( double x ) { System . out . print ( " percentage ▁ increase ▁ in ▁ the " + " ▁ volume ▁ of ▁ the ▁ sphere ▁ is ▁ " + ( Math . pow ( x , 3 ) / 10000 + 3 * x + ( 3 * Math . pow ( x , 2 ) ) / 100 ) + " % " ) ; }
static boolean isDivisible ( int n ) { int d ; while ( ( n / 100 ) > 0 ) { d = n % 10 ; n /= 10 ; n = Math . abs ( n - ( d * 14 ) ) ; } return ( n % 47 == 0 ) ; }
static boolean isProductEven ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) if ( ( arr [ i ] & 1 ) == 0 ) return true ; return false ; }
static Pair getMinMax ( int arr [ ] , int low , int high ) { Pair minmax = new Pair ( ) ; Pair mml = new Pair ( ) ; Pair mmr = new Pair ( ) ; int mid ; if ( low == high ) { minmax . max = arr [ low ] ; minmax . min = arr [ low ] ; return minmax ; } if ( high == low + 1 ) { if ( arr [ low ] > arr [ high ] ) { minmax . max = arr [ low ] ; minmax . min = arr [ high ] ; } else { minmax . max = arr [ high ] ; minmax . min = arr [ low ] ; } return minmax ; } mid = ( low + high ) / 2 ; mml = getMinMax ( arr , low , mid ) ; mmr = getMinMax ( arr , mid + 1 , high ) ; if ( mml . min < mmr . min ) { minmax . min = mml . min ; } else { minmax . min = mmr . min ; } if ( mml . max > mmr . max ) { minmax . max = mml . max ; } else { minmax . max = mmr . max ; } return minmax ; }
static int countOperations ( int n ) { int i = 2 ; while ( ( i * i ) < n && ( n % i ) > 0 ) i += 1 ; if ( ( i * i ) > n ) i = n ; return ( 1 + ( n - i ) / 2 ) ; }
static void printStrings ( String s , int l , int m ) { Set < String > c = new LinkedHashSet < > ( ) ; s = s + s ; for ( int i = 0 ; i < l ; i ++ ) { c . add ( s . substring ( i , i + m ) ) ; } Iterator itr = c . iterator ( ) ; while ( itr . hasNext ( ) ) { String a = ( String ) itr . next ( ) ; System . out . print ( a + " ▁ " ) ; } c . clear ( ) ; }
static int getMissingNo ( int a [ ] , int n ) { int total = 1 ; for ( int i = 2 ; i <= ( n + 1 ) ; i ++ ) { total += i ; total -= a [ i - 2 ] ; } return total ; }
static int sumOddOccurring ( int arr [ ] [ ] ) { Map < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( mp . get ( arr [ i ] [ j ] ) == null ) mp . put ( arr [ i ] [ j ] , 1 ) ; else mp . put ( arr [ i ] [ j ] , ( mp . get ( arr [ i ] [ j ] ) + 1 ) ) ; } } int sum = 0 ; Set < Map . Entry < Integer , Integer > > st = mp . entrySet ( ) ; for ( Map . Entry < Integer , Integer > me : st ) { if ( me . getValue ( ) % 2 == 0 ) { int x = me . getValue ( ) ; sum += ( me . getKey ( ) ) * ( me . getValue ( ) ) ; } } return sum ; }
static void removeElements ( int arr [ ] , int n , int l , int r ) { HashMap < Integer , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { int val = 0 ; if ( mp . get ( arr [ i ] ) == null ) { val = 1 ; } else { val = mp . get ( arr [ i ] ) + 1 ; } mp . put ( arr [ i ] , val ) ; } for ( int i = 0 ; i < n ; ++ i ) { if ( mp . get ( arr [ i ] ) < l || mp . get ( arr [ i ] ) > r ) { System . out . print ( arr [ i ] + " ▁ " ) ; } } }
static boolean checkTriangularSumRepresentation ( int n ) { HashSet < Integer > tri = new HashSet < > ( ) ; int i = 1 ; while ( true ) { int x = i * ( i + 1 ) / 2 ; if ( x >= n ) { break ; } tri . add ( x ) ; i ++ ; } for ( Integer tm : tri ) { if ( tri . contains ( n - tm ) && ( n - tm ) != ( int ) tri . toArray ( ) [ tri . size ( ) - 1 ] ) { return true ; } } return false ; }
static int findMinEqualSums ( int [ ] a , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += a [ i ] ; } int sum1 = 0 , sum2 = 0 ; int min = Integer . MAX_VALUE ; for ( int i = 0 ; i < N ; i ++ ) { sum1 += a [ i ] ; sum2 = sum - sum1 ; if ( Math . abs ( sum1 - sum2 ) < min ) { min = Math . abs ( sum1 - sum2 ) ; } if ( min == 0 ) { break ; } } return min ; }
static int distinctCount ( int arr [ ] , int n ) { int count = n ; int i = 0 , j = n - 1 , sum = 0 ; while ( i < j ) { while ( i != j && arr [ i ] == arr [ i + 1 ] ) { count -- ; i ++ ; } while ( i != j && arr [ j ] == arr [ j - 1 ] ) { count -- ; j -- ; } if ( i == j ) break ; sum = arr [ i ] + arr [ j ] ; if ( sum == 0 ) { count -- ; i ++ ; j -- ; } else if ( sum < 0 ) i ++ ; else j -- ; } return count ; }
static void minAbsSumPair ( int arr [ ] , int arr_size ) { int inv_count = 0 ; int l , r , min_sum , sum , min_l , min_r ; if ( arr_size < 2 ) { System . out . println ( " Invalid ▁ Input " ) ; return ; } min_l = 0 ; min_r = 1 ; min_sum = arr [ 0 ] + arr [ 1 ] ; for ( l = 0 ; l < arr_size - 1 ; l ++ ) { for ( r = l + 1 ; r < arr_size ; r ++ ) { sum = arr [ l ] + arr [ r ] ; if ( Math . abs ( min_sum ) > Math . abs ( sum ) ) { min_sum = sum ; min_l = l ; min_r = r ; } } } System . out . println ( " ▁ The ▁ two ▁ elements ▁ whose ▁ " + " sum ▁ is ▁ minimum ▁ are ▁ " + arr [ min_l ] + " ▁ and ▁ " + arr [ min_r ] ) ; }
static int findLength ( int [ ] arr , int n ) { int x = 0 ; for ( int i = 0 ; i < n ; i ++ ) x = Math . max ( x , arr [ i ] ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != x ) continue ; int j = i ; while ( arr [ j ] == x ) { j ++ ; if ( j >= n ) break ; } ans = Math . max ( ans , j - i ) ; } return ans ; }
static long power ( long x , long y ) { long res = 1 ; x = x % p ; while ( y > 0 ) { if ( y % 2 == 1 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res % p ; }
static int maxPathSum ( int tri [ ] [ ] ) { int ans = 0 ; for ( int i = N - 2 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < N - i ; j ++ ) { if ( j - 1 >= 0 ) tri [ i ] [ j ] += Math . max ( tri [ i + 1 ] [ j ] , tri [ i + 1 ] [ j - 1 ] ) ; else tri [ i ] [ j ] += tri [ i + 1 ] [ j ] ; ans = Math . max ( ans , tri [ i ] [ j ] ) ; } } return ans ; }
static int maximize ( int A1 [ ] , int A2 [ ] , int n , int x , int y ) { int [ ] c = new int [ n ] ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { c [ i ] = A2 [ i ] - A1 [ i ] ; sum += A1 [ i ] ; } int temp ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( c [ i ] < c [ i + 1 ] ) { temp = c [ i ] ; c [ i ] = c [ i + 1 ] ; c [ i + 1 ] = temp ; } } int maxi = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { sum += c [ i ] ; if ( i + 1 >= ( n - x ) ) maxi = Math . max ( sum , maxi ) ; } return maxi ; }
static void printEqualModNumbers ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int d = arr [ n - 1 ] - arr [ 0 ] ; if ( d == 0 ) { System . out . println ( " Infinite ▁ solution " ) ; return ; } Vector < Integer > v = new Vector < > ( ) ; for ( int i = 1 ; i * i <= d ; i ++ ) { if ( d % i == 0 ) { v . add ( i ) ; if ( i != d / i ) v . add ( d / i ) ; } } for ( int i = 0 ; i < v . size ( ) ; i ++ ) { int temp = arr [ 0 ] % v . get ( i ) ; int j ; for ( j = 1 ; j < n ; j ++ ) if ( arr [ j ] % v . get ( i ) != temp ) break ; if ( j == n ) System . out . print ( v . get ( i ) + " ▁ " ) ; } }
static String printBinary ( double num ) { if ( num >= 1 || num <= 0 ) return " ERROR " ; StringBuilder binary = new StringBuilder ( ) ; binary . append ( " . " ) ; while ( num > 0 ) { if ( binary . length ( ) >= 32 ) return " ERROR " ; double r = num * 2 ; if ( r >= 1 ) { binary . append ( 1 ) ; num = r - 1 ; } else { binary . append ( 0 ) ; num = r ; } } return binary . toString ( ) ; }
static int numberOfCells ( int mat [ ] [ ] ) { boolean [ ] [ ] row = new boolean [ N ] [ N ] ; boolean [ ] [ ] col = new boolean [ N ] [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = N - 1 ; j >= 0 ; j -- ) { if ( mat [ i ] [ j ] == 1 ) { row [ i ] [ j ] = ( j + 1 < N ) ? row [ i ] [ j + 1 ] : true ; } else { row [ i ] [ j ] = false ; } } } for ( int j = 0 ; j < N ; j ++ ) { for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( mat [ i ] [ j ] == 1 ) { col [ i ] [ j ] = ( i + 1 < N ) ? col [ i + 1 ] [ j ] : true ; } else { col [ i ] [ j ] = false ; } } } int cnt = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { for ( int j = 0 ; j < N - 1 ; j ++ ) { if ( row [ i ] [ j ] && col [ i ] [ j ] ) { cnt ++ ; } } } for ( int i = 0 ; i < N ; i ++ ) { if ( col [ i ] [ N - 1 ] ) cnt ++ ; } for ( int j = 0 ; j < N - 1 ; j ++ ) { if ( row [ N - 1 ] [ j ] ) cnt ++ ; } return cnt ; }
static public int LongestSubarray ( int arr [ ] , int n , int k ) { int count = 1 ; int max_length = 1 ; int prev_mod = arr [ 0 ] % k ; for ( int i = 1 ; i < n ; i ++ ) { int curr_mod = arr [ i ] % k ; if ( curr_mod == prev_mod ) { count ++ ; } else { max_length = Math . max ( max_length , count ) ; count = 1 ; prev_mod = curr_mod ; } } return max_length ; }
static void printPattern ( int n ) { int j , k = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i % 2 != 0 ) { for ( j = k + 1 ; j < k + i ; j ++ ) System . out . print ( j + " * " ) ; System . out . println ( j ++ ) ; k = j ; } else { k = k + i - 1 ; for ( j = k ; j > k - i + 1 ; j -- ) System . out . print ( j + " * " ) ; System . out . println ( j ) ; } } }
static void minMaxValues ( int [ ] arr , int n , int m ) { int sum = 0 ; for ( int i = 0 ; i < ( n + m ) ; i ++ ) { sum += arr [ i ] ; arr [ i ] += 50 ; } boolean dp [ ] [ ] = new boolean [ MAX + 1 ] [ MAX * MAX + 1 ] ; dp [ 0 ] [ 0 ] = true ; for ( int i = 0 ; i < ( n + m ) ; i ++ ) { for ( int k = Math . min ( n , i + 1 ) ; k >= 1 ; k -- ) { for ( int j = 0 ; j < MAX * MAX + 1 ; j ++ ) { if ( dp [ k - 1 ] [ j ] ) dp [ k ] [ j + arr [ i ] ] = true ; } } } double max_value = - 1 * INF , min_value = INF ; for ( int i = 0 ; i < MAX * MAX + 1 ; i ++ ) { if ( dp [ n ] [ i ] ) { int temp = i - 50 * n ; max_value = Math . max ( max_value , temp * ( sum - temp ) ) ; min_value = Math . min ( min_value , temp * ( sum - temp ) ) ; } } System . out . print ( " Maximum ▁ Value : ▁ " + ( int ) max_value + " \n " + " Minimum ▁ Value : ▁ " + ( int ) min_value + " \n " ) ; }
static int StrictlyPositiveXor ( int [ ] A , int N ) { int allxor = 0 ; boolean checkallzero = true ; for ( int i = 0 ; i < N ; i += 1 ) { allxor ^= A [ i ] ; if ( A [ i ] > 0 ) checkallzero = false ; } if ( allxor != 0 ) return N ; if ( checkallzero ) return - 1 ; int l = N , r = - 1 ; for ( int i = 0 ; i < N ; i += 1 ) { if ( A [ i ] > 0 ) { l = i + 1 ; break ; } } for ( int i = N - 1 ; i >= 0 ; i -= 1 ) { if ( A [ i ] > 0 ) { r = i + 1 ; break ; } } return Math . max ( N - l , r - 1 ) ; }
static void findNthTerm ( int n ) { if ( n % 2 == 0 ) { n = n / 2 ; System . out . print ( Math . pow ( 3 , n - 1 ) + " \n " ) ; } else { n = ( n / 2 ) + 1 ; System . out . print ( Math . pow ( 2 , n - 1 ) + " \n " ) ; } }
static int Squares ( int n , int m , int a ) { return ( ( m + a - 1 ) / a ) * ( ( n + a - 1 ) / a ) ; }
static int maxOnesIndex ( boolean arr [ ] , int n ) { int i = 0 ; int leftCnt = 0 ; int rightCnt = 0 ; int maxIndex = - 1 ; int lastInd = - 1 ; int maxCnt = 0 ; while ( i < n ) { if ( arr [ i ] ) { rightCnt ++ ; } else { if ( lastInd != - 1 ) { if ( rightCnt + leftCnt + 1 > maxCnt ) { maxCnt = leftCnt + rightCnt + 1 ; maxIndex = lastInd ; } } lastInd = i ; leftCnt = rightCnt ; rightCnt = 0 ; } i ++ ; } if ( lastInd != - 1 ) { if ( leftCnt + rightCnt + 1 > maxCnt ) { maxCnt = leftCnt + rightCnt + 1 ; maxIndex = lastInd ; } } return maxIndex ; }
static int closetAND ( int arr [ ] , int n , int k ) { int ans = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { int X = arr [ i ] ; for ( int j = i ; j < n ; j ++ ) { X &= arr [ j ] ; ans = Math . min ( ans , Math . abs ( k - X ) ) ; if ( X <= k ) break ; } } return ans ; }
static int minOperations ( int [ ] arr , int n ) { int maxi , result = 0 ; int [ ] freq = new int [ 1000001 ] ; for ( int i = 0 ; i < n ; i ++ ) { int x = arr [ i ] ; freq [ x ] ++ ; } maxi = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; for ( int i = 1 ; i <= maxi ; i ++ ) { if ( freq [ i ] != 0 ) { for ( int j = i * 2 ; j <= maxi ; j = j + i ) { freq [ j ] = 0 ; } result ++ ; } } return result ; }
static int min_elimination ( int n , int arr [ ] ) { int countOdd = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 == 1 ) countOdd ++ ; return Math . min ( countOdd , n - countOdd ) ; }
static int minimumChanges ( int n , int a [ ] ) { int i ; int [ ] sf = new int [ n + 1 ] ; sf [ n ] = 0 ; for ( i = n - 1 ; i >= 0 ; i -- ) { sf [ i ] = sf [ i + 1 ] ; if ( a [ i ] <= 0 ) sf [ i ] ++ ; } int pos = 0 ; int mn = n ; for ( i = 0 ; i < n - 1 ; i ++ ) { if ( a [ i ] >= 0 ) pos ++ ; mn = Math . min ( mn , pos + sf [ i + 1 ] ) ; } return mn ; }
static int squares ( int l , int b , int a ) { return ( int ) ( Math . ceil ( l / ( double ) a ) * Math . ceil ( b / ( double ) a ) ) ; }
static int search ( int ar [ ] , int size ) { int a = 0 , b = size - 1 ; int mid = 0 ; while ( ( b - a ) > 1 ) { mid = ( a + b ) / 2 ; if ( ( ar [ a ] - a ) != ( ar [ mid ] - mid ) ) b = mid ; else if ( ( ar [ b ] - b ) != ( ar [ mid ] - mid ) ) a = mid ; } return ( ar [ mid ] + 1 ) ; }
static void diagonalsMinMax ( int [ ] [ ] mat ) { int n = mat . length ; if ( n == 0 ) return ; int principalMin = mat [ 0 ] [ 0 ] , principalMax = mat [ 0 ] [ 0 ] ; int secondaryMin = mat [ n - 1 ] [ 0 ] , secondaryMax = mat [ n - 1 ] [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( mat [ i ] [ i ] < principalMin ) { principalMin = mat [ i ] [ i ] ; } if ( mat [ i ] [ i ] > principalMax ) { principalMax = mat [ i ] [ i ] ; } if ( mat [ n - 1 - i ] [ i ] < secondaryMin ) { secondaryMin = mat [ n - 1 - i ] [ i ] ; } if ( mat [ n - 1 - i ] [ i ] > secondaryMax ) { secondaryMax = mat [ n - 1 - i ] [ i ] ; } } System . out . println ( " Principal ▁ Diagonal ▁ Smallest ▁ Element : ▁ ▁ " + principalMin ) ; System . out . println ( " Principal ▁ Diagonal ▁ Greatest ▁ Element ▁ : ▁ " + principalMax ) ; System . out . println ( " Secondary ▁ Diagonal ▁ Smallest ▁ Element : ▁ " + secondaryMin ) ; System . out . println ( " Secondary ▁ Diagonal ▁ Greatest ▁ Element : ▁ " + secondaryMax ) ; }
static int subgrids ( int N , int Z , int row [ ] , int col [ ] , int r , int d ) { Vector < Integer > conrow = new Vector < Integer > ( ) ; Vector < Integer > concol = new Vector < Integer > ( ) ; int K = ( int ) Math . sqrt ( Z ) ; conrow . add ( row [ 0 ] - 0 - 1 ) ; conrow . add ( N + 1 - row [ r - 1 ] - 1 ) ; for ( int i = 1 ; i < r ; i ++ ) { conrow . add ( row [ i ] - row [ i - 1 ] - 1 ) ; } concol . add ( col [ 0 ] - 0 - 1 ) ; concol . add ( N + 1 - col [ d - 1 ] - 1 ) ; for ( int i = 1 ; i < d ; i ++ ) { concol . add ( col [ i ] - col [ i - 1 ] - 1 ) ; } int row_size = conrow . size ( ) ; int col_size = concol . size ( ) ; int answer = 0 ; for ( int i = 0 ; i < row_size ; i ++ ) { for ( int j = 0 ; j < col_size ; j ++ ) { int total = ( concol . get ( j ) / K ) * ( conrow . get ( i ) / K ) ; answer += ( total ) ; } } return answer ; }
static String toggleCase ( char [ ] a ) { for ( int i = 0 ; i < a . length ; i ++ ) { a [ i ] ^= 32 ; } return new String ( a ) ; }
static int findMinRemoval ( int arr [ ] , int n ) { int temp , value = 0 ; int maximum = 0 ; if ( n == 1 ) return 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i != 0 && i != n - 1 ) { value = value + Math . abs ( arr [ i ] - arr [ i + 1 ] ) ; temp = Math . abs ( arr [ i ] - arr [ i + 1 ] ) + Math . abs ( arr [ i ] - arr [ i - 1 ] ) - Math . abs ( arr [ i - 1 ] - arr [ i + 1 ] ) ; } else if ( i == 0 ) { value = value + Math . abs ( arr [ i ] - arr [ i + 1 ] ) ; temp = Math . abs ( arr [ i ] - arr [ i + 1 ] ) ; } else temp = Math . abs ( arr [ i ] - arr [ i - 1 ] ) ; maximum = Math . max ( maximum , temp ) ; } return ( value - maximum ) ; }
static void divide ( int n , int m ) { System . out . println ( " Remainder ▁ = ▁ " + ( ( n ) & ( m - 1 ) ) ) ; System . out . println ( " Quotient ▁ = ▁ " + ( n >> ( int ) ( Math . log ( m ) / Math . log ( 2 ) ) ) ) ; }
static double nthHarmonic ( int N ) { float harmonic = 1 ; for ( int i = 2 ; i <= N ; i ++ ) { harmonic += ( float ) 1 / i ; } return harmonic ; }
static void printSubstrings ( int n ) { int s = ( int ) Math . log10 ( n ) ; int d = ( int ) ( Math . pow ( 10 , s ) + 0.5 ) ; int k = d ; while ( n > 0 ) { while ( d > 0 ) { System . out . println ( n / d ) ; d = d / 10 ; } n = n % k ; k = k / 10 ; d = k ; } }
static void checkArray ( int a [ ] , int b [ ] , int n ) { int operations = 0 ; int i = 0 ; while ( i < n ) { if ( a [ i ] - b [ i ] == 0 ) { i ++ ; continue ; } int diff = a [ i ] - b [ i ] ; i ++ ; while ( i < n && a [ i ] - b [ i ] == diff ) { i ++ ; } operations ++ ; } System . out . println ( operations ) ; }
static void difference ( int arr [ ] , int n ) { int largest = arr [ 0 ] ; int i ; for ( i = 0 ; i < n ; i ++ ) { if ( largest < arr [ i ] ) largest = arr [ i ] ; } for ( i = 0 ; i < n ; i ++ ) arr [ i ] = largest - arr [ i ] ; for ( i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; }
public static boolean isMagic ( int n ) { int sum = 0 ; while ( n > 0 || sum > 9 ) { if ( n == 0 ) { n = sum ; sum = 0 ; } sum += n % 10 ; n /= 10 ; } return ( sum == 1 ) ; }
static float InscribedCircleArea ( float n , float a ) { if ( a < 0 && n < 0 ) return - 1 ; float r = a / ( float ) ( 2 * Math . tan ( ( 180 / n ) * 3.14159 / 180 ) ) ; float Area = ( float ) ( 3.14 ) * ( r ) * ( r ) ; return Area ; }
static void EvenOddProduct ( int arr [ ] , int n ) { int even = 1 ; int odd = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) even *= arr [ i ] ; else odd *= arr [ i ] ; } System . out . println ( " Even ▁ Index ▁ Product ▁ : ▁ " + even ) ; System . out . println ( " Odd ▁ Index ▁ Product ▁ : ▁ " + odd ) ; }
static boolean isPairWithDiff ( int mat [ ] [ ] , int k ) { HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < M ; j ++ ) s . add ( mat [ i ] [ j ] ) ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < M ; j ++ ) if ( s . contains ( k + mat [ i ] [ j ] ) && k + mat [ i ] [ j ] != ( int ) s . toArray ( ) [ s . size ( ) - 1 ] ) return true ; return false ; }
static float findVolume ( float l , float b , float h ) { float volume = ( l * b * h ) / 2 ; return volume ; }
public static int countSetBits ( int n ) { if ( n == 0 ) return 0 ; else return 1 + countSetBits ( n & ( n - 1 ) ) ; }
static int countSteps ( int [ ] val , int n ) { int sol = 0 ; Vector < Integer > vec = new Vector < > ( 1 ) ; vec . add ( 0 ) ; status [ 0 ] = - 1 ; for ( int i = 1 ; i < n ; ++ i ) { status [ i ] = 0 ; while ( vec . size ( ) > 0 && val [ vec . lastElement ( ) ] >= val [ i ] ) { status [ i ] = Math . max ( status [ i ] , status [ vec . lastElement ( ) ] + 1 ) ; vec . remove ( vec . lastElement ( ) ) ; } if ( vec . isEmpty ( ) ) { status [ i ] = - 1 ; } vec . add ( i ) ; sol = Math . max ( sol , status [ i ] + 1 ) ; } return sol ; }
static int odd_digits ( int n ) { if ( n < 10 ) return n ; else if ( n / 10 < 10 ) return 9 ; else if ( n / 100 < 10 ) return 9 + n - 99 ; else if ( n / 1000 < 10 ) return 9 + 900 ; else if ( n / 10000 < 10 ) return 909 + n - 9999 ; else return 90909 ; }
static String even_or_odd ( String N ) { int len = N . length ( ) ; if ( N . charAt ( len - 1 ) == '0' || N . charAt ( len - 1 ) == '2' || N . charAt ( len - 1 ) == '4' || N . charAt ( len - 1 ) == '6' || N . charAt ( len - 1 ) == '8' || N . charAt ( len - 1 ) == ' A ' || N . charAt ( len - 1 ) == ' C ' || N . charAt ( len - 1 ) == ' E ' ) return ( " Even " ) ; else return ( " Odd " ) ; }
static void parallel ( int a [ ] [ ] ) { boolean x = true , y = true ; for ( int i = 0 ; i < a . length - 1 ; i ++ ) { for ( int j = 0 ; j < 2 ; j ++ ) { if ( a [ i ] [ 0 ] != a [ i + 1 ] [ 0 ] ) x = false ; if ( a [ i ] [ 1 ] != a [ i + 1 ] [ 1 ] ) y = false ; } } if ( x ) System . out . println ( " Parallel ▁ to ▁ X ▁ Axis " ) ; else if ( y ) System . out . println ( " Parallel ▁ to ▁ Y ▁ Axis " ) ; else System . out . println ( " Not ▁ parallel ▁ to ▁ X " + " ▁ and ▁ Y ▁ axis " ) ; }
static void sub_segments ( String str , int n ) { int l = str . length ( ) ; for ( int x = 0 ; x < l ; x += n ) { String newlist = str . substring ( x , x + n ) ; List < Character > arr = new ArrayList < Character > ( ) ; for ( char y : newlist . toCharArray ( ) ) { if ( ! arr . contains ( y ) ) arr . add ( y ) ; } for ( char y : arr ) System . out . print ( y ) ; System . out . println ( ) ; } }
static int printNthElement ( int n ) { int arr [ ] = new int [ n + 1 ] ; arr [ 1 ] = 3 ; arr [ 2 ] = 5 ; for ( int i = 3 ; i <= n ; i ++ ) { if ( i % 2 != 0 ) arr [ i ] = arr [ i / 2 ] * 10 + 3 ; else arr [ i ] = arr [ ( i / 2 ) - 1 ] * 10 + 5 ; } return arr [ n ] ; }
static int lds ( Integer arr [ ] , int n ) { Integer lds [ ] = new Integer [ n ] ; lds [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { lds [ i ] = 1 ; for ( int j = 0 ; j < i ; j ++ ) if ( lds [ j ] != 0 && arr [ i ] % arr [ j ] == 0 ) lds [ i ] = Math . max ( lds [ i ] , lds [ j ] + 1 ) ; } int max = ( int ) Collections . max ( Arrays . asList ( lds ) ) ; return max ; }
static int smallestIndex ( int [ ] a , int n ) { int right1 = 0 , right0 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) right1 = i ; else right0 = i ; } return Math . min ( right1 , right0 ) ; }
static int getMod ( String str , int n , int k ) { int pwrTwo [ ] = new int [ n ] ; pwrTwo [ 0 ] = 1 % k ; for ( int i = 1 ; i < n ; i ++ ) { pwrTwo [ i ] = pwrTwo [ i - 1 ] * ( 2 % k ) ; pwrTwo [ i ] %= k ; } int res = 0 ; int i = 0 , j = n - 1 ; while ( i < n ) { if ( str . charAt ( j ) == '1' ) { res += ( pwrTwo [ i ] ) ; res %= k ; } i ++ ; j -- ; } return res ; }
static boolean isPerfect ( int n ) { int sum = 1 ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( i * i != n ) sum = sum + i + n / i ; else sum = sum + i ; } } if ( sum == n && n != 1 ) return true ; return false ; }
static long maxProd ( int arr [ ] , int n , int k ) { long product = 1 ; HashMap < Integer , Integer > s = new HashMap < Integer , Integer > ( ) ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . containsKey ( arr [ i ] ) == false ) { product = product * arr [ i ] ; s . put ( arr [ i ] , 1 ) ; } else s . put ( arr [ i ] , s . get ( arr [ i ] ) + 1 ) ; } for ( int j = n - 1 ; j >= 0 && k > 0 ; j -- ) { if ( ( k > ( s . get ( arr [ j ] ) - 1 ) ) && ( ( s . get ( arr [ j ] ) - 1 ) > 0 ) ) { product *= Math . pow ( arr [ j ] , s . get ( arr [ j ] ) - 1 ) ; k = k - s . get ( arr [ j ] ) + 1 ; s . put ( arr [ j ] , 0 ) ; } if ( k <= ( s . get ( arr [ j ] ) - 1 ) && ( ( s . get ( arr [ j ] ) - 1 ) > 0 ) ) { product *= Math . pow ( arr [ j ] , k ) ; break ; } } return product ; }
static int findLength ( String str ) { int n = str . length ( ) ; int maxlen = 0 ; int sum [ ] [ ] = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) sum [ i ] [ i ] = str . charAt ( i ) - '0' ; for ( int len = 2 ; len <= n ; len ++ ) { for ( int i = 0 ; i < n - len + 1 ; i ++ ) { int j = i + len - 1 ; int k = len / 2 ; sum [ i ] [ j ] = sum [ i ] [ j - k ] + sum [ j - k + 1 ] [ j ] ; if ( len % 2 == 0 && sum [ i ] [ j - k ] == sum [ ( j - k + 1 ) ] [ j ] && len > maxlen ) maxlen = len ; } } return maxlen ; }
static void KthCharacter ( int m , int n , int k ) { int distance = ( int ) Math . pow ( 2 , n ) ; int Block_number = k / distance ; int remaining = k % distance ; int s [ ] = new int [ 32 ] ; int x = 0 ; for ( ; m > 0 ; x ++ ) { s [ x ] = m % 2 ; m = m / 2 ; } int root = s [ x - 1 - Block_number ] ; if ( remaining == 0 ) { System . out . println ( root ) ; return ; } Boolean flip = true ; while ( remaining > 1 ) { if ( ( remaining & 1 ) > 0 ) { flip = ! flip ; } remaining = remaining >> 1 ; } if ( flip ) { System . out . println ( ( root > 0 ) ? 0 : 1 ) ; } else { System . out . println ( root ) ; } }
static double getMaxMedian ( int [ ] arr , int n , int k ) { int size = n + k ; Arrays . sort ( arr ) ; if ( size % 2 == 0 ) { double median = ( double ) ( arr [ ( size / 2 ) - 1 ] + arr [ size / 2 ] ) / 2 ; return median ; } double median1 = arr [ size / 2 ] ; return median1 ; }
static void powerfulIntegers ( int x , int y , int bound ) { Set < Integer > s = new HashSet < > ( ) ; ArrayList < Integer > powersOfY = new ArrayList < > ( ) ; int i ; powersOfY . add ( 1 ) ; for ( i = y ; i < bound ; i = i * y ) powersOfY . add ( i ) ; i = 0 ; while ( true ) { int xPowI = ( int ) Math . pow ( ( double ) x , ( double ) i ) ; if ( xPowI >= bound ) break ; for ( int j = 0 ; j < powersOfY . size ( ) ; ++ j ) { int num = xPowI + powersOfY . get ( j ) ; if ( num <= bound ) s . add ( num ) ; else break ; } i ++ ; } Iterator itr = s . iterator ( ) ; while ( itr . hasNext ( ) ) { System . out . print ( itr . next ( ) + " ▁ " ) ; } }
public static boolean judgeSquareSum ( int n ) { for ( int i = 2 ; i * i <= n ; i ++ ) { int count = 0 ; if ( n % i == 0 ) { while ( n % i == 0 ) { count ++ ; n /= i ; } if ( i % 4 == 3 && count % 2 != 0 ) return false ; } } return n % 4 != 3 ; }
static int nthTerm ( int n ) { return ( int ) Math . pow ( n , 2 ) + 2 * n + 2 ; }
static float Cel_To_Fah ( float n ) { return ( ( n * 9.0f / 5.0f ) + 32.0f ) ; }
static int divisorSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) sum += ( n / i ) * i ; return sum ; }
static int centeredTetrahedralNumber ( int n ) { return ( 2 * n + 1 ) * ( n * n + n + 3 ) / 3 ; }
static int sumOfSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum = sum + ( 2 * i - 1 ) * ( 2 * i - 1 ) ; return sum ; }
static void countFreq ( int a [ ] , int n ) { int hm [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) hm [ a [ i ] ] ++ ; int cumul = 0 ; for ( int i = 0 ; i < n ; i ++ ) { cumul += hm [ a [ i ] ] ; if ( hm [ a [ i ] ] != 0 ) { System . out . println ( a [ i ] + " - > " + cumul ) ; } hm [ a [ i ] ] = 0 ; } }
public static int count_flips ( int a [ ] , int n , int k ) { boolean set = false ; int ans = 0 , min_diff = Integer . MAX_VALUE ; for ( int i = 0 ; i < k ; i ++ ) { int curr_index = i , segment = 0 , count_zero = 0 , count_one = 0 ; while ( curr_index < n ) { if ( segment % 2 == 0 ) { if ( a [ curr_index ] == 1 ) count_zero ++ ; else count_one ++ ; } else { if ( a [ curr_index ] == 0 ) count_zero ++ ; else count_one ++ ; } curr_index = curr_index + k ; segment ++ ; } ans += Math . min ( count_one , count_zero ) ; if ( count_one < count_zero ) set = ! set ; min_diff = Math . min ( min_diff , Math . abs ( count_zero - count_one ) ) ; } if ( set ) return ans ; else return ans + min_diff ; }
static int findNumber ( int n ) { int x = ( int ) Math . floor ( ( - 1 + Math . sqrt ( 1 + 8 * n - 8 ) ) / 2 ) ; int base = ( x * ( x + 1 ) ) / 2 + 1 ; return n - base + 1 ; }
static long countPairs ( int [ ] arr , int n ) { int count_2 = 0 , count_others = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 2 ) { count_2 ++ ; } else if ( arr [ i ] > 2 ) { count_others ++ ; } } long ans = 1L * count_2 * count_others + ( 1L * count_others * ( count_others - 1 ) ) / 2 ; return ans ; }
static int getMinimumOps ( int ar [ ] , int k ) { int n = ar . length ; int dp [ ] [ ] = new int [ n ] [ k + 1 ] ; dp [ 0 ] [ 1 ] = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int maxGroups = Math . min ( k , i + 1 ) ; for ( int j = 1 ; j <= maxGroups ; j ++ ) { dp [ i ] [ j ] = Integer . MAX_VALUE ; if ( j == 1 ) { int freq [ ] = new int [ 100000 ] ; int freqOfMode = 0 ; for ( int it = 0 ; it <= i ; it ++ ) { freq [ ar [ it ] ] ++ ; int newElementFreq = freq [ ar [ it ] ] ; if ( newElementFreq > freqOfMode ) freqOfMode = newElementFreq ; } dp [ i ] [ 1 ] = ( i + 1 ) - freqOfMode ; } else { int freq [ ] = new int [ 100000 ] ; int freqOfMode = 0 ; for ( int it = i ; it >= j - 1 ; it -- ) { freq [ ar [ it ] ] ++ ; int newElementFreq = freq [ ar [ it ] ] ; if ( newElementFreq > freqOfMode ) freqOfMode = newElementFreq ; int elementsToChange = i - it + 1 ; elementsToChange -= freqOfMode ; dp [ i ] [ j ] = Math . min ( dp [ it - 1 ] [ j - 1 ] + elementsToChange , dp [ i ] [ j ] ) ; } } } } return dp [ n - 1 ] [ k ] ; }
static int maxArea ( float perimeter ) { int length = ( int ) Math . ceil ( perimeter / 4 ) ; int breadth = ( int ) Math . floor ( perimeter / 4 ) ; return length * breadth ; }
static int getRemainder ( int num , int divisor ) { return ( num - divisor * ( num / divisor ) ) ; }
static boolean isDivisible ( int arr [ ] , int n ) { int lastDigit = arr [ n - 1 ] % 10 ; if ( lastDigit == 0 ) return true ; return false ; }
static char maxRepeating ( String str ) { int len = str . length ( ) ; int count = 0 ; char res = str . charAt ( 0 ) ; for ( int i = 0 ; i < len ; i ++ ) { int cur_count = 1 ; for ( int j = i + 1 ; j < len ; j ++ ) { if ( str . charAt ( i ) != str . charAt ( j ) ) break ; cur_count ++ ; } if ( cur_count > count ) { count = cur_count ; res = str . charAt ( i ) ; } } return res ; }
static void printFun ( int test ) { if ( test < 1 ) return ; else { System . out . printf ( " % d ▁ " , test ) ; printFun ( test - 1 ) ; System . out . printf ( " % d ▁ " , test ) ; return ; } }
static float rainDayProbability ( int a [ ] , int n ) { float count = 0 , m ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) count ++ ; } m = count / n ; return m ; }
static int minCost ( char [ ] s ) { boolean alphabets [ ] = new boolean [ 26 ] ; for ( int i = 0 ; i < s . length ; i ++ ) { alphabets [ ( int ) s [ i ] - 97 ] = true ; } int count = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( alphabets [ i ] ) { count ++ ; } } return count ; }
static int Largestpower ( int n , int p ) { int ans = 0 ; while ( n > 0 ) { n /= p ; ans += n ; } return ans ; }
static long hexadecagonalNum ( long n ) { return ( ( 14 * n * n ) - 12 * n ) / 2 ; }
static int calSum ( int n ) { int a = 3 , b = 0 , c = 2 ; if ( n == 0 ) return 3 ; if ( n == 1 ) return 3 ; if ( n == 2 ) return 5 ; int sum = 5 ; while ( n > 2 ) { int d = a + b ; sum += d ; a = b ; b = c ; c = d ; n -- ; } return sum ; }
static double sum ( int x , int n ) { double i , total = 1.0 ; for ( i = 1 ; i <= n ; i ++ ) total = total + ( Math . pow ( x , i ) / i ) ; return total ; }
static int max_sum ( int a [ ] , int n ) { int [ ] [ ] dp = new int [ n + 1 ] [ 2 ] ; dp [ 0 ] [ 0 ] = 0 ; dp [ 0 ] [ 1 ] = - 999999 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { dp [ i + 1 ] [ 0 ] = Math . max ( dp [ i ] [ 0 ] + a [ i ] , dp [ i ] [ 1 ] - a [ i ] ) ; dp [ i + 1 ] [ 1 ] = Math . max ( dp [ i ] [ 0 ] - a [ i ] , dp [ i ] [ 1 ] + a [ i ] ) ; } return dp [ n ] [ 0 ] ; }
static int minimumIncrease ( int a , int b , int c ) { int arr [ ] = { a , b , c } ; Arrays . sort ( arr ) ; if ( arr [ 0 ] + arr [ 1 ] >= arr [ 2 ] ) return 0 ; else return arr [ 2 ] - ( arr [ 0 ] + arr [ 1 ] ) ; }
static int countPairs ( int n ) { int count = 0 ; for ( int x = 1 ; x < n ; x ++ ) { for ( int y = x + 1 ; y <= n ; y ++ ) { if ( ( y + x ) % ( y ^ x ) == 0 ) count ++ ; } } return count ; }
static void sortString ( String str ) { char [ ] arr = str . toCharArray ( ) ; Arrays . sort ( arr ) ; System . out . print ( String . valueOf ( arr ) ) ; }
static int term ( int n ) { return n * ( n + 1 ) / 2 ; }
static boolean validateStackSequence ( int pushed [ ] , int popped [ ] , int len ) { int j = 0 ; Stack < Integer > st = new Stack < > ( ) ; for ( int i = 0 ; i < len ; i ++ ) { st . push ( pushed [ i ] ) ; while ( ! st . empty ( ) && j < len && st . peek ( ) == popped [ j ] ) { st . pop ( ) ; j ++ ; } } return j == len ; }
static int getMinimumSum ( int arr [ ] , int n ) { int ans = Integer . MAX_VALUE ; for ( int i = 0 ; i < n - 2 ; i ++ ) { for ( int j = i + 1 ; j < n - 1 ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { ans = Math . min ( ans , arr [ i ] + arr [ j ] + arr [ k ] ) ; } } } return ans ; }
static void perfectCube ( int N ) { int cube ; for ( int i = 0 ; i <= N ; i ++ ) { cube = i * i * i ; if ( cube == N ) { System . out . println ( " Yes " ) ; return ; } else if ( cube > N ) { System . out . println ( " NO " ) ; return ; } } }
static int longest_gap ( int N ) { int distance = 0 , count = 0 , first_1 = - 1 , last_1 = - 1 ; while ( N != 0 ) { count ++ ; int r = N & 1 ; if ( r == 1 ) { first_1 = first_1 == - 1 ? count : first_1 ; last_1 = count ; } N = N / 2 ; } if ( last_1 <= first_1 ) { return - 1 ; } else { distance = ( last_1 - first_1 - 1 ) ; return distance ; } }
static int findMaxValue ( int [ ] arr , int n ) { if ( n < 4 ) { System . out . println ( " The ▁ array ▁ should ▁ have " + " ▁ atleast ▁ 4 ▁ elements " ) ; } int table1 [ ] = new int [ n + 1 ] ; int table2 [ ] = new int [ n ] ; int table3 [ ] = new int [ n - 1 ] ; int table4 [ ] = new int [ n - 2 ] ; Arrays . fill ( table1 , Integer . MIN_VALUE ) ; Arrays . fill ( table2 , Integer . MIN_VALUE ) ; Arrays . fill ( table3 , Integer . MIN_VALUE ) ; Arrays . fill ( table4 , Integer . MIN_VALUE ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { table1 [ i ] = Math . max ( table1 [ i + 1 ] , arr [ i ] ) ; } for ( int i = n - 2 ; i >= 0 ; i -- ) { table2 [ i ] = Math . max ( table2 [ i + 1 ] , table1 [ i + 1 ] - arr [ i ] ) ; } for ( int i = n - 3 ; i >= 0 ; i -- ) table3 [ i ] = Math . max ( table3 [ i + 1 ] , table2 [ i + 1 ] + arr [ i ] ) ; for ( int i = n - 4 ; i >= 0 ; i -- ) table4 [ i ] = Math . max ( table4 [ i + 1 ] , table3 [ i + 1 ] - arr [ i ] ) ; return table4 [ 0 ] ; }
static int squaresum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( i * i ) ; return sum ; }
static int count ( int arr [ ] [ ] ) { int diag1 = 0 , diag2 = 0 ; int row = 0 , col = 0 , count = 0 ; for ( int i = 0 , j = n - 1 ; i < n ; i ++ , j -- ) { diag1 += arr [ i ] [ i ] ; diag2 += arr [ i ] [ j ] ; } for ( int i = 0 ; i < n ; i ++ ) { row = 0 ; col = 0 ; for ( int j = 0 ; j < n ; j ++ ) { row = row + arr [ i ] [ j ] ; } for ( int j = 0 ; j < n ; j ++ ) { col = col + arr [ j ] [ i ] ; } if ( ( row == diag1 ) || ( row == diag2 ) ) count ++ ; if ( ( col == diag1 ) || ( col == diag2 ) ) count ++ ; } return count ; }
static int findMinDifference ( int arr [ ] , int n ) { int min , secondMin , max , secondMax ; min = secondMax = ( arr [ 0 ] < arr [ 1 ] ) ? arr [ 0 ] : arr [ 1 ] ; max = secondMin = ( arr [ 0 ] < arr [ 1 ] ) ? arr [ 1 ] : arr [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) { if ( arr [ i ] > max ) { secondMax = max ; max = arr [ i ] ; } else if ( arr [ i ] > secondMax ) { secondMax = arr [ i ] ; } else if ( arr [ i ] < min ) { secondMin = min ; min = arr [ i ] ; } else if ( arr [ i ] < secondMin ) { secondMin = arr [ i ] ; } } int diff = Math . min ( max - secondMin , secondMax - min ) ; return diff ; }
static int minItems ( int k , int r ) { for ( int i = 1 ; i < 10 ; i ++ ) if ( ( i * k - r ) % 10 == 0 || ( i * k ) % 10 == 0 ) return i ; return 10 ; }
static int max_intersection ( int center [ ] , int length , int k ) { Arrays . sort ( center ) ; if ( center [ 2 ] - center [ 0 ] >= 2 * k + length ) { return 0 ; } else if ( center [ 2 ] - center [ 0 ] >= 2 * k ) { return ( 2 * k - ( center [ 2 ] - center [ 0 ] - length ) ) ; } else return length ; }
static int maxProfit ( int profitA [ ] , int profitB [ ] , int n ) { int preSum [ ] = new int [ n ] ; preSum [ 0 ] = profitA [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { preSum [ i ] = preSum [ i - 1 ] + profitA [ i ] ; } int suffSum [ ] = new int [ n ] ; suffSum [ n - 1 ] = profitB [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { suffSum [ i ] = suffSum [ i + 1 ] + profitB [ i ] ; } int res = preSum [ n - 1 ] ; for ( int i = 1 ; i < n - 1 ; i ++ ) { res = Math . max ( res , preSum [ i ] + suffSum [ i + 1 ] ) ; } res = Math . max ( res , suffSum [ 0 ] ) ; return res ; }
static int getMissingNo ( int a [ ] , int n ) { int i , total ; total = ( n + 1 ) * ( n + 2 ) / 2 ; for ( i = 0 ; i < n ; i ++ ) total -= a [ i ] ; return total ; }
public static void subArraySum ( int [ ] arr , int n , int sum ) { int cur_sum = 0 ; int start = 0 ; int end = - 1 ; HashMap < Integer , Integer > hashMap = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { cur_sum = cur_sum + arr [ i ] ; if ( cur_sum - sum == 0 ) { start = 0 ; end = i ; break ; } if ( hashMap . containsKey ( cur_sum - sum ) ) { start = hashMap . get ( cur_sum - sum ) + 1 ; end = i ; break ; } hashMap . put ( cur_sum , i ) ; } if ( end == - 1 ) { System . out . println ( " No ▁ subarray ▁ with ▁ given ▁ sum ▁ exists " ) ; } else { System . out . println ( " Sum ▁ found ▁ between ▁ indexes ▁ " + start + " ▁ to ▁ " + end ) ; } }
static double calTime ( double arr [ ] , int n ) { double work = 0 ; for ( int i = 0 ; i < n ; i ++ ) work += 1 / arr [ i ] ; return 1 / work ; }
static void SieveOfEratosthenes ( ) { for ( int i = 0 ; i <= MAX ; i ++ ) prime [ i ] = true ; for ( int i = 0 ; i <= MAX ; i ++ ) sum [ i ] = 0 ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } } for ( int i = 1 ; i <= MAX ; i ++ ) { if ( prime [ i ] == true ) sum [ i ] = 1 ; sum [ i ] += sum [ i - 1 ] ; } }
static void printDistinct ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] == arr [ j ] ) break ; if ( i == j ) System . out . print ( arr [ i ] + " ▁ " ) ; } }
static int findMinimumX ( int a [ ] , int n ) { Set < Integer > st = new HashSet < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) st . add ( a [ i ] ) ; if ( st . size ( ) == 1 ) return 0 ; if ( st . size ( ) == 2 ) { Iterator < Integer > it = st . iterator ( ) ; int el1 = it . next ( ) ; int el2 = it . next ( ) ; if ( ( el2 - el1 ) % 2 == 0 ) return ( el2 - el1 ) / 2 ; else return ( el2 - el1 ) ; } if ( st . size ( ) == 3 ) { Iterator < Integer > it = st . iterator ( ) ; int el1 = it . next ( ) ; int el2 = it . next ( ) ; int el3 = it . next ( ) ; if ( ( el2 - el1 ) == ( el3 - el2 ) ) return el2 - el1 ; else return - 1 ; } return - 1 ; }
static int grayCode ( int n ) { return n ^ ( n >> 1 ) ; }
static int oddEquivalent ( String s , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == '1' ) count ++ ; } return count ; }
static int nthTerm ( int n ) { return ( int ) Math . pow ( n , 2 ) - 2 * n + 2 ; }
static void findTriangles ( int n ) { int num ; num = n * ( n - 4 ) ; System . out . println ( num ) ; }
static long removeRecur ( long n ) { long prev_digit = n % 10 ; long pow = 10 ; long res = prev_digit ; while ( n > 0 ) { long curr_digit = n % 10 ; if ( curr_digit != prev_digit ) { res += curr_digit * pow ; prev_digit = curr_digit ; pow *= 10 ; } n = n / 10 ; } return res ; }
static int countOddSquares ( int n , int m ) { return ( int ) Math . pow ( m , 0.5 ) - ( int ) Math . pow ( n - 1 , 0.5 ) ; }
static int sumKRepeating ( int arr [ ] , int n , int k ) { int sum = 0 ; HashMap < Integer , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! mp . containsKey ( arr [ i ] ) ) mp . put ( arr [ i ] , 0 ) ; mp . put ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } for ( Integer x : mp . keySet ( ) ) if ( mp . get ( x ) == k ) sum += x ; return sum ; }
static void findNumbers ( int n , int b ) { double even = 0 , odd = 0 ; if ( b % 2 == 0 ) { even = Math . pow ( b , n ) - 2 ; odd = Math . pow ( b , n ) - 1 ; } else { even = Math . pow ( b , n ) - 1 ; odd = Math . pow ( b , n ) - 2 ; } System . out . println ( " Even ▁ Number ▁ = ▁ " + ( int ) even ) ; System . out . print ( " Odd ▁ Number ▁ = ▁ " + ( int ) odd ) ; }
static int pairORSum ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) ans += arr [ i ] ^ arr [ j ] ; return ans ; }
static int CountSubSet ( int arr [ ] , int n , int X ) { int N = ( int ) Math . pow ( 2 , n ) ; int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( ( i & ( 1 << j ) ) != 0 ) if ( arr [ j ] == X ) count += 1 ; } } return count ; }
static int lis ( int [ ] arr , int n ) { int max = 0 ; int [ ] lst = new int [ n ] ; Arrays . fill ( lst , 1 ) ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ i ] > arr [ j ] && lst [ i ] < lst [ j ] + 1 ) lst [ i ] = lst [ j ] + 1 ; } } for ( int i = 0 ; i < n ; i ++ ) if ( max < lst [ i ] ) max = lst [ i ] ; return max ; }
static int distinctCount ( int arr [ ] , int n ) { Set < Integer > s = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) s . add ( Math . abs ( arr [ i ] ) ) ; return s . size ( ) ; }
static int MaximumDivisors ( int X , int Y ) { int [ ] arr = new int [ Y - X + 1 ] ; for ( int i = 0 ; i < arr . length ; i ++ ) arr [ i ] = 0 ; int mx = 0 ; int cnt = 0 ; for ( int i = 1 ; i * i <= Y ; i ++ ) { int sq = i * i ; int first_divisible ; if ( ( X / i ) * i >= X ) first_divisible = ( X / i ) * i ; else first_divisible = ( X / i + 1 ) * i ; for ( int j = first_divisible ; j <= Y ; j += i ) { if ( j < sq ) continue ; else if ( j == sq ) arr [ j - X ] ++ ; else arr [ j - X ] += 2 ; } } for ( int i = X ; i <= Y ; i ++ ) { if ( arr [ i - X ] > mx ) { cnt = 1 ; mx = arr [ i - X ] ; } else if ( arr [ i - X ] == mx ) cnt ++ ; } return cnt ; }
static String printString ( int n , String str ) { String str2 = " " ; int extraChar = n % 26 ; if ( extraChar >= 1 ) { for ( int i = 26 - ( extraChar + 1 ) ; i <= 25 ; i ++ ) { str2 += str . charAt ( i ) ; } } int countOfStr = n / 26 ; for ( int i = 1 ; i <= countOfStr ; i ++ ) { for ( int j = 0 ; j < 26 ; j ++ ) { str2 += str . charAt ( j ) ; } } return str2 ; }
static void greaterK ( int n , int k ) { int [ ] p = new int [ String . valueOf ( n ) . length ( ) + 2 ] ; int index = 0 ; int x = n ; while ( x > 0 ) { p [ index ] = ( int ) ( x % k ) ; x /= k ; index ++ ; } int idx = 0 ; for ( int i = 0 ; i < p . length - 1 ; ++ i ) { if ( p [ i ] >= 2 ) { p [ i ] = 0 ; p [ i + 1 ] ++ ; for ( int j = idx ; j < i ; ++ j ) { p [ j ] = 0 ; } idx = i + 1 ; } if ( p [ i ] == k ) { p [ i ] = 0 ; p [ i + 1 ] ++ ; } } int j = p . length - 1 ; if ( p [ j ] >= 2 ) { p [ index ] = 1 ; index ++ ; } int ans = 0 ; for ( int i = p . length - 1 ; i >= 0 ; -- i ) { ans = ans * k + p [ i ] ; } System . out . print ( ans + " \n " ) ; }
static void line ( double x0 , double y0 ) { double c = ( int ) ( 2 * y0 * x0 ) ; System . out . println ( y0 + " x " + " ▁ + ▁ " + x0 + " y ▁ = ▁ " + c ) ; }
static char NthCharacter ( int n ) { String s = " " ; int c = 1 ; for ( int i = 1 ; ; i ++ ) { if ( c < 10 ) s += Integer . toString ( c ) ; else { String s1 = " " ; int dup = c ; while ( dup > 0 ) { s1 += Integer . toString ( dup % 10 ) ; dup /= 10 ; } StringBuilder temp = new StringBuilder ( ) ; temp . append ( s1 ) ; temp = temp . reverse ( ) ; s += temp ; } c ++ ; if ( s . length ( ) >= n ) { return s . charAt ( n - 1 ) ; } } }
static int maxLength ( int arr [ ] , int N ) { int product = 1 , len = 0 ; for ( int i = 0 ; i < N ; i ++ ) { product *= arr [ i ] ; } if ( product >= 0 ) { return N ; } for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] < 0 ) { len = Math . max ( len , Math . max ( N - i - 1 , i ) ) ; } } return len ; }
static int countMultiples ( int n ) { return n / 3 + n / 7 - n / 21 ; }
public static double maxEdges ( double N ) { double edges = 0 ; edges = Math . floor ( ( N * N ) / 4 ) ; return edges ; }
static void printSum ( int m [ ] , int s [ ] , int n ) { int total = 0 ; for ( int i = 0 ; i < n ; i ++ ) { total += s [ i ] ; total += ( m [ i ] * 60 ) ; } System . out . print ( total / 3600 + " ▁ : ▁ " ) ; total %= 3600 ; System . out . print ( total / 60 + " : ▁ " ) ; total %= 60 ; System . out . println ( total ) ; }
static int findEle ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == sum - arr [ i ] ) return arr [ i ] ; return - 1 ; }
static void findTriangles ( int n ) { int num = n ; System . out . print ( num + " ▁ " ) ; System . out . print ( num * ( num - 4 ) * ( num - 5 ) / 6 ) ; }
static int center_nonadecagon_num ( int n ) { return ( 19 * n * n - 19 * n + 2 ) / 2 ; }
static void minReplacement ( String str ) { if ( str . length ( ) > 26 ) { System . out . println ( " IMPOSSIBLE " ) ; } else { int hash [ ] = new int [ 26 ] ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { hash [ str . charAt ( i ) - ' a ' ] ++ ; } int count = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( hash [ str . charAt ( i ) - ' a ' ] > 1 ) { for ( int j = 0 ; j < 26 ; j ++ ) { if ( hash [ j ] == 0 ) { hash [ str . charAt ( i ) - ' a ' ] -- ; str = str . substring ( 0 , i ) + ( char ) ( j + ' a ' ) + str . substring ( i + 1 ) ; hash [ j ] ++ ; break ; } } } } System . out . println ( str ) ; } }
public static void check ( int n , int x , int y ) { long fact = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { fact *= i ; } long divisor = ( long ) Math . pow ( x , y ) ; if ( fact % divisor == 0 ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; }
static int no_of_ways ( int a [ ] , int n ) { int count_0 = 0 , count_1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) count_0 ++ ; else count_1 ++ ; } if ( count_1 % 2 == 0 ) return count_0 ; else return count_1 ; }
public static int findNth ( int n ) { int count = 0 ; for ( int curr = 19 ; ; curr += 9 ) { int sum = 0 ; for ( int x = curr ; x > 0 ; x = x / 10 ) sum = sum + x % 10 ; if ( sum == 10 ) count ++ ; if ( count == n ) return curr ; } }
static float calcProbability ( int M [ ] [ ] , int k ) { float dp [ ] [ ] = new float [ m ] [ n ] ; float sum [ ] = new float [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { dp [ 0 ] [ j ] = M [ 0 ] [ j ] ; sum [ 0 ] = sum [ 0 ] + dp [ 0 ] [ j ] ; } for ( int i = 1 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { dp [ i ] [ j ] += dp [ i - 1 ] [ j ] / sum [ i - 1 ] + M [ i ] [ j ] ; sum [ i ] += dp [ i ] [ j ] ; } } return dp [ n - 1 ] [ k - 1 ] / sum [ n - 1 ] ; }
static void kFactors ( int n , int k ) { ArrayList < Integer > P = new ArrayList < Integer > ( ) ; while ( n % 2 == 0 ) { P . add ( 2 ) ; n /= 2 ; } for ( int i = 3 ; i * i <= n ; i = i + 2 ) { while ( n % i == 0 ) { n = n / i ; P . add ( i ) ; } } if ( n > 2 ) P . add ( n ) ; if ( P . size ( ) < k ) { System . out . println ( " - 1" ) ; return ; } for ( int i = 0 ; i < k - 1 ; i ++ ) System . out . print ( P . get ( i ) + " , ▁ " ) ; int product = 1 ; for ( int i = k - 1 ; i < P . size ( ) ; i ++ ) product = product * P . get ( i ) ; System . out . println ( product ) ; }
static boolean isSumOfPowersOfTwo ( int n ) { if ( n % 2 == 1 ) return false ; else return true ; }
static void findNumbers ( int arr [ ] , int n ) { int sumN = ( n * ( n + 1 ) ) / 2 ; int sumSqN = ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; int sum = 0 , sumSq = 0 , i ; for ( i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; sumSq += Math . pow ( arr [ i ] , 2 ) ; } int B = ( ( ( sumSq - sumSqN ) / ( sum - sumN ) ) + sumN - sum ) / 2 ; int A = sum - sumN + B ; System . out . println ( " A ▁ = ▁ " + A + " \n B ▁ = ▁ " + B ) ; }
static int sumOfDivisblePowers ( int L , int R , int P ) { int res = 0 ; for ( int i = L ; i <= R ; i ++ ) { int x = i ; while ( x % P == 0 ) { res ++ ; x /= P ; } } return res ; }
public static int pell ( int n ) { if ( n <= 2 ) return n ; return 2 * pell ( n - 1 ) + pell ( n - 2 ) ; }
static int countSubArrays ( int arr [ ] , int n , int K ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { int bitwise_or = 0 ; for ( int k = i ; k <= j ; k ++ ) { bitwise_or = bitwise_or | arr [ k ] ; } if ( bitwise_or >= K ) count ++ ; } } return count ; }
static int countNumber ( int n ) { int result = 0 ; for ( int i = 1 ; i <= 9 ; i ++ ) { Stack < Integer > s = new Stack < > ( ) ; if ( i <= n ) { s . push ( i ) ; result ++ ; } while ( ! s . empty ( ) ) { int tp = s . peek ( ) ; s . pop ( ) ; for ( int j = tp % 10 ; j <= 9 ; j ++ ) { int x = tp * 10 + j ; if ( x <= n ) { s . push ( x ) ; result ++ ; } } } } return result ; }
static int findMaxDiff ( int arr [ ] , int n ) { if ( n < 2 ) { System . out . print ( " Invalid ▁ " ) ; return 0 ; } int res = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( res < ( arr [ i ] - arr [ j ] - i + j ) ) res = ( arr [ i ] - arr [ j ] - i + j ) ; return res ; }
static long fun ( int marks [ ] , int n ) { long dp [ ] = new long [ n ] ; int temp ; for ( int i = 0 ; i < n ; i ++ ) dp [ i ] = 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( marks [ i ] > marks [ i + 1 ] ) { temp = i ; while ( true ) { if ( ( marks [ temp ] > marks [ temp + 1 ] ) && temp >= 0 ) { if ( dp [ temp ] > dp [ temp + 1 ] ) { temp -= 1 ; continue ; } else { dp [ temp ] = dp [ temp + 1 ] + 1 ; temp -= 1 ; } } else break ; } } else if ( marks [ i ] < marks [ i + 1 ] ) dp [ i + 1 ] = dp [ i ] + 1 ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += dp [ i ] ; return sum ; }
static int maxLen ( int [ ] arr , int n ) { int min_val = Arrays . stream ( arr ) . min ( ) . getAsInt ( ) ; int freq = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == min_val ) freq ++ ; } return freq ; }
static float normal ( float m , float n ) { float N = ( float ) ( ( Math . abs ( m ) * Math . abs ( n ) ) / Math . sqrt ( ( Math . abs ( m ) * Math . abs ( m ) ) + ( Math . abs ( n ) * Math . abs ( n ) ) ) ) ; return N ; }
static int findNumber ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int max = arr [ n - 1 ] ; int table [ ] = new int [ ( 2 * max ) + 1 ] ; table [ 0 ] = 0 ; for ( int i = 1 ; i < ( 2 * max ) + 1 ; i ++ ) table [ i ] = Integer . MAX_VALUE ; int ans = - 1 ; for ( int i = 1 ; i < ( 2 * max ) + 1 ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] <= i ) { int res = table [ i - arr [ j ] ] ; if ( res != Integer . MAX_VALUE && res + 1 < table [ i ] ) table [ i ] = res + 1 ; } } if ( i > arr [ n - 1 ] && table [ i ] == Integer . MAX_VALUE ) { ans = i ; break ; } } return ans ; }
static int setBitNumber ( int n ) { n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; n = n + 1 ; return ( n >> 1 ) ; }
static void permutatedRows ( int mat [ ] [ ] , int m , int n , int r ) { LinkedHashSet < Integer > s = new LinkedHashSet < > ( ) ; for ( int j = 0 ; j < n ; j ++ ) s . add ( mat [ r ] [ j ] ) ; for ( int i = 0 ; i < m ; i ++ ) { if ( i == r ) continue ; int j ; for ( j = 0 ; j < n ; j ++ ) if ( ! s . contains ( mat [ i ] [ j ] ) ) break ; if ( j != n ) continue ; System . out . print ( i + " , ▁ " ) ; } }
static void findMajority ( int arr [ ] , int n ) { int maxCount = 0 ; int index = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ i ] == arr [ j ] ) count ++ ; } if ( count > maxCount ) { maxCount = count ; index = i ; } } if ( maxCount > n / 2 ) System . out . println ( arr [ index ] ) ; else System . out . println ( " No ▁ Majority ▁ Element " ) ; }
static void printSubArrays ( int [ ] arr , int start , int end ) { if ( end == arr . length ) return ; else if ( start > end ) printSubArrays ( arr , 0 , end + 1 ) ; else { System . out . print ( " [ " ) ; for ( int i = start ; i < end ; i ++ ) { System . out . print ( arr [ i ] + " , ▁ " ) ; } System . out . println ( arr [ end ] + " ] " ) ; printSubArrays ( arr , start + 1 , end ) ; } return ; }
static boolean multipleOfThree ( int K , int dig0 , int dig1 ) { long sum = 0 ; int temp = ( dig0 + dig1 ) % 10 ; sum = dig0 + dig1 ; if ( K == 2 ) { if ( sum % 3 == 0 ) return true ; else return false ; } sum += temp ; long numberofGroups = ( K - 3 ) / 4 ; int remNumberofDigits = ( K - 3 ) % 4 ; sum += ( numberofGroups * 20 ) ; for ( int i = 0 ; i < remNumberofDigits ; i ++ ) { temp = ( 2 * temp ) % 10 ; sum += temp ; } if ( sum % 3 == 0 ) return true ; else return false ; }
static int countDigit ( int n ) { boolean prime [ ] = new boolean [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) prime [ i ] = false ; prime [ 2 ] = prime [ 3 ] = true ; prime [ 5 ] = prime [ 7 ] = true ; int temp = n , count = 0 ; while ( temp != 0 ) { int d = temp % 10 ; temp /= 10 ; if ( d > 0 && n % d == 0 && prime [ d ] == true ) count ++ ; } return count ; }
static long getSum ( int n , int d ) { long sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i % 10 == d ) sum += i ; } return sum ; }
public static int Valid ( int a , int b , int c ) { if ( a + b + c == 180 && a != 0 && b != 0 && c != 0 ) return 1 ; else return 0 ; }
public static int minOperations ( int [ ] a , int n , int K ) { HashMap < Integer , Boolean > map = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( map . containsKey ( a [ i ] ) ) return 0 ; map . put ( a [ i ] , true ) ; } int [ ] b = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) b [ i ] = a [ i ] | K ; map . clear ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] != b [ i ] ) map . put ( b [ i ] , true ) ; } for ( int i = 0 ; i < n ; i ++ ) { if ( map . containsKey ( a [ i ] ) ) return 1 ; } map . clear ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( map . containsKey ( b [ i ] ) ) return 2 ; map . put ( b [ i ] , true ) ; } return - 1 ; }
static double square ( double a ) { if ( a < 0 ) return - 1 ; double x = 0.464 * a ; return x ; }
static int getModulo ( int n , int d ) { return ( n & ( d - 1 ) ) ; }
static long sumOfLastDig ( long n , long m ) { long sum = 0 , k ; k = n / m ; long [ ] arr = new long [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { arr [ i ] = m * ( i + 1 ) % 10 ; sum += arr [ i ] ; } long rem = k % 10 ; long ans = ( k / 10 ) * sum ; for ( int i = 0 ; i < rem ; i ++ ) { ans += arr [ i ] ; } return ans ; }
static void prime ( int arr [ ] , int n ) { int max_val = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; Vector < Boolean > prime = new Vector < Boolean > ( ) ; for ( int i = 0 ; i < max_val + 1 ; i ++ ) prime . add ( Boolean . TRUE ) ; prime . add ( 0 , Boolean . FALSE ) ; prime . add ( 1 , Boolean . FALSE ) ; for ( int p = 2 ; p * p <= max_val ; p ++ ) { if ( prime . get ( p ) == true ) { for ( int i = p * 2 ; i <= max_val ; i += p ) prime . add ( i , Boolean . FALSE ) ; } } int minimum = Integer . MAX_VALUE ; int maximum = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) if ( prime . get ( arr [ i ] ) ) { minimum = Math . min ( minimum , arr [ i ] ) ; maximum = Math . max ( maximum , arr [ i ] ) ; } System . out . println ( " Minimum ▁ : ▁ " + minimum ) ; System . out . println ( " Maximum ▁ : ▁ " + maximum ) ; }
static boolean isPower ( int n ) { for ( int x = 2 ; x <= Math . sqrt ( n ) ; x ++ ) { int p = x ; while ( p <= n ) { p = p * x ; if ( p == n ) return true ; } } return false ; }
static boolean isRotation ( long x , long y ) { long x64 = x | ( x << 32 ) ; while ( x64 >= y ) { if ( x64 == y ) { return true ; } x64 >>= 1 ; } return false ; }
static int mod ( String num , int a ) { int res = 0 ; for ( int i = 0 ; i < num . length ( ) ; i ++ ) res = ( res * 10 + ( int ) num . charAt ( i ) - '0' ) % a ; return res ; }
static void printRepeating ( Integer [ ] arr , int size ) { SortedSet < Integer > s = new TreeSet < > ( ) ; Collections . addAll ( s , arr ) ; System . out . print ( s ) ; }
static boolean isDefeat ( String s1 , String s2 , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( ( s1 . charAt ( i ) == '0' && s2 . charAt ( i ) == '1' ) || ( s1 . charAt ( i ) == '1' && s2 . charAt ( i ) == '0' ) ) continue ; else if ( ( s1 . charAt ( i ) == '0' && s2 . charAt ( i ) == ' Z ' ) || ( s1 . charAt ( i ) == ' Z ' && s2 . charAt ( i ) == '0' ) ) continue ; else { return true ; } } return false ; }
static int getInvCount ( int n ) { int inv_count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] > arr [ j ] ) inv_count ++ ; return inv_count ; }
static int KthMinValAfterMconcatenate ( int [ ] A , int N , int M , int K ) { Arrays . sort ( A ) ; return ( A [ ( ( K - 1 ) / M ) ] ) ; }
static int findNum ( int div [ ] , int rem [ ] , int N ) { int num = rem [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; i -- ) { num = num * div [ i ] + rem [ i ] ; } return num ; }
static void printGP ( int a , int r , int n ) { int curr_term ; for ( int i = 0 ; i < n ; i ++ ) { curr_term = a * ( int ) Math . pow ( r , i ) ; System . out . print ( curr_term + " ▁ " ) ; } }
static int MinimumCost ( int a [ ] , int n , int x ) { for ( int i = 1 ; i < n ; i ++ ) { a [ i ] = Math . min ( a [ i ] , 2 * a [ i - 1 ] ) ; } int ind = 0 ; int sum = 0 ; while ( x > 0 ) { if ( x != 0 ) sum += a [ ind ] ; ind ++ ; x = x >> 1 ; } return sum ; }
static boolean possibleToReach ( int a , int b ) { int c = ( int ) Math . cbrt ( a * b ) ; int re1 = a / c ; int re2 = b / c ; if ( ( re1 * re1 * re2 == a ) && ( re2 * re2 * re1 == b ) ) return true ; else return false ; }
static float Time ( float arr [ ] , int n , float Emptypipe ) { float fill = 0 ; for ( int i = 0 ; i < n ; i ++ ) fill += 1 / arr [ i ] ; fill = fill - ( 1 / ( float ) Emptypipe ) ; return 1 / fill ; }
static int findMissing ( int arr [ ] , int n , int k , int avg ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } int num = ( avg * ( n + k ) ) - sum ; int den = k ; if ( num % den != 0 ) return - 1 ; return ( int ) ( num / den ) ; }
static void last_digit ( int X , int Y ) { System . out . print ( X % Y ) ; }
static void max_element ( int a [ ] , int n ) { int [ ] pre = new int [ n ] ; pre [ 0 ] = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) pre [ i ] = Math . max ( pre [ i - 1 ] , a [ i ] ) ; int [ ] suf = new int [ n ] ; suf [ n - 1 ] = a [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) suf [ i ] = Math . max ( suf [ i + 1 ] , a [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i == 0 ) System . out . print ( suf [ i + 1 ] + " ▁ " ) ; else if ( i == n - 1 ) System . out . print ( pre [ i - 1 ] + " ▁ " ) ; else System . out . print ( Math . max ( pre [ i - 1 ] , suf [ i + 1 ] ) + " ▁ " ) ; } }
static boolean checkSubarraySum ( int arr [ ] , int n , int k , int sum ) { for ( int i = 0 ; i < n - k + 1 ; i ++ ) { int current_sum = 0 ; for ( int j = 0 ; j < k ; j ++ ) current_sum = current_sum + arr [ i + j ] ; if ( current_sum == sum ) return true ; } return false ; }
static float Area ( float a ) { if ( a < 0 ) return - 1 ; float h = ( float ) 1.268 * a ; float A = ( float ) ( 0.70477 * Math . pow ( h , 2 ) ) ; return A ; }
static int operations ( int op [ ] , int n , int k ) { int i , count = 0 ; int nVal = 0 ; int min = Integer . MAX_VALUE ; for ( i = 0 ; i < n ; i ++ ) { nVal += op [ i ] ; min = Math . min ( min , nVal ) ; if ( ( k + nVal ) <= 0 ) return ( i + 1 ) ; } if ( nVal >= 0 ) return - 1 ; int times = ( k - Math . abs ( min ) ) / Math . abs ( nVal ) ; k = ( k - ( times * Math . abs ( nVal ) ) ) ; count = ( times * n ) ; while ( k > 0 ) { for ( i = 0 ; i < n ; i ++ ) { k = k + op [ i ] ; count ++ ; if ( k <= 0 ) break ; } } return count ; }
static int getOccurence ( int n , int d ) { int result = 0 ; int itr = d ; while ( itr <= n ) { if ( itr % 10 == d ) result ++ ; if ( itr != 0 && itr / 10 == d ) { result ++ ; itr ++ ; } else if ( itr / 10 == d - 1 ) itr = itr + ( 10 - d ) ; else itr = itr + 10 ; } return result ; }
static int countSequences ( int arr [ ] , int n ) { int count = 1 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] + 1 != arr [ i + 1 ] ) count ++ ; return count ; }
public static int find ( int n , int k ) { if ( n + 1 >= k ) return ( k - 1 ) ; else return ( 2 * n + 1 - k ) ; }
static void interLeaveQueue ( Queue < Integer > q ) { if ( q . size ( ) % 2 != 0 ) System . out . println ( " Input ▁ even ▁ number ▁ of ▁ integers . " ) ; Stack < Integer > s = new Stack < > ( ) ; int halfSize = q . size ( ) / 2 ; for ( int i = 0 ; i < halfSize ; i ++ ) { s . push ( q . peek ( ) ) ; q . poll ( ) ; } while ( ! s . empty ( ) ) { q . add ( s . peek ( ) ) ; s . pop ( ) ; } for ( int i = 0 ; i < halfSize ; i ++ ) { q . add ( q . peek ( ) ) ; q . poll ( ) ; } for ( int i = 0 ; i < halfSize ; i ++ ) { s . push ( q . peek ( ) ) ; q . poll ( ) ; } while ( ! s . empty ( ) ) { q . add ( s . peek ( ) ) ; s . pop ( ) ; q . add ( q . peek ( ) ) ; q . poll ( ) ; } }
static boolean divisibleBy36 ( String num ) { int l = num . length ( ) ; if ( l == 0 ) return false ; if ( l == 1 && num . charAt ( 0 ) != '0' ) return false ; int two_digit_num = ( num . charAt ( l - 2 ) - '0' ) * 10 + ( num . charAt ( l - 1 ) - '0' ) ; if ( two_digit_num % 4 != 0 ) return false ; int sum = 0 ; for ( int i = 0 ; i < l ; i ++ ) sum += ( num . charAt ( i ) - '0' ) ; if ( sum % 9 != 0 ) return false ; return true ; }
static int countWays ( int n , int m ) { int count [ ] = new int [ n + 1 ] ; count [ 0 ] = 0 ; int i ; for ( i = 1 ; i <= n ; i ++ ) { if ( i > m ) count [ i ] = count [ i - 1 ] + count [ i - m ] ; else if ( i < m ) count [ i ] = 1 ; else count [ i ] = 2 ; } return count [ n ] ; }
static int countReduce ( String str ) { int n = str . length ( ) ; int res = 0 ; for ( int i = 0 ; i < n / 2 ; i ++ ) res += Math . abs ( str . charAt ( i ) - str . charAt ( n - i - 1 ) ) ; return res ; }
static int countSetBits ( int n ) { int count = 0 ; while ( n > 0 ) { n &= ( n - 1 ) ; count ++ ; } return count ; }
static long countSubstr ( String s , int k ) { int n = s . length ( ) ; int l = n - 1 ; int r = n - 1 ; int [ ] arr = new int [ n ] ; int last_indexof1 = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == '1' ) { arr [ i ] = i ; last_indexof1 = i ; } else { arr [ i ] = last_indexof1 ; } } long no_of_substr = 0 ; for ( r = n - 1 ; r >= 0 ; r -- ) { l = r ; while ( l >= 0 && ( r - l + 1 ) <= 64 && Integer . valueOf ( s . substring ( l , r + 1 ) , 2 ) < k ) { l -- ; } if ( r - l + 1 <= 64 ) no_of_substr += l + 1 ; else { no_of_substr += arr [ l + 1 ] + 1 ; } } return no_of_substr ; }
static int lehmann ( int n , int t ) { Random rand = new Random ( ) ; int a = rand . nextInt ( n - 3 ) + 2 ; float e = ( n - 1 ) / 2 ; while ( t > 0 ) { int result = ( ( int ) ( Math . pow ( a , e ) ) ) % n ; if ( ( result % n ) == 1 || ( result % n ) == ( n - 1 ) ) { a = rand . nextInt ( n - 3 ) + 2 ; t -= 1 ; } else return - 1 ; } return 1 ; }
static boolean isLucky ( int n ) { boolean arr [ ] = new boolean [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) arr [ i ] = false ; while ( n > 0 ) { int digit = n % 10 ; if ( arr [ digit ] ) return false ; arr [ digit ] = true ; n = n / 10 ; } return true ; }
static String check ( int k , int d0 , int d1 ) { int s = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 + ( 8 * ( d0 + d1 ) ) % 10 + ( 6 * ( d0 + d1 ) ) % 10 ; int a = ( k - 3 ) % 4 ; int x = 0 ; switch ( a ) { case 0 : x = 0 ; break ; case 1 : x = ( 2 * ( d0 + d1 ) ) % 10 ; break ; case 2 : x = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 ; break ; case 3 : x = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 + ( 8 * ( d0 + d1 ) ) % 10 ; break ; } int sum = d0 + d1 + ( ( ( k - 3 ) / 4 ) * s + x ) ; if ( sum % 3 == 0 ) return " YES " ; return " NO " ; }
static int eggDrop ( int n , int k ) { if ( k == 1 || k == 0 ) return k ; if ( n == 1 ) return k ; int min = Integer . MAX_VALUE ; int x , res ; for ( x = 1 ; x <= k ; x ++ ) { res = Math . max ( eggDrop ( n - 1 , x - 1 ) , eggDrop ( n , k - x ) ) ; if ( res < min ) min = res ; } return min + 1 ; }
static boolean allBitsSetInTheGivenRange ( int n , int l , int r ) { int num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; int new_num = n & num ; if ( new_num == 0 ) return true ; return false ; }
static int count ( int n ) { int table [ ] = new int [ n + 1 ] , i ; Arrays . fill ( table , 0 ) ; table [ 0 ] = 1 ; for ( i = 3 ; i <= n ; i ++ ) table [ i ] += table [ i - 3 ] ; for ( i = 5 ; i <= n ; i ++ ) table [ i ] += table [ i - 5 ] ; for ( i = 10 ; i <= n ; i ++ ) table [ i ] += table [ i - 10 ] ; return table [ n ] ; }
static int addOne ( int x ) { int m = 1 ; while ( ( int ) ( x & m ) >= 1 ) { x = x ^ m ; m <<= 1 ; } x = x ^ m ; return x ; }
static int countNumberOfTriangles ( int n ) { return n * ( n - 1 ) * ( n - 2 ) / 6 ; }
public static double polygonArea ( double X [ ] , double Y [ ] , int n ) { double area = 0.0 ; int j = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) ; j = i ; } return Math . abs ( area / 2.0 ) ; }
static int countMinimumMoves ( int arr [ ] , int n , int k ) { int i ; for ( i = k - 1 ; i < n ; i ++ ) if ( arr [ i ] != arr [ k - 1 ] ) return - 1 ; for ( i = k - 1 ; i >= 0 ; i -- ) if ( arr [ i ] != arr [ k - 1 ] ) return i + 1 ; return 0 ; }
static String findSubString ( String str , String pat ) { int len1 = str . length ( ) ; int len2 = pat . length ( ) ; if ( len1 < len2 ) { System . out . println ( " No ▁ such ▁ window ▁ exists " ) ; return " " ; } int hash_pat [ ] = new int [ no_of_chars ] ; int hash_str [ ] = new int [ no_of_chars ] ; for ( int i = 0 ; i < len2 ; i ++ ) hash_pat [ pat . charAt ( i ) ] ++ ; int start = 0 , start_index = - 1 , min_len = Integer . MAX_VALUE ; int count = 0 ; for ( int j = 0 ; j < len1 ; j ++ ) { hash_str [ str . charAt ( j ) ] ++ ; if ( hash_pat [ str . charAt ( j ) ] != 0 && hash_str [ str . charAt ( j ) ] <= hash_pat [ str . charAt ( j ) ] ) count ++ ; if ( count == len2 ) { while ( hash_str [ str . charAt ( start ) ] > hash_pat [ str . charAt ( start ) ] || hash_pat [ str . charAt ( start ) ] == 0 ) { if ( hash_str [ str . charAt ( start ) ] > hash_pat [ str . charAt ( start ) ] ) hash_str [ str . charAt ( start ) ] -- ; start ++ ; } int len_window = j - start + 1 ; if ( min_len > len_window ) { min_len = len_window ; start_index = start ; } } } if ( start_index == - 1 ) { System . out . println ( " No ▁ such ▁ window ▁ exists " ) ; return " " ; } return str . substring ( start_index , start_index + min_len ) ; }
static void countDigit ( int n ) { int temp = n , sum = 0 , product = 1 ; while ( temp != 0 ) { int d = temp % 10 ; temp /= 10 ; if ( d > 0 && n % d == 0 ) { sum += d ; product *= d ; } } System . out . print ( " Sum ▁ = ▁ " + sum ) ; System . out . print ( " \n Product ▁ = ▁ " + product ) ; }
static int countPairs ( String str ) { int result = 0 ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( Math . abs ( str . charAt ( i ) - str . charAt ( j ) ) == Math . abs ( i - j ) ) result ++ ; return result ; }
static boolean checkplusperfect ( int x ) { int temp = x ; int n = 0 ; while ( x != 0 ) { x /= 10 ; n ++ ; } x = temp ; int sum = 0 ; while ( x != 0 ) { sum += Math . pow ( x % 10 , n ) ; x /= 10 ; } return ( sum == temp ) ; }
static int countIntersections ( int n ) { return n * ( n - 1 ) / 2 ; }
static int maxSortedAdjacentDiff ( int [ ] arr , int n ) { int maxVal = arr [ 0 ] ; int minVal = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { maxVal = Math . max ( maxVal , arr [ i ] ) ; minVal = Math . min ( minVal , arr [ i ] ) ; } int maxBucket [ ] = new int [ n - 1 ] ; int minBucket [ ] = new int [ n - 1 ] ; Arrays . fill ( maxBucket , 0 , n - 1 , Integer . MIN_VALUE ) ; Arrays . fill ( minBucket , 0 , n - 1 , Integer . MAX_VALUE ) ; float delta = ( float ) ( maxVal - minVal ) / ( float ) ( n - 1 ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == maxVal || arr [ i ] == minVal ) { continue ; } int index = ( int ) ( Math . round ( ( arr [ i ] - minVal ) / delta ) ) ; if ( maxBucket [ index ] == Integer . MIN_VALUE ) { maxBucket [ index ] = arr [ i ] ; } else { maxBucket [ index ] = Math . max ( maxBucket [ index ] , arr [ i ] ) ; } if ( minBucket [ index ] == Integer . MAX_VALUE ) { minBucket [ index ] = arr [ i ] ; } else { minBucket [ index ] = Math . min ( minBucket [ index ] , arr [ i ] ) ; } } int prev_val = minVal ; int max_gap = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( minBucket [ i ] == Integer . MAX_VALUE ) { continue ; } max_gap = Math . max ( max_gap , minBucket [ i ] - prev_val ) ; prev_val = maxBucket [ i ] ; } max_gap = Math . max ( max_gap , maxVal - prev_val ) ; return max_gap ; }
public static void solve ( int n ) { double a = n / 2 ; if ( n % 2 != 0 ) { System . out . println ( ( Math . ceil ( a ) - 1 ) + " ▁ " + ( Math . floor ( a ) + 1 ) ) ; } else { if ( ( int ) ( a ) % 2 == 0 ) { System . out . println ( ( Math . ceil ( a ) - 1 ) + " ▁ " + ( Math . floor ( a ) + 1 ) ) ; } else { System . out . println ( ( Math . ceil ( a ) - 2 ) + " ▁ " + ( Math . floor ( a ) + 2 ) ) ; } } }
static int getMissingNo ( int a [ ] , int n ) { int x1 = a [ 0 ] ; int x2 = 1 ; for ( int i = 1 ; i < n ; i ++ ) x1 = x1 ^ a [ i ] ; for ( int i = 2 ; i <= n + 1 ; i ++ ) x2 = x2 ^ i ; return ( x1 ^ x2 ) ; }
static boolean isCyclic ( long N ) { long num = N ; int count = 0 ; int digit = ( int ) ( num % 10 ) ; boolean allSame = true ; while ( num > 0 ) { count ++ ; if ( num % 10 != digit ) allSame = false ; num = num / 10 ; } if ( allSame == true ) return false ; if ( count % 2 == 0 ) { long halfPower = ( long ) Math . pow ( 10 , count / 2 ) ; long firstHalf = N % halfPower ; long secondHalf = N / halfPower ; if ( firstHalf == firstHalf && isCyclic ( firstHalf ) ) return false ; } num = N ; while ( true ) { long rem = num % 10 ; long div = num / 10 ; num = ( long ) ( Math . pow ( 10 , count - 1 ) ) * rem + div ; if ( num == N ) break ; if ( num % N != 0 ) return false ; } return true ; }
static int nthTerm ( int n ) { return 2 * ( int ) Math . pow ( n , 3 ) + ( int ) Math . pow ( n , 2 ) ; }
static int Nth_Term ( int n ) { return ( int ) ( 3 * Math . pow ( n , 2 ) - n + 2 ) / ( 2 ) ; }
static int Max_Sum ( int a [ ] , int n ) { int [ ] b = new int [ n ] ; int S = 0 ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { b [ i ] = res ; res += a [ i ] ; S += a [ i ] ; res = Math . max ( res , - S ) ; } int ans = S ; ans = Math . max ( ans , res ) ; int g = 0 ; for ( int i = n - 1 ; i >= 0 ; -- i ) { g -= a [ i ] ; ans = Math . max ( ans , g + b [ i ] ) ; } return ans ; }
static int lcs ( String X , String Y , int m , int n ) { if ( m == 0 || n == 0 ) { return 0 ; } if ( X . charAt ( m - 1 ) == Y . charAt ( n - 1 ) ) { return 1 + lcs ( X , Y , m - 1 , n - 1 ) ; } else { return Math . max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) ) ; } }
static int countSticks ( String str ) { int cnt = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char ch = str . charAt ( i ) ; if ( ch >= ' A ' && ch <= ' Z ' ) { cnt += sticks [ ch - ' A ' ] ; } else { cnt += number [ ch - '0' ] ; } } return cnt ; }
static int countSubarrays ( int [ ] arr , int n ) { int difference = 0 ; int ans = 0 ; int [ ] hash_positive = new int [ n + 1 ] ; int [ ] hash_negative = new int [ n + 1 ] ; hash_positive [ 0 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] & 1 ) == 1 ) { difference ++ ; } else { difference -- ; } if ( difference < 0 ) { ans += hash_negative [ - difference ] ; hash_negative [ - difference ] ++ ; } else { ans += hash_positive [ difference ] ; hash_positive [ difference ] ++ ; } } return ans ; }
static int Count ( String s , int pos ) { int c = s . charAt ( pos - 1 ) ; int counter = 0 ; for ( int i = 0 ; i < pos - 1 ; i ++ ) { if ( s . charAt ( i ) == c ) counter = counter + 1 ; } return counter ; }
static int seriesSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += i * ( i + 1 ) / 2 ; return sum ; }
static int countSubStr ( String str , int len ) { int ans = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( str . charAt ( i ) == '0' ) ans += ( i + 1 ) ; } return ans ; }
static int findTransitionPoint ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == 1 ) return i ; return - 1 ; }
static boolean check ( int a [ ] [ ] , int b [ ] [ ] ) { for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 1 ; j < M ; j ++ ) { if ( a [ i ] [ j ] != b [ i ] [ j ] ) { a [ i ] [ j ] ^= 1 ; a [ 0 ] [ 0 ] ^= 1 ; a [ 0 ] [ j ] ^= 1 ; a [ i ] [ 0 ] ^= 1 ; } } } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( a [ i ] [ j ] != b [ i ] [ j ] ) return false ; } } return true ; }
static int findevenPair ( int [ ] A , int N ) { int i , j ; int evenPair = 0 ; for ( i = 0 ; i < N ; i ++ ) { for ( j = i + 1 ; j < N ; j ++ ) { if ( ( A [ i ] & A [ j ] ) % 2 == 0 ) evenPair ++ ; } } return evenPair ; }
static int minCost ( int N , int P , int Q ) { int cost = 0 ; while ( N > 0 ) { if ( ( N & 1 ) > 0 ) { cost += P ; N -- ; } else { int temp = N / 2 ; if ( temp * P > Q ) cost += Q ; else cost += P * temp ; N /= 2 ; } } return cost ; }
static int countPalindromes ( int n , int m , int matrix [ ] [ ] ) { int count = n * m ; int length_of_sequence_row ; int length_of_sequence_column ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { length_of_sequence_row = Math . min ( j , m - 1 - j ) ; length_of_sequence_column = Math . min ( i , n - i - 1 ) ; for ( int k = 1 ; k <= length_of_sequence_row ; k ++ ) { if ( matrix [ i ] [ j - k ] == matrix [ i ] [ j + k ] ) { count ++ ; } else { break ; } } for ( int k = 1 ; k <= length_of_sequence_column ; k ++ ) { if ( matrix [ i - k ] [ j ] == matrix [ i + k ] [ j ] ) { count ++ ; } else { break ; } } } } return count ; }
static void reverseorder ( int n ) { boolean prime [ ] = new boolean [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } for ( int i = n ; i >= 2 ; i -- ) if ( prime [ i ] == true ) System . out . print ( i + " ▁ " ) ; }
static void shortestLength ( int n , int x [ ] , int y [ ] ) { int answer = 0 ; int i = 0 ; while ( n != 0 && i < x . length ) { if ( x [ i ] + y [ i ] > answer ) answer = x [ i ] + y [ i ] ; i ++ ; } System . out . println ( " Length ▁ - > ▁ " + answer ) ; System . out . println ( " Path ▁ - > ▁ " + " ( ▁ 1 , ▁ " + answer + " ▁ ) " + " and ▁ ( ▁ " + answer + " , ▁ 1 ▁ ) " ) ; }
static int power ( int x , int y ) { int res = 1 ; while ( y > 0 ) { if ( ( y & 1 ) == 1 ) res = res * x ; y = y >> 1 ; x = x * x ; } return res ; }
static int center_hexadecagonal_num ( int n ) { return 8 * n * n - 8 * n + 1 ; }
static int minCost ( int n , int arr [ ] , int cost ) { int sum = 0 , totalCost = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) sum += arr [ i ] ; totalCost += cost * sum ; arr [ n - 1 ] += sum ; totalCost += ( 2 * cost * arr [ n - 1 ] ) ; return totalCost ; }
static int countNumbers ( int n ) { if ( n % 2 == 1 ) return 0 ; return ( 9 * ( int ) Math . pow ( 10 , n / 2 - 1 ) ) ; }
static int sumOfSeries ( int n ) { return ( n * ( 2 * n - 1 ) * ( 2 * n + 1 ) ) / 3 ; }
static void solution ( int a , int b , int n ) { for ( int i = 0 ; i * a <= n ; i ++ ) { if ( ( n - ( i * a ) ) % b == 0 ) { System . out . println ( " x ▁ = ▁ " + i + " , ▁ y ▁ = ▁ " + ( n - ( i * a ) ) / b ) ; return ; } } System . out . println ( " No ▁ solution " ) ; }
static int countSetBitsRec ( int num ) { int nibble = 0 ; if ( 0 == num ) return num_to_bits [ 0 ] ; nibble = num & 0xf ; return num_to_bits [ nibble ] + countSetBitsRec ( num >> 4 ) ; }
static int findCullen ( int n ) { return ( 1 << n ) * n + 1 ; }
static int calculate ( int a [ ] , int n ) { Arrays . sort ( a ) ; int count = 1 ; int answer = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] == a [ i - 1 ] ) { count += 1 ; } else { answer = answer + ( count * ( count - 1 ) ) / 2 ; count = 1 ; } } answer = answer + ( count * ( count - 1 ) ) / 2 ; return answer ; }
static void recaman ( int n ) { int arr [ ] = new int [ n ] ; arr [ 0 ] = 0 ; System . out . print ( arr [ 0 ] + " ▁ , " ) ; for ( int i = 1 ; i < n ; i ++ ) { int curr = arr [ i - 1 ] - i ; int j ; for ( j = 0 ; j < i ; j ++ ) { if ( ( arr [ j ] == curr ) || curr < 0 ) { curr = arr [ i - 1 ] + i ; break ; } } arr [ i ] = curr ; System . out . print ( arr [ i ] + " , ▁ " ) ; } }
static void centeredHexagonalSeries ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) System . out . print ( 3 * i * ( i - 1 ) + 1 + " ▁ " ) ; }
static void reverse ( String str , int x ) { int n = ( str . length ( ) - x ) / 2 ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( str . charAt ( i ) ) ; for ( int i = n + x - 1 ; i >= n ; i -- ) System . out . print ( str . charAt ( i ) ) ; for ( int i = n + x ; i < str . length ( ) ; i ++ ) System . out . print ( str . charAt ( i ) ) ; }
static int pairsInSortedRotated ( int arr [ ] , int n , int x ) { int i ; for ( i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] > arr [ i + 1 ] ) break ; int l = ( i + 1 ) % n ; int r = i ; int cnt = 0 ; while ( l != r ) { if ( arr [ l ] + arr [ r ] == x ) { cnt ++ ; if ( l == ( r - 1 + n ) % n ) { return cnt ; } l = ( l + 1 ) % n ; r = ( r - 1 + n ) % n ; } else if ( arr [ l ] + arr [ r ] < x ) l = ( l + 1 ) % n ; else r = ( n + r - 1 ) % n ; } return cnt ; }
static String smallestFreq ( String S1 , String S2 ) { HashMap < String , Integer > banned = new HashMap < > ( ) ; for ( int i = 0 ; i < S2 . length ( ) ; i ++ ) { String s = " " ; while ( i < S2 . length ( ) && S2 . charAt ( i ) != ' ▁ ' ) s += S2 . charAt ( i ++ ) ; banned . put ( s , banned . get ( s ) == null ? 1 : banned . get ( s ) + 1 ) ; } HashMap < String , Integer > result = new HashMap < > ( ) ; String ans = " " ; int freq = 0 ; for ( int i = 0 ; i < S1 . length ( ) ; i ++ ) { String s = " " ; while ( i < S1 . length ( ) && S1 . charAt ( i ) != ' ▁ ' ) s += S1 . charAt ( i ++ ) ; if ( banned . get ( s ) == null ) { result . put ( s , result . get ( s ) == null ? 1 : result . get ( s ) + 1 ) ; if ( result . get ( s ) > freq || ( result . get ( s ) == freq && s . compareTo ( ans ) < 0 ) ) { ans = s ; freq = result . get ( s ) ; } } } return ans ; }
static int isPowerOf2 ( String s ) { char [ ] str = s . toCharArray ( ) ; int len_str = s . length ( ) ; int num = 0 ; if ( len_str == 1 && str [ len_str - 1 ] == '1' ) return 0 ; while ( len_str != 1 || str [ len_str - 1 ] != '1' ) { if ( ( str [ len_str - 1 ] - '0' ) % 2 == 1 ) return 0 ; int j = 0 ; for ( int i = 0 ; i < len_str ; i ++ ) { num = num * 10 + ( int ) str [ i ] - ( int ) '0' ; if ( num < 2 ) { if ( i != 0 ) str [ j ++ ] = '0' ; continue ; } str [ j ++ ] = ( char ) ( ( int ) ( num / 2 ) + ( int ) '0' ) ; num = ( num ) - ( num / 2 ) * 2 ; } str [ j ] = ' \0' ; len_str = j ; } return 1 ; }
public static int breakEvenPoint ( int exp1 , int S , int M ) { double earn = S - M ; double exp = exp1 ; double res = Math . ceil ( exp / earn ) ; int res1 = ( int ) res ; return res1 ; }
static int numberOfPaths ( int m , int n ) { int count [ ] [ ] = new int [ m ] [ n ] ; for ( int i = 0 ; i < m ; i ++ ) count [ i ] [ 0 ] = 1 ; for ( int j = 0 ; j < n ; j ++ ) count [ 0 ] [ j ] = 1 ; for ( int i = 1 ; i < m ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) count [ i ] [ j ] = count [ i - 1 ] [ j ] + count [ i ] [ j - 1 ] ; } return count [ m - 1 ] [ n - 1 ] ; }
static int search ( int arr [ ] , int n , int x ) { int i = 0 ; while ( i < n ) { if ( arr [ i ] == x ) return i ; i = i + Math . abs ( arr [ i ] - x ) ; } System . out . println ( " number ▁ is ▁ not " + " ▁ present ! " ) ; return - 1 ; }
static int findSum ( int N , int K ) { int ans = 0 ; int y = N / K ; int x = N % K ; ans = ( K * ( K - 1 ) / 2 ) * y + ( x * ( x + 1 ) ) / 2 ; return ans ; }
static void count_even_odd ( int min , int max , int steps [ ] [ ] ) { int a , b , even , odd ; boolean beven = true , aeven = false ; int n = 2 ; for ( int i = 0 ; i < n ; i ++ ) { a = steps [ i ] [ 0 ] ; b = steps [ i ] [ 1 ] ; if ( ! ( aeven || ( a & 1 ) > 0 ) ) aeven = true ; if ( beven ) { if ( ( b & 1 ) > 0 ) beven = false ; } else if ( ! ( ( a & 1 ) > 0 ) ) { if ( ! ( ( b & 1 ) > 0 ) ) beven = true ; } else { if ( ( b & 1 ) > 0 ) beven = true ; } } if ( beven ) { even = ( int ) max / 2 - ( int ) ( min - 1 ) / 2 ; odd = 0 ; } else { even = ( int ) max / 2 - ( int ) ( min - 1 ) / 2 ; odd = 0 ; } if ( ! ( beven ^ aeven ) ) even += max - min + 1 - ( int ) max / 2 + ( int ) ( min - 1 ) / 2 ; else odd += max - min + 1 - ( int ) max / 2 + ( int ) ( min - 1 ) / 2 ; System . out . print ( " even ▁ = ▁ " + even + " , ▁ odd ▁ = ▁ " + odd ) ; }
static void printBracketNumber ( String exp , int n ) { int left_bnum = 1 ; Stack < Integer > right_bnum = new Stack < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( exp . charAt ( i ) == ' ( ' ) { System . out . print ( left_bnum + " ▁ " ) ; right_bnum . push ( left_bnum ) ; left_bnum ++ ; } else if ( exp . charAt ( i ) == ' ) ' ) { System . out . print ( right_bnum . peek ( ) + " ▁ " ) ; right_bnum . pop ( ) ; } } }
static int findElement ( int arr [ ] , int size ) { int right_mul = 1 , left_mul = 1 ; for ( int i = 1 ; i < size ; i ++ ) right_mul *= arr [ i ] ; for ( int i = 0 , j = 1 ; j < size ; i ++ , j ++ ) { right_mul /= arr [ j ] ; left_mul *= arr [ i ] ; if ( left_mul == right_mul ) return arr [ i + 1 ] ; } return - 1 ; }
static boolean checkIsAP ( int arr [ ] , int n ) { if ( n == 1 ) return true ; Arrays . sort ( arr ) ; int d = arr [ 1 ] - arr [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) if ( arr [ i ] - arr [ i - 1 ] != d ) return false ; return true ; }
static int countOdd ( int L , int R ) { int N = ( R - L ) / 2 ; if ( R % 2 != 0 || L % 2 != 0 ) N ++ ; return N ; }
static String lucas_sequence ( String s , int n ) { HashMap < Character , Integer > m = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) m . put ( s . charAt ( i ) , m . get ( s . charAt ( i ) ) == null ? 1 : m . get ( s . charAt ( i ) ) + 1 ) ; Vector < Integer > v1 = new Vector < > ( ) ; Vector < Integer > v2 = new Vector < > ( ) ; for ( HashMap . Entry < Character , Integer > entry : m . entrySet ( ) ) v1 . add ( entry . getValue ( ) ) ; Collections . sort ( v1 ) ; if ( v1 . elementAt ( 0 ) == 1 && v1 . elementAt ( 1 ) == 2 ) { v1 . set ( 0 , 2 ) ; v1 . set ( 1 , 1 ) ; } else return " NO " ; int a = 2 , b = 1 ; int c ; v2 . add ( a ) ; v2 . add ( b ) ; for ( int i = 0 ; i < v1 . size ( ) - 2 ; i ++ ) { v2 . add ( a + b ) ; c = a + b ; a = b ; b = c ; } int flag = 1 ; for ( int i = 0 ; i < v1 . size ( ) ; i ++ ) { if ( v1 . elementAt ( i ) != v2 . elementAt ( i ) ) { flag = 0 ; break ; } } if ( flag == 1 ) return " YES " ; else return " NO " ; }
public static long firstkdigits ( int n , int k ) { double product = n * Math . log10 ( n ) ; double decimal_part = product - Math . floor ( product ) ; decimal_part = Math . pow ( 10 , decimal_part ) ; double digits = Math . pow ( 10 , k - 1 ) , i = 0 ; return ( ( long ) ( decimal_part * digits ) ) ; }
public static double answer ( double X , double K ) { double i = 10 ; double MIN = Math . pow ( i , K - 1 ) ; if ( MIN % X == 0 ) return ( MIN ) ; else return ( ( MIN + X ) - ( ( MIN + X ) % X ) ) ; }
static int MaximumHeight ( int [ ] a , int n ) { int result = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { int y = ( i * ( i + 1 ) ) / 2 ; if ( y < n ) result = i ; else break ; } return result ; }
static Character findKthChar ( String s , int k ) { int len = s . length ( ) ; int i = 0 ; int total_len = 0 ; while ( i < len ) { if ( Character . isLetter ( s . charAt ( i ) ) ) { total_len ++ ; if ( total_len == k ) return s . charAt ( i ) ; i ++ ; } else { int n = 0 ; while ( i < len && ! Character . isLetter ( s . charAt ( i ) ) ) { n = n * 10 + ( s . charAt ( i ) - '0' ) ; i ++ ; } int next_total_len = total_len * n ; if ( k <= next_total_len ) { int pos = k % total_len ; if ( pos == 0 ) { pos = total_len ; } return findKthChar ( s , pos ) ; } else { total_len = next_total_len ; } } } return ' ▁ ' ; }
static int countChanges ( int arr [ ] , int n ) { Set < Integer > s = new HashSet < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) s . add ( arr [ i ] ) ; int count = 0 ; for ( int i = 1 ; i <= n ; i ++ ) if ( ! s . contains ( i ) ) count ++ ; return count ; }
static StringBuilder findMaximumNum ( StringBuilder str , int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) { if ( k < 1 ) break ; if ( str . charAt ( i ) != '9' ) { str . setCharAt ( i , '9' ) ; k -- ; } } return str ; }
static int countTripletsLessThanL ( int n , int L , int [ ] arr ) { Arrays . sort ( arr ) ; int ways = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { int mostDistantDistance = arr [ k ] - arr [ i ] ; if ( mostDistantDistance <= L ) { ways ++ ; } } } } return ways ; }
static void checkEqualMatrix ( int arr [ ] [ ] , int n , int m , int k ) { int c = 0 , cnt1 = 0 , cnt2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( c % 2 == 0 ) { if ( arr [ i ] [ j ] == k ) { cnt1 ++ ; } } else { if ( arr [ i ] [ j ] == k ) { cnt2 ++ ; } } c = c + 1 ; } } if ( cnt1 >= 1 && cnt2 >= 1 ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } }
static boolean isMinHeap ( int [ ] level ) { int n = level . length - 1 ; for ( int i = ( n / 2 - 1 ) ; i >= 0 ; i -- ) { if ( level [ i ] > level [ 2 * i + 1 ] ) return false ; if ( 2 * i + 2 < n ) { if ( level [ i ] > level [ 2 * i + 2 ] ) return false ; } } return true ; }
static double haversine ( double lat1 , double lon1 , double lat2 , double lon2 ) { double dLat = Math . toRadians ( lat2 - lat1 ) ; double dLon = Math . toRadians ( lon2 - lon1 ) ; lat1 = Math . toRadians ( lat1 ) ; lat2 = Math . toRadians ( lat2 ) ; double a = Math . pow ( Math . sin ( dLat / 2 ) , 2 ) + Math . pow ( Math . sin ( dLon / 2 ) , 2 ) * Math . cos ( lat1 ) * Math . cos ( lat2 ) ; double rad = 6371 ; double c = 2 * Math . asin ( Math . sqrt ( a ) ) ; return rad * c ; }
static int count ( int n ) { return ( int ) Math . pow ( 2 , n - 1 ) ; }
static int numberofterm ( int digit , int number ) { int firstnum = ( int ) Math . pow ( 10 , digit - 1 ) ; int lastnum = ( int ) Math . pow ( 10 , digit ) ; firstnum = ( firstnum - firstnum % number ) + number ; lastnum = ( lastnum - lastnum % number ) ; return ( ( lastnum - firstnum ) / number + 1 ) ; }
static int findOddPair ( int A [ ] , int N ) { int i , j ; int oddPair = 0 ; for ( i = 0 ; i < N ; i ++ ) { for ( j = i + 1 ; j < N ; j ++ ) { if ( ( A [ i ] ^ A [ j ] ) % 2 != 0 ) oddPair ++ ; } } return oddPair ; }
public static int countOrderedPairs ( int [ ] A , int n ) { int orderedPairs = 0 ; HashMap < Integer , Integer > m = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( m . get ( A [ i ] ) == null ) m . put ( A [ i ] , 1 ) ; else { int a = m . get ( A [ i ] ) ; m . put ( A [ i ] , ++ a ) ; } } for ( int entry : m . keySet ( ) ) { int X = entry ; int Y = m . get ( entry ) ; for ( int j = 1 ; j <= Y ; j ++ ) { if ( m . get ( j ) >= X ) orderedPairs ++ ; } } return orderedPairs ; }
static long firstkdigits ( int n , int k ) { long product = 1 ; for ( int i = 0 ; i < n ; i ++ ) product *= n ; while ( ( int ) ( product / Math . pow ( 10 , k ) ) != 0 ) product = product / 10 ; return product ; }
static int largestCoprime ( int N ) { if ( N == 6 ) return 1 ; else if ( N % 4 == 0 ) return ( N / 2 ) - 1 ; else if ( N % 2 == 0 ) return ( N / 2 ) - 2 ; else return ( ( N - 1 ) / 2 ) ; }
static long getSum ( int n , int d ) { long sum = 0 ; while ( d <= n ) { sum += d ; d += 10 ; } return sum ; }
static void partSort ( int [ ] arr , int N , int a , int b ) { int l = Math . min ( a , b ) ; int r = Math . max ( a , b ) ; int [ ] temp = new int [ r - l + 1 ] ; int j = 0 ; for ( int i = l ; i <= r ; i ++ ) { temp [ j ] = arr [ i ] ; j ++ ; } Arrays . sort ( temp ) ; j = 0 ; for ( int i = l ; i <= r ; i ++ ) { arr [ i ] = temp [ j ] ; j ++ ; } for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } }
static int minOperations ( int arr [ ] , int n ) { HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . containsKey ( arr [ i ] ) ) { mp . put ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . put ( arr [ i ] , 1 ) ; } } int maxFreq = Integer . MIN_VALUE ; maxFreq = Collections . max ( mp . entrySet ( ) , Comparator . comparingInt ( Map . Entry :: getKey ) ) . getValue ( ) ; return ( n - maxFreq ) ; }
static void thirdLargest ( int arr [ ] , int arr_size ) { if ( arr_size < 3 ) { System . out . printf ( " ▁ Invalid ▁ Input ▁ " ) ; return ; } int first = arr [ 0 ] ; for ( int i = 1 ; i < arr_size ; i ++ ) if ( arr [ i ] > first ) first = arr [ i ] ; int second = Integer . MIN_VALUE ; for ( int i = 0 ; i < arr_size ; i ++ ) if ( arr [ i ] > second && arr [ i ] < first ) second = arr [ i ] ; int third = Integer . MIN_VALUE ; for ( int i = 0 ; i < arr_size ; i ++ ) if ( arr [ i ] > third && arr [ i ] < second ) third = arr [ i ] ; System . out . printf ( " The ▁ third ▁ Largest ▁ " + " element ▁ is ▁ % d \n " , third ) ; }
static void generateSequence ( int n , int g ) { for ( int i = 1 ; i <= n ; i ++ ) System . out . print ( i * g + " ▁ " ) ; ; }
static int findevenPair ( int A [ ] , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( A [ i ] % 2 != 0 ) count ++ ; int oddCount = count * ( count - 1 ) / 2 ; return ( N * ( N - 1 ) / 2 ) - oddCount ; }
static int findProduct ( int arr [ ] , int n , int k ) { int prod = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % k == 0 ) { prod *= arr [ i ] ; } } return prod ; }
static void findNthNum ( int N ) { int bit_L = 1 , last_num = 0 ; while ( bit_L * ( bit_L + 1 ) / 2 < N ) { last_num = last_num + bit_L ; bit_L ++ ; } int bit_R = N - last_num - 1 ; System . out . print ( ( 1 << bit_L ) + ( 1 << bit_R ) + " \n " ) ; }
static int multiplyWith4 ( int n ) { return ( n << 2 ) ; }
static int productDiagonals ( int arr [ ] [ ] , int n ) { int product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { product = product * arr [ i ] [ i ] ; product = product * arr [ i ] [ n - i - 1 ] ; } if ( n % 2 == 1 ) { product = product / arr [ n / 2 ] [ n / 2 ] ; } return product ; }
static void findTime ( String T , int K ) { int minutes = ( ( T . charAt ( 0 ) - '0' ) * 10 + T . charAt ( 1 ) - '0' ) * 60 + ( ( T . charAt ( 3 ) - '0' ) * 10 + T . charAt ( 4 ) - '0' ) ; minutes += K ; int hour = ( minutes / 60 ) % 24 ; int min = minutes % 60 ; if ( hour < 10 ) { System . out . print ( "0" + hour + " : " ) ; } else { System . out . print ( hour + " : " ) ; } if ( min < 10 ) { System . out . println ( "0" + min ) ; } else { System . out . println ( min ) ; } }
static int count ( int n ) { int x = ( n / 3 ) - 1 ; if ( n % 3 > 0 ) { x ++ ; } return ( 4 * x + 4 * n ) ; }
static long solve ( int i , boolean tight , int sum_so_far , int Sum , String number , int len ) { if ( i == len ) { if ( sum_so_far == Sum ) return 1 ; else return 0 ; } long ans = dp [ i ] [ 1 ] [ sum_so_far ] ; if ( ans != - 1 ) { return ans ; } ans = 0 ; boolean ntight ; int nsum_so_far ; for ( char currdigit = '0' ; currdigit <= '9' ; currdigit ++ ) { if ( ! tight && currdigit > number . charAt ( i ) ) { break ; } ntight = tight || currdigit < number . charAt ( i ) ; nsum_so_far = sum_so_far + ( currdigit - '0' ) ; ans += solve ( i + 1 , ntight , nsum_so_far , Sum , number , len ) ; } return ans ; }
static void replace_elements ( int arr [ ] , int n ) { int pos = 0 ; for ( int i = 0 ; i < n ; i ++ ) { arr [ pos ++ ] = arr [ i ] ; while ( pos > 1 && arr [ pos - 2 ] == arr [ pos - 1 ] ) { pos -- ; arr [ pos - 1 ] ++ ; } } for ( int i = 0 ; i < pos ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; }
static boolean isPrime ( int a [ ] , int lower , int upper ) { int n = 0 ; for ( int i = lower - 1 ; i <= upper - 1 ; i ++ ) n += a [ i ] ; if ( n <= 1 ) return false ; for ( int i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; }
static int disc ( int a , int b , int c ) { int dis = ( int ) Math . pow ( b , 2 ) - ( 4 * a * c ) ; return dis ; }
public static void getSum ( int [ ] a , int n ) { int [ ] P = new int [ n ] ; P [ 0 ] = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) P [ i ] = a [ i ] + P [ i - 1 ] ; int S = P [ n - 1 ] ; HashMap < Integer , Integer > hash = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) hash . put ( P [ i ] , 1 ) ; HashSet < Integer > res = new HashSet < > ( ) ; for ( int i = 1 ; i * i <= S ; i ++ ) { if ( S % i == 0 ) { boolean pres = true ; int div1 = i , div2 = S / i ; for ( int j = div1 ; j <= S ; j += div1 ) { if ( hash . get ( j ) == null || hash . get ( j ) != 1 ) { pres = false ; break ; } } if ( pres && div1 != S ) res . add ( div1 ) ; pres = true ; for ( int j = S / i ; j <= S ; j += S / i ) { if ( hash . get ( j ) == null || hash . get ( j ) != 1 ) { pres = false ; break ; } } if ( pres && div2 != S ) res . add ( div2 ) ; } } if ( res . size ( ) == 0 ) { System . out . println ( " - 1" ) ; return ; } for ( int i : res ) System . out . print ( i + " ▁ " ) ; }
static int count_pairs ( int a [ ] , int b [ ] , int n , int m ) { int odd1 = 0 , even1 = 0 ; int odd2 = 0 , even2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 1 ) { odd1 ++ ; } else { even1 ++ ; } } for ( int i = 0 ; i < m ; i ++ ) { if ( b [ i ] % 2 == 1 ) { odd2 ++ ; } else { even2 ++ ; } } int pairs = Math . min ( odd1 , even2 ) + Math . min ( odd2 , even1 ) ; return pairs ; }
static void printUnique ( int l , int r ) { for ( int i = l ; i <= r ; i ++ ) { int num = i ; boolean visited [ ] = new boolean [ 10 ] ; while ( num != 0 ) { if ( visited [ num % 10 ] ) break ; visited [ num % 10 ] = true ; num = num / 10 ; } if ( num == 0 ) System . out . print ( i + " ▁ " ) ; } }
static void countPairs ( int arr [ ] , int n , int k ) { int i , j , cnt = 0 ; for ( i = 0 ; i < n - 1 ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { if ( ( arr [ i ] - arr [ j ] + k ) % k == 0 ) cnt += 1 ; } } System . out . print ( cnt + " \n " ) ; }
static boolean check ( String s , int m ) { int l = s . length ( ) ; int c1 = 0 ; int c2 = 0 ; for ( int i = 0 ; i < l ; i ++ ) { if ( s . charAt ( i ) == '0' ) { c2 = 0 ; c1 ++ ; } else { c1 = 0 ; c2 ++ ; } if ( c1 == m || c2 == m ) return true ; } return false ; }
static long exponentiation ( long base , long exp ) { long t = 1L ; while ( exp > 0 ) { if ( exp % 2 != 0 ) t = ( t * base ) % N ; base = ( base * base ) % N ; exp /= 2 ; } return t % N ; }
static int findSumofEle ( int [ ] arr1 , int m , int [ ] arr2 , int n , int k ) { float arraySum = 0 ; for ( int i = 0 ; i < n ; i ++ ) arraySum += arr2 [ i ] ; float mean = arraySum / n ; int sumOfElements = 0 ; float difference = 0 ; for ( int i = 0 ; i < m ; i ++ ) { difference = arr1 [ i ] - mean ; if ( ( difference < 0 ) && ( k > ( - 1 ) * difference ) ) { sumOfElements += arr1 [ i ] ; } if ( ( difference >= 0 ) && ( k > difference ) ) { sumOfElements += arr1 [ i ] ; } } return sumOfElements ; }
static void count ( String str1 , String str2 ) { int c = 0 , j = 0 ; for ( int i = 0 ; i < str1 . length ( ) ; i ++ ) { if ( str2 . indexOf ( str1 . charAt ( i ) ) >= 0 ) { c += 1 ; } } System . out . println ( " No . ▁ of ▁ matching ▁ characters ▁ are : ▁ " + c ) ; }
static void findDivisors ( int n ) { int [ ] div = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j * i <= n ; j ++ ) div [ i * j ] ++ ; } for ( int i = 1 ; i <= n ; i ++ ) System . out . print ( div [ i ] + " ▁ " ) ; }
public static void getSmallestAndLargest ( String s , int k ) { String currStr = s . substring ( 0 , k ) ; String lexMin = currStr ; String lexMax = currStr ; for ( int i = k ; i < s . length ( ) ; i ++ ) { currStr = currStr . substring ( 1 , k ) + s . charAt ( i ) ; if ( lexMax . compareTo ( currStr ) < 0 ) lexMax = currStr ; if ( lexMin . compareTo ( currStr ) > 0 ) lexMin = currStr ; } System . out . println ( lexMin ) ; System . out . println ( lexMax ) ; }
static int maxSum ( int arr [ ] , int n , int k ) { int max_sum = Integer . MIN_VALUE ; for ( int i = 0 ; i < n - k + 1 ; i ++ ) { int current_sum = 0 ; for ( int j = 0 ; j < k ; j ++ ) current_sum = current_sum + arr [ i + j ] ; max_sum = Math . max ( current_sum , max_sum ) ; } return max_sum ; }
static void decToHexa ( int n ) { char [ ] hexaDeciNum = new char [ 100 ] ; int i = 0 ; while ( n != 0 ) { int temp = 0 ; temp = n % 16 ; if ( temp < 10 ) { hexaDeciNum [ i ] = ( char ) ( temp + 48 ) ; i ++ ; } else { hexaDeciNum [ i ] = ( char ) ( temp + 55 ) ; i ++ ; } n = n / 16 ; } for ( int j = i - 1 ; j >= 0 ; j -- ) System . out . print ( hexaDeciNum [ j ] ) ; }
static int ways ( String s , int n ) { int dp [ ] [ ] = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) { dp [ i ] [ j ] = 0 ; } for ( int i = 0 ; i < n ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { String temp = " " ; for ( int j = i ; j < n ; j ++ ) { temp += s . charAt ( j ) ; String test = " " ; for ( int k = i - 1 ; k >= 0 ; k -- ) { test += s . charAt ( k ) ; if ( test . compareTo ( temp ) < 0 ) { dp [ i ] [ j ] += dp [ k ] [ i - 1 ] ; } } } } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans += dp [ i ] [ n - 1 ] ; } return ans ; }
static int noOfBinaryStrings ( int N , int k ) { int dp [ ] = new int [ 100002 ] ; for ( int i = 1 ; i <= k - 1 ; i ++ ) { dp [ i ] = 1 ; } dp [ k ] = 2 ; for ( int i = k + 1 ; i <= N ; i ++ ) { dp [ i ] = ( dp [ i - 1 ] + dp [ i - k ] ) % mod ; } return dp [ N ] ; }
static int countSubSeq ( int a [ ] , int n , int k ) { Arrays . sort ( a ) ; List < Integer > arr = new LinkedList < > ( ) ; for ( int i = 0 ; i < n ; ) { int count = 1 , x = a [ i ] ; i ++ ; while ( i < n && a [ i ] == x ) { count ++ ; i ++ ; } arr . add ( count ) ; } int m = arr . size ( ) ; n = Math . min ( m , k ) ; int count = 1 ; int [ ] [ ] dp = new int [ n + 1 ] [ m + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = m ; j >= 0 ; j -- ) { if ( j > m - i ) dp [ i ] [ j ] = 0 ; else { dp [ i ] [ j ] = dp [ i ] [ j + 1 ] + arr . get ( j ) * dp [ i - 1 ] [ j + 1 ] ; } } count = count + dp [ i ] [ 0 ] ; } return count ; }
public static int squareFree ( int n ) { int cnt = 0 ; for ( int i = 1 ; ; i ++ ) { boolean isSqFree = true ; for ( int j = 2 ; j * j <= i ; j ++ ) { if ( i % ( j * j ) == 0 ) { isSqFree = false ; break ; } } if ( isSqFree == true ) { cnt ++ ; if ( cnt == n ) return i ; } } }
static int getMaximumSumWithLCMN ( int N ) { int sum = 0 ; int LIM = ( int ) Math . sqrt ( N ) ; for ( int i = 1 ; i <= LIM ; i ++ ) { if ( N % i == 0 ) { if ( i == ( N / i ) ) sum += i ; else sum += ( i + N / i ) ; } } return sum ; }
static int smallestSubWithSum ( int arr [ ] , int n , int x ) { int min_len = n + 1 ; for ( int start = 0 ; start < n ; start ++ ) { int curr_sum = arr [ start ] ; if ( curr_sum > x ) return 1 ; for ( int end = start + 1 ; end < n ; end ++ ) { curr_sum += arr [ end ] ; if ( curr_sum > x && ( end - start + 1 ) < min_len ) min_len = ( end - start + 1 ) ; } } return min_len ; }
static void converthenumber ( int n ) { String s = Integer . toString ( n ) ; String res = " " ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == '1' || s . charAt ( i ) == '3' || s . charAt ( i ) == '5' || s . charAt ( i ) == '7' || s . charAt ( i ) == '9' ) res += s . charAt ( i ) ; if ( res . length ( ) == 2 ) break ; } if ( res . length ( ) == 2 ) System . out . println ( res ) ; else System . out . println ( - 1 ) ; }
static String find_Square_369 ( String num ) { char a , b , c , d ; if ( num . charAt ( 0 ) == '3' ) { a = '1' ; b = '0' ; c = '8' ; d = '9' ; } else if ( num . charAt ( 0 ) == '6' ) { a = '4' ; b = '3' ; c = '5' ; d = '6' ; } else { a = '9' ; b = '8' ; c = '0' ; d = '1' ; } String result = " " ; int size = num . length ( ) ; for ( int i = 1 ; i < size ; i ++ ) result += a ; result += b ; for ( int i = 1 ; i < size ; i ++ ) result += c ; result += d ; return result ; }
static void product_subarrays ( int arr [ ] , int n ) { int product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { product *= arr [ j ] ; } } System . out . println ( product + " \n " ) ; }
public static int smallestKFreq ( int a [ ] , int n , int k ) { HashMap < Integer , Integer > m = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) if ( m . containsKey ( a [ i ] ) ) m . put ( a [ i ] , m . get ( a [ i ] ) + 1 ) ; else m . put ( a [ i ] , 1 ) ; int res = Integer . MAX_VALUE ; Set < Integer > s = m . keySet ( ) ; for ( int temp : s ) if ( m . get ( temp ) == k ) res = Math . min ( res , temp ) ; return ( res != Integer . MAX_VALUE ) ? res : - 1 ; }
static void rotate ( ) { int x = arr [ arr . length - 1 ] , i ; for ( i = arr . length - 1 ; i > 0 ; i -- ) arr [ i ] = arr [ i - 1 ] ; arr [ 0 ] = x ; }
static int findMin ( int arr [ ] , int n ) { int m = 0 ; for ( int i = 0 ; i < n ; i ++ ) m = Math . max ( m , arr [ i ] ) ; int freq [ ] = new int [ m + 2 ] ; for ( int i = 0 ; i < n ; i ++ ) freq [ arr [ i ] ] ++ ; for ( int i = 1 ; i <= m + 1 ; i ++ ) { int j = i ; int cnt = 0 ; while ( j <= m ) { cnt += freq [ j ] ; j += i ; } if ( cnt == 0 ) return i ; } return m + 1 ; }
static float CalculateRatio ( float m , float n ) { return ( 2 * m - 1 ) / ( 2 * n - 1 ) ; }
static long kBitDifferencePairs ( int arr [ ] , int n , int k ) { int MAX = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; long [ ] count = new long [ MAX + 1 ] ; Arrays . fill ( count , 0 ) ; for ( int i = 0 ; i < n ; ++ i ) ++ count [ arr [ i ] ] ; long ans = 0 ; if ( k == 0 ) { for ( int i = 0 ; i <= MAX ; ++ i ) ans += ( count [ i ] * ( count [ i ] - 1 ) ) / 2 ; return ans ; } for ( int i = 0 ; i <= MAX ; ++ i ) { if ( count [ i ] == 0 ) continue ; for ( int j = i + 1 ; j <= MAX ; ++ j ) { if ( Integer . bitCount ( i ^ j ) == k ) ans += count [ i ] * count [ j ] ; } } return ans ; }
static boolean isDivisible ( int n ) { int d ; while ( ( n / 100 ) > 0 ) { d = n % 10 ; n /= 10 ; n = Math . abs ( n - ( d * 3 ) ) ; } return ( n % 31 == 0 ) ; }
static int findMinCost ( int arr [ ] , int n , int choc_cost ) { int choc_buy = arr [ 0 ] ; int curr_choc = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int choc = arr [ i ] - arr [ i + 1 ] ; curr_choc += choc ; if ( curr_choc < 0 ) { choc_buy += Math . abs ( curr_choc ) ; curr_choc = 0 ; } } return choc_buy * choc_cost ; }
static int binaryToDecimal ( int n ) { int num = n ; int dec_value = 0 ; int base = 1 ; int temp = num ; while ( temp > 0 ) { int last_digit = temp % 10 ; temp = temp / 10 ; dec_value += last_digit * base ; base = base * 2 ; } return dec_value ; }
static void profitLoss ( int N , int M ) { if ( N == M ) System . out . print ( " No ▁ Profit ▁ nor ▁ Loss " ) ; else { float result = 0 ; result = ( float ) ( Math . abs ( N - M ) ) / M ; if ( N - M < 0 ) System . out . print ( " Loss ▁ = ▁ - " + result * 100 + " % " ) ; else System . out . print ( " Profit ▁ = ▁ " + result * 100 + " % " ) ; } }
static void swapDiagonal ( int matrix [ ] [ ] ) { for ( int i = 0 ; i < N ; i ++ ) { int temp = matrix [ i ] [ i ] ; matrix [ i ] [ i ] = matrix [ i ] [ N - i - 1 ] ; matrix [ i ] [ N - i - 1 ] = temp ; } }
static int count ( int S [ ] , int m , int n ) { if ( n == 0 ) return 1 ; if ( n < 0 ) return 0 ; if ( m <= 0 && n >= 1 ) return 0 ; return count ( S , m - 1 , n ) + count ( S , m , n - S [ m - 1 ] ) ; }
static int nthTerm ( int n ) { return 7 * ( int ) Math . pow ( n , 2 ) - 7 * n + 7 ; }
static int longestFibonacciSubarray ( int n , int a [ ] ) { if ( n <= 2 ) return n ; int len = 2 ; int mx = Integer . MIN_VALUE ; for ( int i = 2 ; i < n ; i ++ ) { if ( a [ i ] == a [ i - 1 ] + a [ i - 2 ] ) len ++ ; else len = 2 ; mx = Math . max ( mx , len ) ; } return mx ; }
static int term ( int n ) { int x = ( ( ( 1 ) + ( int ) Math . sqrt ( 1 + ( 8 * n ) ) ) / 2 ) ; return x ; }
static float polydiagonal ( float n , float a ) { if ( a < 0 && n < 0 ) { return - 1 ; } return ( float ) ( 2 * a * Math . sin ( ( ( ( n - 2 ) * 180 ) / ( 2 * n ) ) * 3.14159 / 180 ) ) ; }
static int angle ( int n ) { return 2 * n ; }
static void substringConversions ( String str , int k , int b ) { for ( int i = 0 ; i + k <= str . length ( ) ; i ++ ) { String sub = str . substring ( i , i + k ) ; int sum = 0 , counter = 0 ; for ( int j = sub . length ( ) - 1 ; j >= 0 ; j -- ) { sum = ( int ) ( sum + ( ( sub . charAt ( j ) - '0' ) * Math . pow ( b , counter ) ) ) ; counter ++ ; } System . out . print ( sum + " ▁ " ) ; } }
static int maxSum ( int [ ] a , int n ) { int ans = 0 ; int [ ] arr = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) arr [ i ] = a [ i - 1 ] ; int [ ] [ ] dp = new int [ n + 1 ] [ 3 ] ; for ( int i = 1 ; i <= n ; ++ i ) { dp [ i ] [ 0 ] = Math . max ( arr [ i ] , dp [ i - 1 ] [ 0 ] + arr [ i ] ) ; dp [ i ] [ 1 ] = Math . max ( 0 , dp [ i - 1 ] [ 0 ] ) - arr [ i ] ; if ( i >= 2 ) dp [ i ] [ 1 ] = Math . max ( dp [ i ] [ 1 ] , dp [ i - 1 ] [ 1 ] + arr [ i ] ) ; if ( i >= 2 ) dp [ i ] [ 2 ] = dp [ i - 1 ] [ 1 ] - arr [ i ] ; if ( i >= 3 ) dp [ i ] [ 2 ] = Math . max ( dp [ i ] [ 2 ] , dp [ i - 1 ] [ 2 ] + arr [ i ] ) ; ans = Math . max ( ans , dp [ i ] [ 0 ] ) ; ans = Math . max ( ans , dp [ i ] [ 1 ] ) ; ans = Math . max ( ans , dp [ i ] [ 2 ] ) ; } return ans ; }
static int findLen ( int [ ] arr , int n , int m ) { Vector < Integer > filter = new Vector < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) if ( ( arr [ i ] & m ) == m ) filter . add ( arr [ i ] ) ; if ( filter . size ( ) == 0 ) return 0 ; int c_and = filter . get ( 0 ) ; for ( int i = 1 ; i < filter . size ( ) ; i ++ ) c_and &= filter . get ( i ) ; if ( c_and == m ) return filter . size ( ) ; return 0 ; }
public static int minNumber ( int a [ ] , int n , int x ) { int l = 0 , h = 0 , e = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == x ) e ++ ; else if ( a [ i ] > x ) h ++ ; else if ( a [ i ] < x ) l ++ ; } int ans = 0 ; if ( l > h ) ans = l - h ; else if ( l < h ) ans = h - l - 1 ; return ans + 1 - e ; }
public static void printTaxicab2 ( int N ) { int i = 1 , count = 0 ; while ( count < N ) { int int_count = 0 ; for ( int j = 1 ; j <= Math . pow ( i , 1.0 / 3 ) ; j ++ ) for ( int k = j + 1 ; k <= Math . pow ( i , 1.0 / 3 ) ; k ++ ) if ( j * j * j + k * k * k == i ) int_count ++ ; if ( int_count == 2 ) { count ++ ; System . out . println ( count + " ▁ " + i ) ; } i ++ ; } }
static void printPattern ( int n ) { if ( n == 0 || n < 0 ) { System . out . print ( n + " ▁ " ) ; return ; } System . out . print ( n + " ▁ " ) ; printPattern ( n - 5 ) ; System . out . print ( n + " ▁ " ) ; }
static int findStarNum ( int n ) { return ( 6 * n * ( n - 1 ) + 1 ) ; }
static void getLongestSeq ( int a [ ] , int n ) { int maxIdx = 0 , maxLen = 0 , currLen = 0 , currIdx = 0 ; for ( int k = 0 ; k < n ; k ++ ) { if ( a [ k ] > 0 ) { currLen ++ ; if ( currLen == 1 ) currIdx = k ; } else { if ( currLen > maxLen ) { maxLen = currLen ; maxIdx = currIdx ; } currLen = 0 ; } } if ( maxLen > 0 ) { System . out . print ( " Length ▁ " + maxLen ) ; System . out . print ( " , starting ▁ index ▁ " + maxIdx ) ; } else System . out . println ( " No ▁ positive ▁ sequence ▁ detected . " ) ; return ; }
static int countBits ( int n ) { int count = 0 ; while ( n != 0 ) { count ++ ; n >>= 1 ; } return count ; }
static void findfactors ( int n ) { Vector < Integer > vec = new Vector < Integer > ( ) ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { vec . add ( i ) ; vec . add ( n / i ) ; } } Collections . sort ( vec ) ; System . out . println ( " All ▁ the ▁ factors ▁ are ▁ - > ▁ " ) ; for ( int i = 0 ; i < vec . size ( ) ; i ++ ) { System . out . print ( vec . get ( i ) + " ▁ " ) ; } System . out . println ( ) ; int maxProduct = 1 ; boolean flag = true ; for ( int i = 0 ; i < vec . size ( ) ; i ++ ) { for ( int j = i ; j < vec . size ( ) ; j ++ ) { for ( int k = j ; k < vec . size ( ) ; k ++ ) { int y = n - vec . get ( i ) - vec . get ( j ) - vec . get ( k ) ; if ( y <= 0 ) { break ; } if ( n % y == 0 ) { flag = false ; maxProduct = Math . max ( vec . get ( i ) * vec . get ( j ) * vec . get ( k ) * y , maxProduct ) ; } } } } if ( flag == false ) { System . out . println ( " Product ▁ is ▁ - > ▁ " + maxProduct ) ; } else { System . out . println ( " Not ▁ possible " ) ; } }
static int Segment ( int x [ ] , int l [ ] , int n ) { if ( n == 1 ) return 1 ; int ans = 2 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( x [ i ] - l [ i ] > x [ i - 1 ] ) ans ++ ; else if ( x [ i ] + l [ i ] < x [ i + 1 ] ) { x [ i ] = x [ i ] + l [ i ] ; ans ++ ; } } return ans ; }
static boolean isEqualBlock ( int n ) { int first_bit = n % 2 ; int first_count = 1 ; n = n / 2 ; while ( n % 2 == first_bit && n > 0 ) { n = n / 2 ; first_count ++ ; } if ( n == 0 ) return false ; while ( n > 0 ) { first_bit = n % 2 ; int curr_count = 1 ; n = n / 2 ; while ( n % 2 == first_bit ) { n = n / 2 ; curr_count ++ ; } if ( curr_count != first_count ) return false ; } return true ; }
static int findLastIndex ( String str , Character x ) { int index = - 1 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( str . charAt ( i ) == x ) index = i ; return index ; }
static int findTerm ( int n ) { if ( n == 1 ) return n ; else { int term = 7 ; for ( int i = 2 ; i <= n ; i ++ ) term = term * 2 + ( i - 1 ) ; return term ; } }
static int findSumofEle ( int arr1 [ ] , int m , int arr2 [ ] , int n ) { int hash [ ] = new int [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) { hash [ arr2 [ i ] ] ++ ; } for ( int i = 1 ; i < MAX ; i ++ ) { hash [ i ] = hash [ i ] + hash [ i - 1 ] ; } int maximumFreq = 0 ; for ( int i = 0 ; i < m ; i ++ ) { maximumFreq = Math . max ( maximumFreq , hash [ arr1 [ i ] ] ) ; } int sumOfElements = 0 ; for ( int i = 0 ; i < m ; i ++ ) { sumOfElements += ( maximumFreq == hash [ arr1 [ i ] ] ) ? arr1 [ i ] : 0 ; } return sumOfElements ; }
static int printKDistinct ( int arr [ ] , int n , int k ) { int dist_count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < n ; j ++ ) if ( i != j && arr [ j ] == arr [ i ] ) break ; if ( j == n ) dist_count ++ ; if ( dist_count == k ) return arr [ i ] ; } return - 1 ; }
static double MinimumMail ( int n , int k , int x ) { double m = ( n - 1 ) + Math . ceil ( ( n - 1 ) * 1.0 / x ) * ( n - 1 ) + Math . ceil ( n * 1.0 / x ) * ( k - n ) ; return m ; }
static int decimalToBinary ( int N ) { int B_Number = 0 ; int cnt = 0 ; while ( N != 0 ) { int rem = N % 2 ; double c = Math . pow ( 10 , cnt ) ; B_Number += rem * c ; N /= 2 ; cnt ++ ; } return B_Number ; }
static int getSum ( int n ) { int sum = 0 ; while ( n != 0 ) { sum = sum + n % 10 ; n = n / 10 ; } return sum ; }
static void findMaxFrequency ( String s ) { int arr [ ] = new int [ 26 ] ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) arr [ s . charAt ( i ) - ' a ' ] ++ ; HashMap < Integer , Integer > hash = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < 26 ; i ++ ) if ( arr [ i ] != 0 ) { if ( hash . containsKey ( arr [ i ] ) ) { hash . put ( arr [ i ] , hash . get ( arr [ i ] ) + 1 ) ; } else { hash . put ( arr [ i ] , 1 ) ; } } int max_count = 0 , res = - 1 ; for ( Map . Entry < Integer , Integer > i : hash . entrySet ( ) ) { if ( max_count < i . getValue ( ) ) { res = i . getKey ( ) ; max_count = i . getValue ( ) ; } } System . out . println ( " Frequency ▁ " + res + " ▁ is ▁ repeated ▁ " + max_count + " ▁ times " ) ; }
static int countNonIncreasing ( int arr [ ] , int n ) { int cnt = 0 ; int len = 1 ; for ( int i = 0 ; i < n - 1 ; ++ i ) { if ( arr [ i + 1 ] >= arr [ i ] ) len ++ ; else { cnt += ( ( ( len + 1 ) * len ) / 2 ) ; len = 1 ; } } if ( len > 1 ) cnt += ( ( ( len - 1 ) * len ) / 2 ) ; return cnt ; }
static int ways ( int i , int arr [ ] , int n ) { if ( i == n - 1 ) return 1 ; int sum = 0 ; for ( int j = 1 ; j + i < n && j <= arr [ i ] ; j ++ ) { sum += ( ways ( i + j , arr , n ) ) % mod ; sum %= mod ; } return sum % mod ; }
static int smallestMultiple ( int n ) { if ( n == 1 ) return 5 ; return ( int ) ( Math . pow ( 10 , n - 1 ) ) ; }
static void LeibnizHarmonicTriangle ( int n ) { int C [ ] [ ] = new int [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= Math . min ( i , n ) ; j ++ ) { if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) System . out . print ( "1 / " + i * C [ i - 1 ] [ j - 1 ] + " ▁ " ) ; System . out . println ( ) ; } }
static int maximumXor ( int arr [ ] , int n ) { Stack < Integer > sForward = new Stack < Integer > ( ) , sBackward = new Stack < Integer > ( ) ; int ans = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { while ( ! sForward . isEmpty ( ) && arr [ i ] < arr [ sForward . peek ( ) ] ) { ans = Math . max ( ans , arr [ i ] ^ arr [ sForward . peek ( ) ] ) ; sForward . pop ( ) ; } sForward . add ( i ) ; while ( ! sBackward . isEmpty ( ) && arr [ n - i - 1 ] < arr [ sBackward . peek ( ) ] ) { ans = Math . max ( ans , arr [ n - i - 1 ] ^ arr [ sBackward . peek ( ) ] ) ; sBackward . pop ( ) ; } sBackward . add ( n - i - 1 ) ; } return ans ; }
static int minimumNumbers ( int n , int s ) { if ( ( s % n ) > 0 ) return s / n + 1 ; else return s / n ; }
public static String prefixSuffix ( String a , String b , int l ) { String prefix = a . substring ( 0 , l ) ; int lb = b . length ( ) ; String suffix = b . substring ( lb - l ) ; return ( prefix + suffix ) ; }
static float findRadiusOfcircumcircle ( float l , float b ) { if ( l < 0 || b < 0 ) return - 1 ; float radius = ( float ) Math . sqrt ( Math . pow ( l , 2 ) + Math . pow ( b , 2 ) ) / 2 ; return radius ; }
static int findTrailingZeros ( int n ) { if ( ( n & 1 ) == 1 ) return 0 ; else { int ans = 0 ; n /= 2 ; while ( n != 0 ) { ans += n / 5 ; n /= 5 ; } return ans ; } }
static void makePolygon ( double a ) { double n = 360 / ( 180 - a ) ; if ( n == ( int ) n ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; }
public static char [ ] sortArrays ( char [ ] arr ) { int length = arr . length ; for ( int j = 0 ; j < arr . length - 1 ; j ++ ) { int d1 = arr [ j ] ; int d2 = arr [ j + 1 ] ; if ( d1 > d2 ) { char temp = arr [ j ] ; arr [ j ] = arr [ j + 1 ] ; arr [ j + 1 ] = temp ; j = - 1 ; } } return arr ; }
static boolean productSumDivisible ( int n , int size ) { int sum = 0 , product = 1 ; while ( n > 0 ) { if ( size % 2 == 0 ) { product *= n % 10 ; } else { sum += n % 10 ; } n = n / 10 ; size -- ; } if ( product % sum == 0 ) { return true ; } return false ; }
static int XorSum ( int arr [ ] , int n ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 != 0 ) result += arr [ i ] ; } return result ; }
static int findSum ( int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += i * ( n - i ) ; return 2 * sum ; }
public static long countSubseq ( int [ ] arr , int n ) { HashMap < Integer , Integer > um = new HashMap < > ( ) ; long count = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( um . get ( arr [ i ] ) != null ) { int a = um . get ( arr [ i ] ) ; um . put ( arr [ i ] , ++ a ) ; } else um . put ( arr [ i ] , 1 ) ; } for ( HashMap . Entry < Integer , Integer > entry : um . entrySet ( ) ) { count *= entry . getValue ( ) ; } return count ; }
static void solve ( int A , int B ) { double p = B / 2.0 ; double M = Math . ceil ( 4 * p ) ; int N = 1 ; int O = - 2 * A ; double Q = Math . ceil ( A * A + 4 * p * p ) ; System . out . println ( M + " ▁ " + N + " ▁ " + O + " ▁ " + Q ) ; }
static boolean find ( String s1 , String s2 ) { int len = s1 . length ( ) , len_1 = s2 . length ( ) ; if ( len != len_1 ) { return false ; } int d [ ] = new int [ len ] ; d [ 0 ] = s2 . charAt ( 0 ) - s1 . charAt ( 0 ) ; for ( int i = 1 ; i < len ; i ++ ) { if ( s1 . charAt ( i ) > s2 . charAt ( i ) ) { return false ; } else { d [ i ] = s2 . charAt ( i ) - s1 . charAt ( i ) ; } } for ( int i = 0 ; i < len - 1 ; i ++ ) { if ( d [ i ] < d [ i + 1 ] ) { return false ; } } return true ; }
public static int composite_factors ( int n ) { int count = 0 ; int i , j ; int [ ] a = new int [ n + 1 ] ; for ( i = 0 ; i < n ; i ++ ) { a [ i ] = 0 ; } for ( i = 1 ; i <= n ; ++ i ) { if ( n % i == 0 ) { a [ i ] = i ; } } for ( i = 2 ; i <= n ; i ++ ) { j = 2 ; int p = 1 ; while ( j < a [ i ] ) { if ( a [ i ] % j == 0 ) { p = 0 ; break ; } j ++ ; } if ( p == 0 && a [ i ] != 0 ) { count ++ ; } } return count ; }
public static void Calculate_area ( ) { double b = 3 , h = 4 , s1 = 3 , s2 = 6 ; double s3 = 6 , Ht = 8 , SA ; SA = b * h + ( s1 + s2 + s3 ) * Ht ; System . out . printf ( " The ▁ area ▁ of ▁ triangular ▁ prism ▁ is ▁ : ▁ % f " , SA ) ; }
static void printSeriesSum ( int N ) { long sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { sum += Math . pow ( i , i - 1 ) ; } System . out . print ( sum + " \n " ) ; }
static int solve ( char X [ ] , char Y [ ] , int l , int r , int k , int dp [ ] [ ] [ ] ) { if ( k == 0 ) { return 0 ; } if ( l < 0 | r < 0 ) { return ( int ) 1e9 ; } if ( dp [ l ] [ r ] [ k ] != - 1 ) { return dp [ l ] [ r ] [ k ] ; } int cost = ( X [ l ] - ' a ' ) ^ ( Y [ r ] - ' a ' ) ; return dp [ l ] [ r ] [ k ] = Math . min ( Math . min ( cost + solve ( X , Y , l - 1 , r - 1 , k - 1 , dp ) , solve ( X , Y , l - 1 , r , k , dp ) ) , solve ( X , Y , l , r - 1 , k , dp ) ) ; }
static int getSingle ( int arr [ ] , int n ) { int ones = 0 , twos = 0 ; int common_bit_mask ; for ( int i = 0 ; i < n ; i ++ ) { twos = twos | ( ones & arr [ i ] ) ; ones = ones ^ arr [ i ] ; common_bit_mask = ~ ( ones & twos ) ; ones &= common_bit_mask ; twos &= common_bit_mask ; } return ones ; }
static void PossibleValues ( int b , int x , int n ) { int leastdivisible = ( b / x + 1 ) * x ; int flag = 1 ; while ( leastdivisible <= n ) { if ( leastdivisible - b >= 1 ) { System . out . print ( leastdivisible - b + " ▁ " ) ; leastdivisible += x ; flag = 0 ; } else break ; } if ( flag > 0 ) System . out . println ( - 1 ) ; }
static int evaluateBoolExpr ( StringBuffer s ) { int n = s . length ( ) ; for ( int i = 0 ; i < n ; i += 2 ) { if ( i + 1 < n && i + 2 < n ) { if ( s . charAt ( i + 1 ) == ' A ' ) { if ( s . charAt ( i + 2 ) == '0' || s . charAt ( i ) == 0 ) s . setCharAt ( i + 2 , '0' ) ; else s . setCharAt ( i + 2 , '1' ) ; } else if ( ( i + 1 ) < n && s . charAt ( i + 1 ) == ' B ' ) { if ( s . charAt ( i + 2 ) == '1' || s . charAt ( i ) == '1' ) s . setCharAt ( i + 2 , '1' ) ; else s . setCharAt ( i + 2 , '0' ) ; } else { if ( s . charAt ( i + 2 ) == s . charAt ( i ) ) s . setCharAt ( i + 2 , '0' ) ; else s . setCharAt ( i + 2 , '1' ) ; } } } return s . charAt ( n - 1 ) - '0' ; }
static int multiply ( ) { int pro = 1 ; for ( int i = 0 ; i < arr . length ; i ++ ) pro = pro * arr [ i ] ; return pro ; }
static void find ( int n , int m ) { if ( n <= 2 * m ) System . out . println ( " Minimum ▁ " + 0 ) ; else System . out . println ( " Minimum ▁ " + ( n - 2 * m ) ) ; int i ; for ( i = 1 ; i <= n ; i ++ ) { if ( i * ( i - 1 ) / 2 >= m ) break ; } System . out . println ( " Maximum ▁ " + ( n - i ) ) ; }
static void display ( int n ) { int i , j , k ; for ( i = 1 ; i <= n ; i ++ ) { for ( j = 1 , k = i ; j <= i ; j ++ , k -- ) { if ( k % 2 == 0 ) { System . out . print ( j ) ; } else { System . out . print ( " * " ) ; } } System . out . print ( " \n " ) ; } }
static int gcd ( int a , int b ) { if ( a == 0 ) return b ; if ( b == 0 ) return a ; if ( a == b ) return a ; if ( a > b ) return gcd ( a - b , b ) ; return gcd ( a , b - a ) ; }
static int maxdiff ( int arr [ ] , int n ) { Map < Integer , Integer > freq = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) freq . put ( arr [ i ] , freq . get ( arr [ i ] ) == null ? 1 : freq . get ( arr [ i ] ) + 1 ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( freq . get ( arr [ i ] ) > freq . get ( arr [ j ] ) && arr [ i ] > arr [ j ] ) ans = Math . max ( ans , freq . get ( arr [ i ] ) - freq . get ( arr [ j ] ) ) ; else if ( freq . get ( arr [ i ] ) < freq . get ( arr [ j ] ) && arr [ i ] < arr [ j ] ) ans = Math . max ( ans , freq . get ( arr [ j ] ) - freq . get ( arr [ i ] ) ) ; } } return ans ; }
static boolean isPowerOfK ( int n , int k ) { boolean oneSeen = false ; while ( n > 0 ) { int digit = n % k ; if ( digit > 1 ) return false ; if ( digit == 1 ) { if ( oneSeen ) return false ; oneSeen = true ; } n /= k ; } return true ; }
static int countIntervals ( int [ ] [ ] arr , int V , int N ) { int count = 0 ; int li , ri ; for ( int i = 0 ; i < N ; i ++ ) { li = arr [ i ] [ 0 ] ; ri = arr [ i ] [ 1 ] ; if ( V >= li && V <= ri ) count ++ ; } return count ; }
static void fill0X ( int m , int n ) { int i , k = 0 , l = 0 ; int r = m , c = n ; char a [ ] [ ] = new char [ m ] [ n ] ; char x = ' X ' ; while ( k < m && l < n ) { for ( i = l ; i < n ; ++ i ) a [ k ] [ i ] = x ; k ++ ; for ( i = k ; i < m ; ++ i ) a [ i ] [ n - 1 ] = x ; n -- ; if ( k < m ) { for ( i = n - 1 ; i >= l ; -- i ) a [ m - 1 ] [ i ] = x ; m -- ; } if ( l < n ) { for ( i = m - 1 ; i >= k ; -- i ) a [ i ] [ l ] = x ; l ++ ; } x = ( x == '0' ) ? ' X ' : '0' ; } for ( i = 0 ; i < r ; i ++ ) { for ( int j = 0 ; j < c ; j ++ ) System . out . print ( a [ i ] [ j ] + " ▁ " ) ; System . out . println ( ) ; } }
static int weightedMean ( int n ) { return ( 2 * n + 1 ) / 3 ; }
static int minMoves ( int n , int a [ ] , int k ) { int ct1 [ ] = new int [ k ] ; int ct0 [ ] = new int [ k ] ; int moves = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] == 1 ) ct1 [ i % k ] ++ ; else ct0 [ i % k ] ++ ; for ( int i = 0 ; i < k ; i ++ ) moves += Math . min ( ct1 [ i ] , ct0 [ i ] ) ; return moves ; }
static void printXYZ ( int n ) { if ( n == 1 ) System . out . println ( - 1 ) ; else { System . out . println ( " x ▁ is ▁ " + n ) ; System . out . println ( " y ▁ is ▁ " + ( n + 1 ) ) ; System . out . println ( " z ▁ is ▁ " + ( n * ( n + 1 ) ) ) ; } }
static int equalize ( int arr [ ] , int n , int k ) { int min_ele = Arrays . stream ( arr ) . min ( ) . getAsInt ( ) ; boolean flag = true ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! ( ( arr [ i ] + k ) >= min_ele + k && min_ele + k >= ( arr [ i ] - k ) ) ) { flag = false ; break ; } } if ( flag ) { return min_ele + k ; } else return - 1 ; }
static int minflip ( int [ ] arr1 , int [ ] arr2 , int [ ] arr3 , int p , int q , int n ) { int flip = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr1 [ i ] > 0 ^ arr2 [ i ] > 0 != arr3 [ i ] > 0 ) flip ++ ; return ( flip <= p + q ) ? flip : - 1 ; }
static int maxLength ( int [ ] a , int n ) { int maximum = 1 ; int left [ ] = new int [ n ] ; int right [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { left [ i ] = 1 ; right [ i ] = 1 ; } for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( a [ i ] > a [ i + 1 ] ) { right [ i ] = right [ i + 1 ] + 1 ; } maximum = Math . max ( maximum , right [ i ] ) ; } for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] < a [ i - 1 ] ) { left [ i ] = left [ i - 1 ] + 1 ; } } if ( n > 2 ) { for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( a [ i - 1 ] > a [ i + 1 ] ) { maximum = Math . max ( maximum , left [ i - 1 ] + right [ i + 1 ] ) ; } } } return maximum ; }
static long countWays ( int S [ ] , int m , int n ) { long [ ] table = new long [ n + 1 ] ; Arrays . fill ( table , 0 ) ; table [ 0 ] = 1 ; for ( int i = 0 ; i < m ; i ++ ) for ( int j = S [ i ] ; j <= n ; j ++ ) table [ j ] += table [ j - S [ i ] ] ; return table [ n ] ; }
static int maxSum ( int arr [ ] , int i , int n , int k ) { if ( i >= n ) return 0 ; if ( visit [ i ] ) return dp [ i ] ; visit [ i ] = true ; int tot = 0 ; dp [ i ] = maxSum ( arr , i + 1 , n , k ) ; for ( int j = i ; j < ( i + k ) && ( j < n ) ; j ++ ) { tot += arr [ j ] ; dp [ i ] = Math . max ( dp [ i ] , tot + maxSum ( arr , j + 2 , n , k ) ) ; } return dp [ i ] ; }
static void printNonDivisible ( int [ ] A , int [ ] B , int n , int m ) { int maxB = 0 ; for ( int i = 0 ; i < m ; i ++ ) if ( B [ i ] > maxB ) maxB = B [ i ] ; int [ ] mark = new int [ maxB + 1 ] ; for ( int i = 0 ; i < maxB ; i ++ ) mark [ i ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int x = A [ i ] ; x <= maxB ; x += A [ i ] ) mark [ x ] ++ ; for ( int i = 0 ; i < m ; i ++ ) if ( mark [ B [ i ] ] == 0 ) System . out . println ( B [ i ] ) ; }
static int nthTerm ( int N ) { return ( 2 * N + 3 ) * ( 2 * N + 3 ) - 2 * N ; }
static int findNumber ( int n ) { n -- ; int i = 1 ; while ( n >= 0 ) { n -= i ; ++ i ; } return ( n + i ) ; }
public static double sumOfSeries ( double num ) { double res = 0 , fact = 1 ; for ( int i = 1 ; i <= num ; i ++ ) { fact = fact * i ; res = res + ( i / fact ) ; } return ( res ) ; }
static int solve ( int [ ] arr , int n ) { int k = arr . length ; int mp [ ] = new int [ n + 2 ] ; for ( int i = 0 ; i <= n ; i ++ ) { mp [ i ] = 0 ; } for ( int i = 0 ; i < k ; i ++ ) { mp [ arr [ i ] ] = 1 ; } int leftSegment = arr [ 0 ] - 1 ; for ( int i = 1 ; i < k ; i ++ ) { leftSegment = Math . max ( leftSegment , arr [ i ] - arr [ i - 1 ] - 1 ) ; } int rightSegment = n - arr [ k - 1 ] ; int maxSegment = Math . max ( leftSegment , rightSegment ) ; int tim ; if ( ( maxSegment & 1 ) == 1 ) tim = ( maxSegment / 2 ) + 1 ; else tim = maxSegment / 2 ; return tim ; }
static boolean validate ( long n ) { for ( int i = 0 ; i < 10 ; i ++ ) { long temp = n ; int count = 0 ; while ( temp > 0 ) { if ( temp % 10 == i ) count ++ ; if ( count > i ) return false ; temp /= 10 ; } } return true ; }
static String removeChars ( String str , int k ) { int hash [ ] = new int [ MAX_CHAR ] ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; ++ i ) { hash [ str . charAt ( i ) - ' a ' ] ++ ; } String res = " " ; for ( int i = 0 ; i < n ; ++ i ) { if ( hash [ str . charAt ( i ) - ' a ' ] >= k ) { res += str . charAt ( i ) ; } } return res ; }
static int subsetGraph ( int C [ ] [ ] ) { HashSet < Integer > vertices = new HashSet < > ( ) ; for ( int i = 0 ; i < N ; ++ i ) { vertices . add ( i ) ; } while ( ! vertices . isEmpty ( ) ) { if ( vertices . size ( ) == 1 ) { return 1 ; } boolean someone_removed = false ; for ( int x : vertices ) { HashSet < Integer > values = new HashSet < > ( ) ; for ( int y : vertices ) { if ( y != x ) { values . add ( C [ x ] [ y ] ) ; } } if ( values . size ( ) == 1 ) { vertices . remove ( x ) ; someone_removed = true ; break ; } } if ( ! someone_removed ) { break ; } } return ( vertices . size ( ) ) ; }
static int averageOdd ( int n ) { if ( n % 2 == 0 ) { System . out . println ( " Invalid ▁ Input " ) ; return - 1 ; } int sum = 0 , count = 0 ; while ( n >= 1 ) { count ++ ; sum += n ; n = n - 2 ; } return sum / count ; }
static int waysToSplit ( String s ) { int n = s . length ( ) ; int answer = 0 ; int prefix [ ] = new int [ n ] ; int suffix [ ] = new int [ n ] ; int seen [ ] = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) { int prev = ( i - 1 >= 0 ? prefix [ i - 1 ] : 0 ) ; if ( seen [ s . charAt ( i ) - ' a ' ] == 0 ) { prefix [ i ] += ( prev + 1 ) ; } else prefix [ i ] = prev ; seen [ s . charAt ( i ) - ' a ' ] = 1 ; } for ( int i = 0 ; i < 26 ; i ++ ) seen [ i ] = 0 ; suffix [ n - 1 ] = 0 ; for ( int i = n - 1 ; i >= 1 ; i -- ) { int prev = suffix [ i ] ; if ( seen [ s . charAt ( i ) - ' a ' ] == 0 ) { suffix [ i - 1 ] += ( prev + 1 ) ; } else suffix [ i - 1 ] = prev ; seen [ s . charAt ( i ) - ' a ' ] = 1 ; } for ( int i = 0 ; i < n ; i ++ ) { if ( prefix [ i ] == suffix [ i ] ) answer ++ ; } return answer ; }
static int Square ( int row , int column , int moves ) { int a = 0 , b = 0 , c = 0 , d = 0 , total = 0 ; a = row - moves ; b = row + moves ; c = column - moves ; d = column + moves ; if ( a < 1 ) a = 1 ; if ( c < 1 ) c = 1 ; if ( b > 8 ) b = 8 ; if ( d > 8 ) d = 8 ; total = ( b - a + 1 ) * ( d - c + 1 ) - 1 ; return total ; }
static int countDistictSubarray ( int arr [ ] , int n ) { HashMap < Integer , Integer > vis = new HashMap < Integer , Integer > ( ) { @ Override public Integer get ( Object key ) { if ( ! containsKey ( key ) ) return 0 ; return super . get ( key ) ; } } ; for ( int i = 0 ; i < n ; ++ i ) vis . put ( arr [ i ] , 1 ) ; int k = vis . size ( ) ; vis . clear ( ) ; int ans = 0 , right = 0 , window = 0 ; for ( int left = 0 ; left < n ; ++ left ) { while ( right < n && window < k ) { vis . put ( arr [ right ] , vis . get ( arr [ right ] ) + 1 ) ; if ( vis . get ( arr [ right ] ) == 1 ) ++ window ; ++ right ; } if ( window == k ) ans += ( n - right + 1 ) ; vis . put ( arr [ left ] , vis . get ( arr [ left ] ) - 1 ) ; if ( vis . get ( arr [ left ] ) == 0 ) -- window ; } return ans ; }
static void checkEVENodd ( int arr [ ] , int n , int l , int r ) { if ( arr [ r ] == 1 ) System . out . println ( " odd " ) ; else System . out . println ( " even " ) ; }
static int nthTerm ( int n ) { return 5 * ( int ) Math . pow ( n , 2 ) - 5 * n ; }
static int countStr ( int n , int bCount , int cCount ) { if ( bCount < 0 || cCount < 0 ) return 0 ; if ( n == 0 ) return 1 ; if ( bCount == 0 && cCount == 0 ) return 1 ; int res = countStr ( n - 1 , bCount , cCount ) ; res += countStr ( n - 1 , bCount - 1 , cCount ) ; res += countStr ( n - 1 , bCount , cCount - 1 ) ; return res ; }
public static void getPairsCount ( int [ ] arr , int sum ) { int count = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) for ( int j = i + 1 ; j < arr . length ; j ++ ) if ( ( arr [ i ] + arr [ j ] ) == sum ) count ++ ; System . out . printf ( " Count ▁ of ▁ pairs ▁ is ▁ % d " , count ) ; }
static int nthTerm ( int n ) { return 2 * ( int ) Math . pow ( n , 2 ) + 4 * n - 2 ; }
static void findNumbers ( int n ) { int i = 1 ; while ( i <= n ) { System . out . print ( ( 3 * i * ( i - 1 ) + 1 ) + " ▁ " ) ; i ++ ; } }
static int findPermutation ( int n ) { int len = ( int ) Math . ceil ( Math . log10 ( n ) ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( n % 2 != 0 ) { return n ; } else { n = ( n / 10 ) + ( n % 10 ) * ( int ) Math . pow ( 10 , len - i - 1 ) ; continue ; } } return - 1 ; }
static void findMissing ( int a [ ] , int b [ ] , int n , int m ) { for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < m ; j ++ ) if ( a [ i ] == b [ j ] ) break ; if ( j == m ) System . out . print ( a [ i ] + " ▁ " ) ; } }
public static int maxLenSub ( int arr [ ] , int n ) { int mls [ ] = new int [ n ] , max = 0 ; for ( int i = 0 ; i < n ; i ++ ) mls [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( Math . abs ( arr [ i ] - arr [ j ] ) <= 1 && mls [ i ] < mls [ j ] + 1 ) mls [ i ] = mls [ j ] + 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( max < mls [ i ] ) max = mls [ i ] ; return max ; }
static void maxSum ( long arr [ ] [ ] ) { long [ ] [ ] dp = new long [ n + 1 ] [ 3 ] ; for ( int i = 0 ; i < n ; i ++ ) { long m1 = 0 , m2 = 0 , m3 = 0 ; for ( int j = 0 ; j < m ; j ++ ) { if ( ( j / ( m / 3 ) ) == 0 ) { m1 = Math . max ( m1 , arr [ i ] [ j ] ) ; } else if ( ( j / ( m / 3 ) ) == 1 ) { m2 = Math . max ( m2 , arr [ i ] [ j ] ) ; } else if ( ( j / ( m / 3 ) ) == 2 ) { m3 = Math . max ( m3 , arr [ i ] [ j ] ) ; } } dp [ i + 1 ] [ 0 ] = Math . max ( dp [ i ] [ 1 ] , dp [ i ] [ 2 ] ) + m1 ; dp [ i + 1 ] [ 1 ] = Math . max ( dp [ i ] [ 0 ] , dp [ i ] [ 2 ] ) + m2 ; dp [ i + 1 ] [ 2 ] = Math . max ( dp [ i ] [ 1 ] , dp [ i ] [ 0 ] ) + m3 ; } System . out . print ( Math . max ( Math . max ( dp [ n ] [ 0 ] , dp [ n ] [ 1 ] ) , dp [ n ] [ 2 ] ) + " \n " ) ; }
static int run_tasks ( Queue < Integer > A , Queue < Integer > B ) { int total_time = 0 ; while ( ! A . isEmpty ( ) ) { int x = A . peek ( ) ; int y = B . peek ( ) ; if ( x == y ) { A . remove ( ) ; B . remove ( ) ; total_time ++ ; } else { A . remove ( ) ; A . add ( x ) ; total_time += 2 ; } } return total_time ; }
static void findNthTerm ( int n ) { if ( n % 2 == 0 ) { n = n / 2 ; n = 2 * ( n - 1 ) ; System . out . println ( n / 2 ) ; } else { n = ( n / 2 ) + 1 ; n = 2 * ( n - 1 ) ; System . out . println ( n ) ; } }
static int lastElement ( int a [ ] , int n ) { int steps = 1 ; Vector < Integer > [ ] v = new Vector [ N ] ; for ( int i = 0 ; i < N ; i ++ ) v [ i ] = new Vector < Integer > ( ) ; if ( n == 1 ) return a [ 0 ] ; for ( int i = 0 ; i < n ; i += 2 ) v [ steps ] . add ( a [ i ] | a [ i + 1 ] ) ; while ( v [ steps ] . size ( ) > 1 ) { steps += 1 ; for ( int i = 0 ; i < v [ steps - 1 ] . size ( ) ; i += 2 ) { if ( steps % 2 == 1 ) v [ steps ] . add ( v [ steps - 1 ] . get ( i ) | v [ steps - 1 ] . get ( i + 1 ) ) ; else v [ steps ] . add ( v [ steps - 1 ] . get ( i ) ^ v [ steps - 1 ] . get ( i + 1 ) ) ; } } return v [ steps ] . get ( 0 ) ; }
static void powerSet ( String str , int index , String curr ) { int n = str . length ( ) ; if ( index == n ) { System . out . println ( curr ) ; return ; } powerSet ( str , index + 1 , curr + str . charAt ( index ) ) ; powerSet ( str , index + 1 , curr ) ; }
static int valueofX ( int ar [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + ar [ i ] ; } if ( sum % n == 0 ) { return sum / n ; } else { int A = sum / n , B = sum / n + 1 ; int ValueA = 0 , ValueB = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ValueA += ( ar [ i ] - A ) * ( ar [ i ] - A ) ; ValueB += ( ar [ i ] - B ) * ( ar [ i ] - B ) ; } if ( ValueA < ValueB ) { return A ; } else { return B ; } } }
static boolean isDivisiblePalindrome ( int n ) { int hash [ ] = new int [ 10 ] ; int digitSum = 0 ; while ( n != 0 ) { digitSum += n % 10 ; hash [ n % 10 ] ++ ; n /= 10 ; } if ( digitSum % 3 != 0 ) return false ; int oddCount = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { if ( hash [ i ] % 2 != 0 ) oddCount ++ ; } if ( oddCount > 1 ) return false ; else return true ; }
static int longestPrefixSuffix ( String s ) { int n = s . length ( ) ; int lps [ ] = new int [ n ] ; lps [ 0 ] = 0 ; int len = 0 ; int i = 1 ; while ( i < n ) { if ( s . charAt ( i ) == s . charAt ( len ) ) { len ++ ; lps [ i ] = len ; i ++ ; } else { if ( len != 0 ) { len = lps [ len - 1 ] ; } else { lps [ i ] = 0 ; i ++ ; } } } int res = lps [ n - 1 ] ; return ( res > n / 2 ) ? n / 2 : res ; }
static double expectedSteps ( int x ) { if ( x == 0 ) return 0 ; if ( x <= 5 ) return 6 ; if ( v [ x ] == 1 ) return dp [ x ] ; v [ x ] = 1 ; dp [ x ] = 1 + ( expectedSteps ( x - 1 ) + expectedSteps ( x - 2 ) + expectedSteps ( x - 3 ) + expectedSteps ( x - 4 ) + expectedSteps ( x - 5 ) + expectedSteps ( x - 6 ) ) / 6 ; return dp [ x ] ; }
static int bitwiseAndOdd ( int n ) { int result = 1 ; for ( int i = 3 ; i <= n ; i = i + 2 ) { result = ( result & i ) ; } return result ; }
static int printMinimumProduct ( int arr [ ] , int n ) { int first_min = Math . min ( arr [ 0 ] , arr [ 1 ] ) ; int second_min = Math . max ( arr [ 0 ] , arr [ 1 ] ) ; for ( int i = 2 ; i < n ; i ++ ) { if ( arr [ i ] < first_min ) { second_min = first_min ; first_min = arr [ i ] ; } else if ( arr [ i ] < second_min ) second_min = arr [ i ] ; } return first_min * second_min ; }
static int remainderWith7 ( String num ) { int series [ ] = { 1 , 3 , 2 , - 1 , - 3 , - 2 } ; int series_index = 0 ; int result = 0 ; for ( int i = num . length ( ) - 1 ; i >= 0 ; i -- ) { int digit = num . charAt ( i ) - '0' ; result += digit * series [ series_index ] ; series_index = ( series_index + 1 ) % 6 ; result %= 7 ; } if ( result < 0 ) result = ( result + 7 ) % 7 ; return result ; }
public static boolean isPower ( int x , int y ) { if ( x == 1 ) return ( y == 1 ) ; int pow = 1 ; while ( pow < y ) pow = pow * x ; return ( pow == y ) ; }
static void prefix ( char [ ] str ) { int k = 1 , j ; int n = str . length ; Vector < Integer > g = new Vector < > ( ) ; int flag = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( str [ i ] == str [ 0 ] ) { g . add ( i ) ; flag = 1 ; } } if ( flag == 0 ) { System . out . println ( String . valueOf ( str ) ) ; } else { int len = g . size ( ) ; while ( k < g . get ( 0 ) ) { int cnt = 0 ; for ( j = 0 ; j < len ; j ++ ) { if ( ( g . get ( j ) + k ) < n && str [ g . get ( j ) + k ] == str [ k ] ) { cnt ++ ; } } if ( cnt == len ) { k ++ ; } else { break ; } } for ( int i = 0 ; i < k ; i ++ ) { System . out . print ( str [ i ] ) ; } System . out . println ( ) ; } }
static int Remainder ( String str , int R ) { int len = str . length ( ) ; int Num , Rem = 0 ; for ( int i = 0 ; i < len ; i ++ ) { Num = Rem * 10 + ( str . charAt ( i ) - '0' ) ; Rem = Num % R ; } return Rem ; }
static int countConsecutive ( int n ) { String s = Integer . toString ( n ) ; int count = 0 ; for ( int i = 0 ; i < s . length ( ) - 1 ; i ++ ) if ( s . charAt ( i ) == s . charAt ( i + 1 ) ) count ++ ; return count ; }
static int FindMinNumber ( int arr [ ] , int n , int k ) { int i = 0 ; int j = 0 ; int min_num = Integer . MAX_VALUE ; boolean found = false ; int sum = 0 ; while ( i < n ) { sum = sum + arr [ i ] ; if ( sum == k ) { min_num = Math . min ( min_num , ( ( n - ( i + 1 ) ) + j ) ) ; found = true ; } else if ( sum > k ) { while ( sum > k ) { sum = sum - arr [ j ] ; j ++ ; } if ( sum == k ) { min_num = Math . min ( min_num , ( ( n - ( i + 1 ) ) + j ) ) ; found = true ; } } i ++ ; } if ( found ) return min_num ; return - 1 ; }
public static void printPairs ( int arr [ ] , int n ) { Vector < Integer > v = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( Math . abs ( arr [ i ] ) == Math . abs ( arr [ j ] ) ) v . add ( Math . abs ( arr [ i ] ) ) ; if ( v . size ( ) == 0 ) return ; Collections . sort ( v ) ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) System . out . print ( - v . get ( i ) + " ▁ " + v . get ( i ) ) ; }
static int cntPairs ( int a [ ] , int n ) { int odd = 0 , even = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 1 ) odd ++ ; else if ( ( a [ i ] / 2 ) % 2 == 1 ) even ++ ; } int ans = odd * even + ( odd * ( odd - 1 ) ) / 2 ; return ans ; }
public static int MDAS_Factorial ( int N ) { if ( N <= 2 ) return N ; if ( N <= 4 ) return ( N + 3 ) ; if ( ( N - 4 ) % 4 == 0 ) return ( N + 1 ) ; else if ( ( N - 4 ) % 4 <= 2 ) return ( N + 2 ) ; else return ( N - 1 ) ; }
static double nthRoot ( int A , int N ) { double xPre = Math . random ( ) % 10 ; double eps = 0.001 ; double delX = 2147483647 ; double xK = 0.0 ; while ( delX > eps ) { xK = ( ( N - 1.0 ) * xPre + ( double ) A / Math . pow ( xPre , N - 1 ) ) / ( double ) N ; delX = Math . abs ( xK - xPre ) ; xPre = xK ; } return xK ; }
static boolean strmatch ( char txt [ ] , char pat [ ] , int n , int m ) { if ( m == 0 ) return ( n == 0 ) ; int i = 0 , j = 0 , index_txt = - 1 , index_pat = - 1 ; while ( i < n ) { if ( j < m && txt [ i ] == pat [ j ] ) { i ++ ; j ++ ; } else if ( j < m && pat [ j ] == ' ? ' ) { i ++ ; j ++ ; } else if ( j < m && pat [ j ] == ' * ' ) { index_txt = i ; index_pat = j ; j ++ ; } else if ( index_pat != - 1 ) { j = index_pat + 1 ; i = index_txt + 1 ; index_txt ++ ; } else { return false ; } } while ( j < m && pat [ j ] == ' * ' ) { j ++ ; } if ( j == m ) { return true ; } return false ; }
static int sum ( int a , int b ) { int sum = 0 ; for ( int i = 1 ; i <= Math . min ( a , b ) ; i ++ ) if ( a % i == 0 && b % i == 0 ) sum += i ; return sum ; }
static int minCells ( int mat [ ] [ ] , int m , int n ) { int dp [ ] [ ] = new int [ m ] [ n ] ; for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) dp [ i ] [ j ] = Integer . MAX_VALUE ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( dp [ i ] [ j ] != Integer . MAX_VALUE && ( j + mat [ i ] [ j ] ) < n && ( dp [ i ] [ j ] + 1 ) < dp [ i ] [ j + mat [ i ] [ j ] ] ) dp [ i ] [ j + mat [ i ] [ j ] ] = dp [ i ] [ j ] + 1 ; if ( dp [ i ] [ j ] != Integer . MAX_VALUE && ( i + mat [ i ] [ j ] ) < m && ( dp [ i ] [ j ] + 1 ) < dp [ i + mat [ i ] [ j ] ] [ j ] ) dp [ i + mat [ i ] [ j ] ] [ j ] = dp [ i ] [ j ] + 1 ; } } if ( dp [ m - 1 ] [ n - 1 ] != Integer . MAX_VALUE ) return dp [ m - 1 ] [ n - 1 ] ; return - 1 ; }
static int getNumStrictMonotone ( int len ) { int [ ] [ ] DP = new int [ len ] [ DP_s ] ; for ( int i = 0 ; i < DP_s ; ++ i ) DP [ 0 ] [ i ] = i + 1 ; for ( int i = 1 ; i < len ; ++ i ) for ( int j = 1 ; j < DP_s ; ++ j ) DP [ i ] [ j ] = DP [ i - 1 ] [ j - 1 ] + DP [ i ] [ j - 1 ] ; return DP [ len - 1 ] [ DP_s - 1 ] ; }
static int totalNumber ( int n ) { return 8 * ( int ) Math . pow ( 9 , n - 1 ) ; }
static String OctToBin ( String octnum ) { long i = 0 ; String binary = " " ; while ( i < octnum . length ( ) ) { char c = octnum . charAt ( ( int ) i ) ; switch ( c ) { case '0' : binary += "000" ; break ; case '1' : binary += "001" ; break ; case '2' : binary += "010" ; break ; case '3' : binary += "011" ; break ; case '4' : binary += "100" ; break ; case '5' : binary += "101" ; break ; case '6' : binary += "110" ; break ; case '7' : binary += "111" ; break ; default : System . out . println ( " \n Invalid ▁ Octal ▁ Digit ▁ " + octnum . charAt ( ( int ) i ) ) ; break ; } i ++ ; } return binary ; }
static int largestSubSeq ( String arr [ ] , int n ) { int [ ] count = new int [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) { String str = arr [ i ] ; boolean [ ] hash = new boolean [ MAX ] ; for ( int j = 0 ; j < str . length ( ) ; j ++ ) { hash [ str . charAt ( j ) - ' a ' ] = true ; } for ( int j = 0 ; j < MAX ; j ++ ) { if ( hash [ j ] ) count [ j ] ++ ; } } int max = - 1 ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( max < count [ i ] ) max = count [ i ] ; } return max ; }
static void towerOfHanoi ( int n , char from_rod , char to_rod , char aux_rod1 , char aux_rod2 ) { if ( n == 0 ) return ; if ( n == 1 ) { System . out . println ( " Move ▁ disk ▁ " + n + " ▁ from ▁ rod ▁ " + from_rod + " ▁ to ▁ rod ▁ " + to_rod ) ; return ; } towerOfHanoi ( n - 2 , from_rod , aux_rod1 , aux_rod2 , to_rod ) ; System . out . println ( " Move ▁ disk ▁ " + ( n - 1 ) + " ▁ from ▁ rod ▁ " + from_rod + " ▁ to ▁ rod ▁ " + aux_rod2 ) ; System . out . println ( " Move ▁ disk ▁ " + n + " ▁ from ▁ rod ▁ " + from_rod + " ▁ to ▁ rod ▁ " + to_rod ) ; System . out . println ( " Move ▁ disk ▁ " + ( n - 1 ) + " ▁ from ▁ rod ▁ " + aux_rod2 + " ▁ to ▁ rod ▁ " + to_rod ) ; towerOfHanoi ( n - 2 , aux_rod1 , to_rod , from_rod , aux_rod2 ) ; }
static float discountPercentage ( float S , float M ) { float discount = M - S ; float disPercent = ( discount / M ) * 100 ; return disPercent ; }
static int countTriplets ( int arr [ ] , int n , int m ) { int count = 0 ; Arrays . sort ( arr ) ; int end , start , mid ; for ( end = n - 1 ; end >= 2 ; end -- ) { start = 0 ; mid = end - 1 ; while ( start < mid ) { long prod = arr [ end ] * arr [ start ] * arr [ mid ] ; if ( prod > m ) mid -- ; else if ( prod < m ) start ++ ; else if ( prod == m ) { count ++ ; mid -- ; start ++ ; } } } return count ; }
static int countSol ( int coeff [ ] , int start , int end , int rhs ) { if ( rhs == 0 ) return 1 ; int result = 0 ; for ( int i = start ; i <= end ; i ++ ) if ( coeff [ i ] <= rhs ) result += countSol ( coeff , i , end , rhs - coeff [ i ] ) ; return result ; }
static int sumEqualProduct ( int a [ ] , int n ) { int zero = 0 , two = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) { zero ++ ; } if ( a [ i ] == 2 ) { two ++ ; } } int cnt = ( zero * ( zero - 1 ) ) / 2 + ( two * ( two - 1 ) ) / 2 ; return cnt ; }
static void ReplaceElementsByFrequency ( int arr [ ] , int n ) { HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { if ( mp . get ( arr [ i ] ) == null ) { mp . put ( arr [ i ] , 1 ) ; } else { mp . put ( arr [ i ] , ( mp . get ( arr [ i ] ) + 1 ) ) ; } } for ( int i = 0 ; i < n ; ++ i ) { if ( mp . get ( arr [ i ] ) != null ) { arr [ i ] = mp . get ( arr [ i ] ) ; } } }
static int findSubsequence ( int arr [ ] , int n ) { int len = 1 ; int tmp ; int i , j , d ; int dp [ ] = new int [ 10 ] ; int cnt [ ] = new int [ 10 ] ; int locMax ; tmp = arr [ 0 ] ; while ( tmp > 0 ) { dp [ tmp % 10 ] = 1 ; tmp /= 10 ; } for ( i = 1 ; i < n ; i ++ ) { tmp = arr [ i ] ; locMax = 1 ; Arrays . fill ( cnt , 0 ) ; while ( tmp > 0 ) { cnt [ tmp % 10 ] = 1 ; tmp /= 10 ; } for ( d = 0 ; d <= 9 ; d ++ ) { if ( cnt [ d ] == 1 ) { dp [ d ] ++ ; locMax = Math . max ( locMax , dp [ d ] ) ; } } for ( d = 0 ; d <= 9 ; d ++ ) { if ( cnt [ d ] == 1 ) { dp [ d ] = locMax ; } } len = Math . max ( len , locMax ) ; } return len ; }
static void CountingEvenOdd ( int arr [ ] , int arr_size ) { int even_count = 0 ; int odd_count = 0 ; for ( int i = 0 ; i < arr_size ; i ++ ) { if ( ( arr [ i ] & 1 ) == 1 ) odd_count ++ ; else even_count ++ ; } System . out . println ( " Number ▁ of ▁ even " + " ▁ elements ▁ = ▁ " + even_count + " ▁ Number ▁ of ▁ odd ▁ elements ▁ = ▁ " + odd_count ) ; }
static boolean check ( String s ) { for ( int i = 0 ; i < s . length ( ) - 1 ; i ++ ) if ( s . charAt ( i ) == s . charAt ( i + 1 ) ) return true ; return false ; }
static boolean isDivisible ( long n ) { while ( n / 100 != 0 ) { long d = n % 10 ; n /= 10 ; n += d * 7 ; } return ( n % 23 == 0 ) ; }
static void kthString ( int n , int k ) { int total = 0 ; int i = 1 ; while ( total < k ) { total = total + n - i ; i ++ ; } int first_y_position = i - 1 ; int second_y_position = k - ( total - n + first_y_position ) ; for ( int j = 1 ; j < first_y_position ; j ++ ) System . out . print ( " x " ) ; System . out . print ( " y " ) ; int j = first_y_position + 1 ; while ( second_y_position > 1 ) { System . out . print ( " x " ) ; second_y_position -- ; j ++ ; } System . out . print ( " y " ) ; while ( j < n ) { System . out . print ( " x " ) ; j ++ ; } }
static void printUncommon ( int arr1 [ ] , int arr2 [ ] , int n1 , int n2 ) { int i = 0 , j = 0 , k = 0 ; while ( i < n1 && j < n2 ) { if ( arr1 [ i ] < arr2 [ j ] ) { System . out . print ( arr1 [ i ] + " ▁ " ) ; i ++ ; k ++ ; } else if ( arr2 [ j ] < arr1 [ i ] ) { System . out . print ( arr2 [ j ] + " ▁ " ) ; k ++ ; j ++ ; } else { i ++ ; j ++ ; } } while ( i < n1 ) { System . out . print ( arr1 [ i ] + " ▁ " ) ; i ++ ; k ++ ; } while ( j < n2 ) { System . out . print ( arr2 [ j ] + " ▁ " ) ; j ++ ; k ++ ; } }
static int findValueAtX ( int n ) { return ( n * n * n ) + n ; }
static int log_a_to_base_b ( int a , int b ) { int rslt = ( a > b - 1 ) ? 1 + log_a_to_base_b ( a / b , b ) : 0 ; return rslt ; }
static boolean onlyFirstAndLastAreSet ( int n ) { if ( n == 1 ) return true ; if ( n == 2 ) return false ; return ( ( ( n - 1 ) & ( n - 2 ) ) == 0 ) ; }
static int lenghtOfLongestAP ( int set [ ] , int n ) { if ( n <= 2 ) return n ; int L [ ] [ ] = new int [ n ] [ n ] ; int llap = 2 ; for ( int i = 0 ; i < n ; i ++ ) L [ i ] [ n - 1 ] = 2 ; for ( int j = n - 2 ; j >= 1 ; j -- ) { int i = j - 1 , k = j + 1 ; while ( i >= 0 && k <= n - 1 ) { if ( set [ i ] + set [ k ] < 2 * set [ j ] ) k ++ ; else if ( set [ i ] + set [ k ] > 2 * set [ j ] ) { L [ i ] [ j ] = 2 ; i -- ; } else { L [ i ] [ j ] = L [ j ] [ k ] + 1 ; llap = Math . max ( llap , L [ i ] [ j ] ) ; i -- ; k ++ ; } } while ( i >= 0 ) { L [ i ] [ j ] = 2 ; i -- ; } } return llap ; }
static int maxAND ( int L , int R ) { if ( L == R ) return L ; else if ( ( R - L ) == 1 ) return ( R & L ) ; else { if ( ( ( R - 1 ) & R ) > ( ( R - 2 ) & ( R - 1 ) ) ) return ( ( R - 1 ) & R ) ; else return ( ( R - 2 ) & ( R - 1 ) ) ; } }
static int maxSum ( int [ ] [ ] mat , int n ) { if ( n == 1 ) return mat [ 0 ] [ 0 ] ; int dp [ ] [ ] = new int [ n ] [ n ] ; int maxSum = Integer . MIN_VALUE , max ; for ( int j = 0 ; j < n ; j ++ ) dp [ n - 1 ] [ j ] = mat [ n - 1 ] [ j ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < n ; j ++ ) { max = Integer . MIN_VALUE ; if ( ( ( j - 1 ) >= 0 ) && ( max < dp [ i + 1 ] [ j - 1 ] ) ) max = dp [ i + 1 ] [ j - 1 ] ; if ( ( ( j + 1 ) < n ) && ( max < dp [ i + 1 ] [ j + 1 ] ) ) max = dp [ i + 1 ] [ j + 1 ] ; dp [ i ] [ j ] = mat [ i ] [ j ] + max ; } } for ( int j = 0 ; j < n ; j ++ ) if ( maxSum < dp [ 0 ] [ j ] ) maxSum = dp [ 0 ] [ j ] ; return maxSum ; }
static double surface_area_octahedron ( double side ) { return ( 2 * ( Math . sqrt ( 3 ) ) * ( side * side ) ) ; }
static int getHermiteNumber ( int n ) { if ( n == 0 ) return 1 ; else if ( n == 1 ) return 1 ; else return - 2 * ( n - 1 ) * getHermiteNumber ( n - 2 ) ; }
public static int cubesum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( 2 * i ) * ( 2 * i ) * ( 2 * i ) ; return sum ; }
static String findSum ( String str1 , String str2 ) { if ( str1 . length ( ) > str2 . length ( ) ) { String t = str1 ; str1 = str2 ; str2 = t ; } String str = " " ; int n1 = str1 . length ( ) , n2 = str2 . length ( ) ; int diff = n2 - n1 ; int carry = 0 ; for ( int i = n1 - 1 ; i >= 0 ; i -- ) { int sum = ( ( int ) ( str1 . charAt ( i ) - '0' ) + ( int ) ( str2 . charAt ( i + diff ) - '0' ) + carry ) ; str += ( char ) ( sum % 10 + '0' ) ; carry = sum / 10 ; } for ( int i = n2 - n1 - 1 ; i >= 0 ; i -- ) { int sum = ( ( int ) ( str2 . charAt ( i ) - '0' ) + carry ) ; str += ( char ) ( sum % 10 + '0' ) ; carry = sum / 10 ; } if ( carry > 0 ) str += ( char ) ( carry + '0' ) ; return new StringBuilder ( str ) . reverse ( ) . toString ( ) ; }
static void print_sequence ( int n , int k ) { int b = n / ( k * ( k + 1 ) / 2 ) ; if ( b == 0 ) { System . out . println ( " - 1" ) ; } else { int r = 1 ; for ( int x = 1 ; x * x <= n ; x ++ ) { if ( n % x != 0 ) continue ; if ( x <= b && x > r ) r = x ; if ( n / x <= b && n / x > r ) r = n / x ; } for ( int i = 1 ; i < k ; i ++ ) System . out . print ( r * i + " ▁ " ) ; int res = n - ( r * ( k * ( k - 1 ) / 2 ) ) ; System . out . println ( res ) ; } }
public static boolean isEven ( int n ) { if ( ( n & 1 ) == 0 ) return true ; else return false ; }
static void printIndex ( String str , String s ) { boolean flag = false ; for ( int i = 0 ; i < str . length ( ) - s . length ( ) + 1 ; i ++ ) { if ( str . substring ( i , i + s . length ( ) ) . equals ( s ) ) { System . out . print ( i + " ▁ " ) ; flag = true ; } } if ( flag == false ) { System . out . println ( " NONE " ) ; } }
public static void checkType ( int arr [ ] , int n ) { if ( arr [ 0 ] <= arr [ 1 ] && arr [ n - 2 ] <= arr [ n - 1 ] ) System . out . println ( " Increasing " ) ; else if ( arr [ 0 ] >= arr [ 1 ] && arr [ n - 2 ] >= arr [ n - 1 ] ) System . out . println ( " Decreasing " ) ; else if ( arr [ 0 ] <= arr [ 1 ] && arr [ n - 2 ] >= arr [ n - 1 ] ) System . out . println ( " Increasing ▁ then ▁ decreasing " ) ; else System . out . println ( " Decreasing ▁ then ▁ increasing " ) ; }
static int countDivisibleSubseq ( String str , int n ) { int len = str . length ( ) ; int dp [ ] [ ] = new int [ len ] [ n ] ; dp [ 0 ] [ ( str . charAt ( 0 ) - '0' ) % n ] ++ ; for ( int i = 1 ; i < len ; i ++ ) { dp [ i ] [ ( str . charAt ( i ) - '0' ) % n ] ++ ; for ( int j = 0 ; j < n ; j ++ ) { dp [ i ] [ j ] += dp [ i - 1 ] [ j ] ; dp [ i ] [ ( j * 10 + ( str . charAt ( i ) - '0' ) ) % n ] += dp [ i - 1 ] [ j ] ; } } return dp [ len - 1 ] [ 0 ] ; }
static void convert12 ( String str ) { int h1 = ( int ) str . charAt ( 0 ) - '0' ; int h2 = ( int ) str . charAt ( 1 ) - '0' ; int hh = h1 * 10 + h2 ; String Meridien ; if ( hh < 12 ) { Meridien = " AM " ; } else Meridien = " PM " ; hh %= 12 ; if ( hh == 0 ) { System . out . print ( "12" ) ; for ( int i = 2 ; i < 8 ; ++ i ) { System . out . print ( str . charAt ( i ) ) ; } } else { System . out . print ( hh ) ; for ( int i = 2 ; i < 8 ; ++ i ) { System . out . print ( str . charAt ( i ) ) ; } } System . out . println ( " ▁ " + Meridien ) ; }
static int seriesSum ( int n ) { return ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ; }
static String removeDuplicate ( char str [ ] , int n ) { int index = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < i ; j ++ ) { if ( str [ i ] == str [ j ] ) { break ; } } if ( j == i ) { str [ index ++ ] = str [ i ] ; } } return String . valueOf ( Arrays . copyOf ( str , index ) ) ; }
static int solve ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int a = 0 , b = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 != 0 ) a = a * 10 + arr [ i ] ; else b = b * 10 + arr [ i ] ; } return a + b ; }
static void dfs ( int u , int p ) { for ( int v : g [ u ] ) { if ( v != p ) { dfs ( v , u ) ; for ( int i = 0 ; i < 22 ; i ++ ) a [ u ] [ i ] += a [ v ] [ i ] ; } } int pp = 0 ; for ( int i = 0 ; i < 22 ; i ++ ) { if ( ! ( ( a [ u ] [ i ] > 0 && x [ i ] - a [ u ] [ i ] > 0 ) || ( a [ u ] [ i ] == 0 && x [ i ] == 0 ) ) ) { pp = 1 ; break ; } } if ( pp == 0 ) ans ++ ; }
static int minSteps ( int i , int j , int arr [ ] [ ] ) { if ( i == n - 1 && j == n - 1 ) { return 0 ; } if ( i > n - 1 || j > n - 1 ) { return 9999999 ; } if ( v [ i ] [ j ] == 1 ) { return dp [ i ] [ j ] ; } v [ i ] [ j ] = 1 ; dp [ i ] [ j ] = 1 + Math . min ( minSteps ( i + arr [ i ] [ j ] , j , arr ) , minSteps ( i , j + arr [ i ] [ j ] , arr ) ) ; return dp [ i ] [ j ] ; }
static int maxDiff ( int [ ] arr , int n ) { int SubsetSum_1 = 0 , SubsetSum_2 = 0 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { boolean isSingleOccurance = true ; for ( int j = i + 1 ; j <= n - 1 ; j ++ ) { if ( arr [ i ] == arr [ j ] ) { isSingleOccurance = false ; arr [ i ] = arr [ j ] = 0 ; break ; } } if ( isSingleOccurance ) { if ( arr [ i ] > 0 ) SubsetSum_1 += arr [ i ] ; else SubsetSum_2 += arr [ i ] ; } } return Math . abs ( SubsetSum_1 - SubsetSum_2 ) ; }
public static int minChanges ( String str ) { int n = str . length ( ) ; if ( n > MAX_CHAR ) return - 1 ; int dist_count = 0 ; int count [ ] = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) count [ i ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( count [ str . charAt ( i ) - ' a ' ] == 0 ) dist_count ++ ; count [ str . charAt ( i ) - ' a ' ] ++ ; } return ( n - dist_count ) ; }
static void printSquares ( int n ) { int square = 0 , prev_x = 0 ; for ( int x = 0 ; x < n ; x ++ ) { square = ( square + x + prev_x ) ; System . out . print ( square + " ▁ " ) ; prev_x = x ; } }
static int findSum ( int arr [ ] , int N ) { Map < Integer , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) mp . put ( arr [ i ] , mp . get ( arr [ i ] ) == null ? 1 : mp . get ( arr [ i ] ) + 1 ) ; int minFreq = Integer . MAX_VALUE ; minFreq = Collections . min ( mp . entrySet ( ) , Comparator . comparingInt ( Map . Entry :: getKey ) ) . getValue ( ) ; int sum = 0 ; for ( Map . Entry < Integer , Integer > entry : mp . entrySet ( ) ) { if ( entry . getValue ( ) == minFreq ) { sum += entry . getKey ( ) * entry . getValue ( ) ; } } return sum ; }
static int countCubes ( int a , int b ) { int cnt = 0 ; for ( int i = a ; i <= b ; i ++ ) for ( int j = 1 ; j * j * j <= i ; j ++ ) if ( j * j * j == i ) cnt ++ ; return cnt ; }
static void printSortedLevels ( int arr [ ] , int n ) { int level = 0 ; for ( int i = 0 ; i < n ; level ++ ) { int cnt = ( int ) Math . pow ( 2 , level ) ; cnt -= 1 ; int j = Math . min ( i + cnt , n - 1 ) ; Arrays . sort ( arr , i , j + 1 ) ; while ( i <= j ) { System . out . print ( arr [ i ] + " ▁ " ) ; i ++ ; } System . out . println ( ) ; } }
static String lastNonRepeating ( String str , int n ) { int freq [ ] = new int [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) freq [ str . charAt ( i ) ] ++ ; for ( int i = n - 1 ; i >= 0 ; i -- ) { char ch = str . charAt ( i ) ; if ( freq [ ch ] == 1 ) return ( " " + ch ) ; } return " - 1" ; }
static boolean areVowelsInOrder ( String s ) { int n = s . length ( ) ; char c = ( char ) 64 ; for ( int i = 1 ; i < n ; i ++ ) { if ( s . charAt ( i ) == ' a ' || s . charAt ( i ) == ' e ' || s . charAt ( i ) == ' i ' || s . charAt ( i ) == ' o ' || s . charAt ( i ) == ' u ' ) { if ( s . charAt ( i ) < c ) return false ; else { c = s . charAt ( i ) ; } } } return true ; }
public static int sumDivisorsOfDivisors ( int n ) { HashMap < Integer , Integer > mp = new HashMap < > ( ) ; for ( int j = 2 ; j <= Math . sqrt ( n ) ; j ++ ) { int count = 0 ; while ( n % j == 0 ) { n /= j ; count ++ ; } if ( count != 0 ) mp . put ( j , count ) ; } if ( n != 1 ) mp . put ( n , 1 ) ; int ans = 1 ; for ( HashMap . Entry < Integer , Integer > entry : mp . entrySet ( ) ) { int pw = 1 ; int sum = 0 ; for ( int i = entry . getValue ( ) + 1 ; i >= 1 ; i -- ) { sum += ( i * pw ) ; pw = entry . getKey ( ) ; } ans *= sum ; } return ans ; }
static int waysToArrange ( int N , int K , int [ ] k ) { int [ ] [ ] C = new int [ N + 1 ] [ N + 1 ] ; int i , j ; for ( i = 0 ; i <= N ; i ++ ) { for ( j = 0 ; j <= i ; j ++ ) { if ( j == 0 || j == i ) { C [ i ] [ j ] = 1 ; } else { C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) ; } } } int [ ] dp = new int [ K + 1 ] ; int count = 0 ; dp [ 0 ] = 1 ; for ( i = 0 ; i < K ; i ++ ) { dp [ i + 1 ] = ( dp [ i ] * C [ count + k [ i ] - 1 ] [ k [ i ] - 1 ] ) ; count += k [ i ] ; } return dp [ K ] ; }
static int minSum ( int arr [ ] , int n ) { int sum = arr [ 0 ] , prev = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] <= prev ) { prev = prev + 1 ; sum = sum + prev ; } else { sum = sum + arr [ i ] ; prev = arr [ i ] ; } } return sum ; }
static void printTwoOdd ( int arr [ ] , int size ) { int xor2 = arr [ 0 ] ; int set_bit_no ; int i ; int n = size - 2 ; int x = 0 , y = 0 ; for ( i = 1 ; i < size ; i ++ ) xor2 = xor2 ^ arr [ i ] ; set_bit_no = xor2 & ~ ( xor2 - 1 ) ; for ( i = 0 ; i < size ; i ++ ) { if ( ( arr [ i ] & set_bit_no ) > 0 ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } System . out . println ( " The ▁ two ▁ ODD ▁ elements ▁ are ▁ " + x + " ▁ & ▁ " + y ) ; }
static String areAllBitsSet ( int n ) { if ( n == 0 ) return " No " ; if ( ( ( n + 1 ) & n ) == 0 ) return " Yes " ; return " No " ; }
static boolean isPossible ( int a [ ] , int n ) { int k = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] != i + 1 ) k ++ ; } if ( k <= 2 ) return true ; return false ; }
static boolean isPlusPossible ( int arr [ ] , int n ) { HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . containsKey ( arr [ i ] ) ) { mp . put ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . put ( arr [ i ] , 1 ) ; } } boolean foundModOne = false ; for ( Map . Entry < Integer , Integer > x : mp . entrySet ( ) ) { int element = x . getKey ( ) ; int frequency = x . getValue ( ) ; if ( frequency % 4 == 0 ) continue ; if ( frequency % 4 == 1 ) { if ( foundModOne ) return false ; foundModOne = true ; } else return false ; } return true ; }
public static String printVertically ( String s ) { String result = " " ; HashMap < Integer , String > map = new HashMap < > ( ) ; Scanner sc = new Scanner ( s ) ; int max = Integer . MIN_VALUE ; while ( sc . hasNext ( ) ) { String st = sc . next ( ) ; max = Math . max ( max , st . length ( ) ) ; } sc = new Scanner ( s ) ; while ( sc . hasNext ( ) ) { String st = sc . next ( ) ; for ( int i = 0 ; i < st . length ( ) ; i ++ ) { char ch = st . charAt ( i ) ; map . put ( i , map . getOrDefault ( i , " " ) + ch ) ; } for ( int i = st . length ( ) ; i < max ; i ++ ) { map . put ( i , map . getOrDefault ( i , " " ) + " $ " ) ; } } for ( int i = 0 ; i < max ; i ++ ) { String a = map . get ( i ) ; result += a + " ▁ " ; } return result ; }
static int calculate_ ( String s ) { if ( s . length ( ) == 1 ) return 0 ; int count_ = 0 ; char [ ] s1 = s . toCharArray ( ) ; for ( int i = s . length ( ) - 1 ; i > 0 😉 { if ( s1 [ i ] == '0' ) { count_ ++ ; i -- ; } else { count_ ++ ; while ( s1 [ i ] == '1' && i > 0 ) { count_ ++ ; i -- ; } if ( i == 0 ) count_ ++ ; s1 [ i ] = '1' ; } } return count_ ; }
static long evenPowerSum ( int n ) { long sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int j = 2 * i ; sum = sum + ( j * j * j * j ) ; } return sum ; }
public static int maxLengthSquare ( int row , int column , int [ ] [ ] arr , int k ) { int sum [ ] [ ] = new int [ row + 1 ] [ column + 1 ] ; int cur_max = 1 ; int max = 0 ; for ( int i = 1 ; i <= row ; i ++ ) { for ( int j = 1 ; j <= column ; j ++ ) { sum [ i ] [ j ] = sum [ i - 1 ] [ j ] + sum [ i ] [ j - 1 ] + arr [ i - 1 ] [ j - 1 ] - sum [ i - 1 ] [ j - 1 ] ; if ( i >= cur_max && j >= cur_max && sum [ i ] [ j ] - sum [ i - cur_max ] [ j ] - sum [ i ] [ j - cur_max ] + sum [ i - cur_max ] [ j - cur_max ] <= k ) { max = cur_max ++ ; } } } return max ; }
static int findExtra ( int arr1 [ ] , int arr2 [ ] , int n ) { int index = n ; int left = 0 , right = n - 1 ; while ( left <= right ) { int mid = ( left + right ) / 2 ; if ( arr2 [ mid ] == arr1 [ mid ] ) left = mid + 1 ; else { index = mid ; right = mid - 1 ; } } return index ; }
static void findSetBits ( int n ) { int [ ] dp = new int [ n + 1 ] ; System . out . print ( dp [ 0 ] + " ▁ " ) ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) { dp [ i ] = dp [ i / 2 ] ; } else { dp [ i ] = dp [ i / 2 ] + 1 ; } System . out . print ( dp [ i ] + " ▁ " ) ; } }
public static int countIdenticalRows ( int mat [ ] [ ] ) { int count = 0 ; for ( int i = 0 ; i < mat . length ; i ++ ) { HashSet < Integer > hs = new HashSet < > ( ) ; for ( int j = 0 ; j < mat [ i ] . length ; j ++ ) { hs . add ( mat [ i ] [ j ] ) ; } if ( hs . size ( ) == 1 ) count ++ ; } return count ; }
static int maxDiff ( int [ ] arr , int n ) { int result = 0 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] != arr [ i + 1 ] ) result += Math . abs ( arr [ i ] ) ; else i ++ ; } if ( arr [ n - 2 ] != arr [ n - 1 ] ) result += Math . abs ( arr [ n - 1 ] ) ; return result ; }
static String removeOddFrequencyCharacters ( String s ) { HashMap < Character , Integer > m = new HashMap < Character , Integer > ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char p = s . charAt ( i ) ; Integer count = m . get ( p ) ; if ( count == null ) { count = 0 ; m . put ( p , 1 ) ; } else m . put ( p , count + 1 ) ; } String new_string = " " ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( ( m . get ( s . charAt ( i ) ) & 1 ) == 1 ) continue ; new_string += s . charAt ( i ) ; } return new_string ; }
static int maxDiff ( int arr [ ] , int n ) { int maxDiff = - 1 ; int maxRight = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] > maxRight ) maxRight = arr [ i ] ; else { int diff = maxRight - arr [ i ] ; if ( diff > maxDiff ) { maxDiff = diff ; } } } return maxDiff ; }
static int findlargestAfterDel ( int arr [ ] , int m , int del [ ] , int n ) { HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { if ( mp . containsKey ( del [ i ] ) ) { mp . put ( del [ i ] , mp . get ( del [ i ] ) + 1 ) ; } else { mp . put ( del [ i ] , 1 ) ; } } int largestElement = Integer . MIN_VALUE ; for ( int i = 0 ; i < m ; i ++ ) { if ( mp . containsKey ( arr [ i ] ) ) { mp . put ( arr [ i ] , mp . get ( arr [ i ] ) - 1 ) ; if ( mp . get ( arr [ i ] ) == 0 ) mp . remove ( arr [ i ] ) ; } else largestElement = Math . max ( largestElement , arr [ i ] ) ; } return largestElement ; }
static int findMod4 ( String s , int n ) { int k ; if ( n == 1 ) k = s . charAt ( 0 ) - '0' ; else k = ( s . charAt ( n - 2 ) - '0' ) * 10 + s . charAt ( n - 1 ) - '0' ; return ( k % 4 ) ; }
public static int lenoflongestnonpalindrome ( String s ) { int max1 = 1 , len = 0 ; char [ ] new_str = s . toCharArray ( ) ; for ( int i = 0 ; i < new_str . length - 1 ; i ++ ) { if ( new_str [ i ] == new_str [ i + 1 ] ) len = 0 ; else if ( i > 0 && ( new_str [ i + 1 ] == new_str [ i - 1 ] ) ) len = 1 ; else len ++ ; max1 = Math . max ( max1 , len + 1 ) ; } if ( max1 == 1 ) return 0 ; else return max1 ; }
static Boolean isPentagonal ( int N ) { int i = 1 , M ; do { M = ( 3 * i * i - i ) / 2 ; i += 1 ; } while ( M < N ) ; return ( M == N ) ; }
static long getNthTerm ( long N ) { return 4 * ( long ) Math . pow ( N , 2 ) - 3 * N + 2 ; }
static int swapNibbles ( int x ) { return ( ( x & 0x0F ) << 4 | ( x & 0xF0 ) >> 4 ) ; }
static int minSteps ( int i , int j , int arr [ ] [ ] ) { if ( i == n - 1 && j == n - 1 ) { return 0 ; } if ( i > n - 1 || j > n - 1 ) { return 9999999 ; } if ( v [ i ] [ j ] == 1 ) { return dp [ i ] [ j ] ; } v [ i ] [ j ] = 1 ; dp [ i ] [ j ] = 9999999 ; for ( int k = Math . max ( 0 , arr [ i ] [ j ] + j - n + 1 ) ; k <= Math . min ( n - i - 1 , arr [ i ] [ j ] ) ; k ++ ) { dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , minSteps ( i + k , j + arr [ i ] [ j ] - k , arr ) ) ; } dp [ i ] [ j ] ++ ; return dp [ i ] [ j ] ; }
static int modInverse ( int a , int m ) { a = a % m ; for ( int x = 1 ; x < m ; x ++ ) if ( ( a * x ) % m == 1 ) return x ; return 1 ; }
static void getnumbers ( int n ) { Vector < Integer > divisor = new Vector < Integer > ( ) ; for ( int i = 2 ; i * i <= n ; i ++ ) { while ( n % i == 0 ) { divisor . add ( i ) ; n /= i ; } } if ( n != 1 ) { divisor . add ( n ) ; } int a , b , c , size ; a = b = c = 1 ; size = divisor . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { if ( a == 1 ) { a = a * divisor . get ( i ) ; } else if ( b == 1 || b == a ) { b = b * divisor . get ( i ) ; } else { c = c * divisor . get ( i ) ; } } if ( a == 1 || b == 1 || c == 1 || a == b || b == c || a == c ) { System . out . print ( " - 1" + " \n " ) ; } else { System . out . print ( a + " ▁ " + b + " ▁ " + c + " \n " ) ; } }
static void removeSpecialCharacter ( String str ) { char [ ] s = str . toCharArray ( ) ; int j = 0 ; for ( int i = 0 ; i < s . length ; i ++ ) { if ( ( s [ i ] >= ' A ' && s [ i ] <= ' Z ' ) || ( s [ i ] >= ' a ' && s [ i ] <= ' z ' ) ) { s [ j ] = s [ i ] ; j ++ ; } } System . out . println ( String . valueOf ( s ) . substring ( 0 , j ) ) ; }
static int calculateSum ( int n ) { int r1 = 2 , r2 = 3 ; int a1 = 1 , a2 = 1 ; return ( int ) ( a1 * ( Math . pow ( r1 , n ) - 1 ) / ( r1 - 1 ) + a2 * ( Math . pow ( r2 , n ) - 1 ) / ( r2 - 1 ) ) ; }
static void fib ( int n ) { int a = 0 , b = 1 ; if ( n >= 0 ) System . out . print ( a + " ▁ " ) ; if ( n >= 1 ) System . out . print ( b + " ▁ " ) ; for ( int i = 2 ; i <= n ; i ++ ) { System . out . print ( a + b + " ▁ " ) ; b = a + b ; a = b - a ; } }
static void checkAllOnes ( int arr [ ] , int n , int k ) { int brr [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 1 ) { int h = k + 1 ; int j = i ; while ( ( j >= 0 ) && ( h -- != 0 ) ) { brr [ j ] = 1 ; j -- ; } h = k + 1 ; j = i ; while ( ( j < n ) && ( h -- != 0 ) ) { brr [ j ] = 1 ; j ++ ; } } } int flag = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( brr [ i ] == 0 ) { flag = 1 ; break ; } } if ( flag == 1 ) System . out . println ( "0" ) ; else System . out . println ( "1" ) ; }
static int makeOdd ( int n ) { if ( n % 2 != 0 ) return 1 ; int i ; for ( i = 2 ; i <= n ; i ++ ) if ( ( n % i == 0 ) && ( ( n / i ) % 2 == 1 ) ) break ; return i ; }
static int Right_most_setbit ( int num ) { int pos = 1 ; for ( int i = 0 ; i < INT_SIZE ; i ++ ) { if ( ( num & ( 1 << i ) ) == 0 ) pos ++ ; else break ; } return pos ; }
static int MinStep ( int a [ ] , int n ) { int positive = 0 , negative = 0 , zero = 0 ; int step = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) { zero ++ ; } else if ( a [ i ] < 0 ) { negative ++ ; step = step + ( - 1 - a [ i ] ) ; } else { positive ++ ; step = step + ( a [ i ] - 1 ) ; } } if ( negative % 2 == 0 ) { step = step + zero ; } else { if ( zero > 0 ) { step = step + zero ; } else { step = step + 2 ; } } return step ; }
static int findCount ( int m , int n ) { int num1 = 0 ; for ( int i = 0 ; i < m ; i ++ ) num1 = ( num1 * 10 ) + 9 ; int num2 = 0 ; for ( int i = 0 ; i < ( m - 1 ) ; i ++ ) num2 = ( num2 * 10 ) + 9 ; return ( ( num1 / n ) - ( num2 / n ) ) ; }
static void sortArray ( int a [ ] , int n ) { Vector < Integer > ans = new Vector < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] >= 0 ) ans . add ( a [ i ] ) ; } Collections . sort ( ans ) ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] >= 0 ) { a [ i ] = ans . get ( j ) ; j ++ ; } } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( a [ i ] + " ▁ " ) ; }
static int breakSum ( int n ) { int dp [ ] = new int [ n + 1 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) dp [ i ] = Math . max ( dp [ i / 2 ] + dp [ i / 3 ] + dp [ i / 4 ] , i ) ; return dp [ n ] ; }
static int findNumbers ( int n , int w ) { int x = 0 , sum = 0 ; if ( w >= 0 && w <= 8 ) { x = 9 - w ; } else if ( w >= - 9 && w <= - 1 ) { x = 10 + w ; } sum = ( int ) Math . pow ( 10 , n - 2 ) ; sum = ( x * sum ) ; return sum ; }
static int arraySortedOrNot ( int arr [ ] , int n ) { if ( n == 1 || n == 0 ) return 1 ; if ( arr [ n - 1 ] < arr [ n - 2 ] ) return 0 ; return arraySortedOrNot ( arr , n - 1 ) ; }
static int isPowerOfFour ( int n ) { int count = 0 ; int x = n & ( n - 1 ) ; if ( n > 0 && x == 0 ) { while ( n > 1 ) { n >>= 1 ; count += 1 ; } return ( count % 2 == 0 ) ? 1 : 0 ; } return 0 ; }
public static int numLen ( int K ) { if ( K % 2 == 0 || K % 5 == 0 ) return - 1 ; int number = 0 ; int len = 1 ; for ( len = 1 ; len <= K ; len ++ ) { number = ( number * 10 + 1 ) % K ; if ( number == 0 ) return len ; } return - 1 ; }
static int minOperations ( int n , String a , String b , String c ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { char x = a . charAt ( i ) ; char y = b . charAt ( i ) ; char z = c . charAt ( i ) ; if ( x == y && y == z ) ; else if ( x == y || y == z || x == z ) { ans ++ ; } else { ans += 2 ; } } return ans ; }
static int binarySearch ( int arr [ ] , int low , int high , int key ) { if ( high < low ) return - 1 ; int mid = ( low + high ) / 2 ; if ( key == arr [ mid ] ) return mid ; if ( key > arr [ mid ] ) return binarySearch ( arr , ( mid + 1 ) , high , key ) ; return binarySearch ( arr , low , ( mid - 1 ) , key ) ; }
static int getPeriod ( int n ) { int rem = 1 ; for ( int i = 1 ; i <= n + 1 ; i ++ ) rem = ( 10 * rem ) % n ; int d = rem ; int count = 0 ; do { rem = ( 10 * rem ) % n ; count ++ ; } while ( rem != d ) ; return count ; }
static int findMaxProduct ( int arr [ ] , int n ) { int i ; int ans = Integer . MIN_VALUE ; int maxval = 1 ; int minval = 1 ; int prevMax ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) { maxval = maxval * arr [ i ] ; minval = Math . min ( 1 , minval * arr [ i ] ) ; } else if ( arr [ i ] == 0 ) { minval = 1 ; maxval = 0 ; } else if ( arr [ i ] < 0 ) { prevMax = maxval ; maxval = minval * arr [ i ] ; minval = prevMax * arr [ i ] ; } ans = Math . max ( ans , maxval ) ; if ( maxval <= 0 ) { maxval = 1 ; } } return ans ; }
static int countStr ( int n ) { return 1 + ( n * 2 ) + ( n * ( ( n * n ) - 1 ) / 2 ) ; }
static int getMinimumSum ( int arr [ ] , int n ) { int fMin = Integer . MAX_VALUE , sMin = Integer . MAX_VALUE , tMin = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < fMin ) { tMin = sMin ; sMin = fMin ; fMin = arr [ i ] ; } else if ( arr [ i ] < sMin ) { tMin = sMin ; sMin = arr [ i ] ; } else if ( arr [ i ] < tMin ) { tMin = arr [ i ] ; } } return ( fMin + sMin + tMin ) ; }
static int primeProduct ( int arr [ ] , int n ) { int max_val = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; Vector < Boolean > prime = new Vector < Boolean > ( max_val + 1 ) ; for ( int i = 0 ; i < max_val + 1 ; i ++ ) prime . add ( i , Boolean . TRUE ) ; prime . add ( 0 , Boolean . FALSE ) ; prime . add ( 1 , Boolean . FALSE ) ; for ( int p = 2 ; p * p <= max_val ; p ++ ) { if ( prime . get ( p ) == true ) { for ( int i = p * 2 ; i <= max_val ; i += p ) prime . add ( i , Boolean . FALSE ) ; } } int prod = 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( prime . get ( arr [ i ] ) ) prod *= arr [ i ] ; return prod ; }
private static int maxDistance ( int [ ] array ) { int max1 = Integer . MIN_VALUE ; int min1 = Integer . MAX_VALUE ; int max2 = Integer . MIN_VALUE ; int min2 = Integer . MAX_VALUE ; for ( int i = 0 ; i < array . length ; i ++ ) { max1 = Math . max ( max1 , array [ i ] + i ) ; min1 = Math . min ( min1 , array [ i ] + i ) ; max2 = Math . max ( max2 , array [ i ] - i ) ; min2 = Math . min ( min2 , array [ i ] - i ) ; } return Math . max ( max1 - min1 , max2 - min2 ) ; }
static int maximum_middle_value ( int n , int k , int arr [ ] ) { int ans = - 1 ; int low = ( n + 1 - k ) / 2 ; int high = ( n + 1 - k ) / 2 + k ; for ( int i = low ; i <= high ; i ++ ) { ans = Math . max ( ans , arr [ i - 1 ] ) ; } return ans ; }
static Queue < Integer > reverse ( Queue < Integer > q ) { int s = q . size ( ) ; Queue < Integer > ans = new LinkedList < > ( ) ; for ( int i = 0 ; i < s ; i ++ ) { for ( int j = 0 ; j < q . size ( ) - 1 ; j ++ ) { int x = q . peek ( ) ; q . remove ( ) ; q . add ( x ) ; } ans . add ( q . peek ( ) ) ; q . remove ( ) ; } return ans ; }
static int countSteps ( int x , int y ) { if ( x % y == 0 ) return x / y ; return x / y + countSteps ( y , x % y ) ; }
static long fifthPowerSum ( int n ) { long sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum = sum + ( i * i * i * i * i ) ; return sum ; }
static int divSum ( int n ) { int result = 0 ; for ( int i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( i == ( n / i ) ) result += i ; else result += ( i + n / i ) ; } } return ( result + n + 1 ) ; }
static void findNextWord ( char [ ] s , int m ) { m += 97 ; int n = s . length ; int i = s . length - 1 ; s [ i ] ++ ; while ( i >= 0 && i <= n - 1 ) { if ( s [ i ] >= m ) { s [ i ] = ' a ' ; s [ -- i ] ++ ; } else if ( s [ i ] == s [ i - 1 ] || s [ i ] == s [ i - 2 ] ) { s [ i ] ++ ; } else { i ++ ; } } if ( i <= - 1 ) { System . out . println ( " - 1" ) ; } else { System . out . println ( s ) ; } }
static int items ( int n , int a [ ] ) { Arrays . sort ( a ) ; int z = a [ n - 1 ] ; int x = 1 ; int s = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { s += a [ i ] ; if ( s <= z ) x += 1 ; else break ; } return x ; }
static boolean isHeterogram ( String s , int n ) { int hash [ ] = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) != ' ▁ ' ) { if ( hash [ s . charAt ( i ) - ' a ' ] == 0 ) hash [ s . charAt ( i ) - ' a ' ] = 1 ; else return false ; } } return true ; }
static int findCount ( String str ) { int result = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( i == ( str . charAt ( i ) - ' a ' ) || i == ( str . charAt ( i ) - ' A ' ) ) { result ++ ; } } return result ; }
static int countWords ( String str ) { int state = OUT ; int wc = 0 ; int i = 0 ; while ( i < str . length ( ) ) { if ( str . charAt ( i ) == ' ▁ ' || str . charAt ( i ) == ' \n ' || str . charAt ( i ) == ' \t ' ) state = OUT ; else if ( state == OUT ) { state = IN ; ++ wc ; } ++ i ; } return wc ; }
public static int CountPair ( int arr [ ] , int n ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) if ( i * arr [ i ] > j * arr [ j ] ) result ++ ; } return result ; }
static int minimumSwaps ( int [ ] arr ) { int count = 0 ; int i = 0 ; while ( i < arr . length ) { if ( arr [ i ] != i + 1 ) { while ( arr [ i ] != i + 1 ) { int temp = 0 ; temp = arr [ arr [ i ] - 1 ] ; arr [ arr [ i ] - 1 ] = arr [ i ] ; arr [ i ] = temp ; count ++ ; } } i ++ ; } return count ; }
static int pairs ( int n ) { int [ ] [ ] c = new int [ 10 ] [ 10 ] ; int tmp = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i >= tmp * 10 ) tmp *= 10 ; c [ i / tmp ] [ i % 10 ] ++ ; } int ans = 0 ; for ( int i = 1 ; i < 10 ; i ++ ) for ( int j = 1 ; j < 10 ; j ++ ) ans += c [ i ] [ j ] * c [ j ] [ i ] ; return ans ; }
static String longestRepeatedSubSeq ( String str ) { int n = str . length ( ) ; int [ ] [ ] dp = new int [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= n ; j ++ ) dp [ i ] [ j ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= n ; j ++ ) if ( str . charAt ( i - 1 ) == str . charAt ( j - 1 ) && i != j ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; String res = " " ; int i = n , j = n ; while ( i > 0 && j > 0 ) { if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j - 1 ] + 1 ) { res = res + str . charAt ( i - 1 ) ; i -- ; j -- ; } else if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j ] ) i -- ; else j -- ; } String reverse = " " ; for ( int k = res . length ( ) - 1 ; k >= 0 ; k -- ) { reverse = reverse + res . charAt ( k ) ; } return reverse ; }
static int factorial ( int n ) { int i = n , fact = 1 ; while ( n / i != n ) { fact = fact * i ; i -- ; } return fact ; }
static int minDiff ( int n , int x , int A [ ] ) { int mn = A [ 0 ] , mx = A [ 0 ] ; for ( int i = 0 ; i < n ; ++ i ) { mn = Math . min ( mn , A [ i ] ) ; mx = Math . max ( mx , A [ i ] ) ; } return Math . max ( 0 , mx - mn - 2 * x ) ; }
static int calcFunction ( int n , int r ) { int finalDenominator = 1 ; int mx = Math . max ( r , n - r ) ; for ( int i = mx + 1 ; i <= n ; i ++ ) { int denominator = ( int ) Math . pow ( i , i ) ; int numerator = ( int ) Math . pow ( i - mx , i - mx ) ; finalDenominator = ( finalDenominator * denominator ) / numerator ; } return finalDenominator ; }
static double sumOfSeries ( double a , double n ) { double res = 0 , prev = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { prev *= ( a / i ) ; res = res + prev ; } return ( res ) ; }
static int count_numbers ( int k , int n ) { int [ ] [ ] dp = new int [ n + 1 ] [ 2 ] ; dp [ 1 ] [ 0 ] = 0 ; dp [ 1 ] [ 1 ] = k - 1 ; for ( int i = 2 ; i <= n ; i ++ ) { dp [ i ] [ 0 ] = dp [ i - 1 ] [ 1 ] ; dp [ i ] [ 1 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] ) * ( k - 1 ) ; } return dp [ n ] [ 0 ] + dp [ n ] [ 1 ] ; }
static void majority ( int a [ ] , int p , int q , int size ) { int start = 0 , ends = q ; int [ ] arr = new int [ p ] ; int k = 0 ; while ( k < p ) { int one = 0 ; for ( int j = start ; j < ends ; j ++ ) { if ( a [ j ] == 1 ) { one ++ ; } } start = ends ; ends = ends + q ; arr [ k ] = one ; k ++ ; } start = 0 ; ends = q ; boolean found = false ; while ( ends > 0 ) { int dist_one = 0 ; for ( int i = 0 ; i < p ; i ++ ) if ( arr [ i ] > q / 2 ) dist_one ++ ; if ( dist_one > p / 2 ) { found = true ; System . out . println ( " Yes " ) ; return ; } start -- ; ends -- ; if ( start < 0 ) start = size + start ; int st = start , en = ends , l = 0 ; while ( en < size ) { if ( a [ st % size ] != a [ en % size ] ) { if ( a [ st % size ] == 1 ) arr [ l ] ++ ; else arr [ l ] -- ; } l ++ ; st = ( st + q ) ; en = en + q ; } } if ( found == false ) { System . out . println ( " No " ) ; } }
static float ellipsearea ( float r ) { if ( r < 0 ) return - 1 ; float a = ( float ) ( ( 3.14f * r * r ) / 4 ) ; return a ; }
static void findMaximumBefore ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int currAns = - 1 ; for ( int j = i - 1 ; j >= 0 ; j -- ) { if ( arr [ j ] > currAns && arr [ j ] < arr [ i ] ) { currAns = arr [ j ] ; } } System . out . print ( currAns + " ▁ " ) ; } }
static void perfectSquares ( float l , float r ) { int number = ( int ) Math . ceil ( Math . sqrt ( l ) ) ; int n2 = number * number ; number = ( number * 2 ) + 1 ; while ( ( n2 >= l && n2 <= r ) ) { System . out . print ( n2 + " ▁ " ) ; n2 = n2 + number ; number += 2 ; } }
static int countWays ( int num ) { int [ ] dp = new int [ num + 1 ] ; int MOD = ( int ) 1E9 + 7 ; dp [ 1 ] = 2 ; for ( int i = 2 ; i <= num ; ++ i ) { dp [ i ] = 0 ; for ( int j = 1 ; j <= 3 ; ++ j ) { if ( i - j == 0 ) dp [ i ] += 1 ; else if ( j == 1 ) dp [ i ] += dp [ i - j ] * 2 ; else if ( i - j > 0 ) dp [ i ] += dp [ i - j ] ; if ( dp [ i ] >= MOD ) dp [ i ] %= MOD ; } } return dp [ num ] ; }
static int sumOfTermsInNthRow ( int n ) { int sum = ( int ) ( n * ( 2 * pow ( n , 2 ) + 1 ) ) ; return sum ; }
static int minToggle ( int arr [ ] , int n ) { int zero [ ] = new int [ n + 1 ] ; zero [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { if ( arr [ i - 1 ] == 0 ) zero [ i ] = zero [ i - 1 ] + 1 ; else zero [ i ] = zero [ i - 1 ] ; } int ans = n ; for ( int i = 1 ; i <= n ; ++ i ) ans = Math . min ( ans , i - zero [ i ] + zero [ n ] - zero [ i ] ) ; return ans ; }
static void checksum ( int n ) { if ( n % 3 == 0 ) System . out . println ( n / 3 - 1 + " ▁ " + n / 3 + " ▁ " + ( n / 3 + 1 ) ) ; else System . out . println ( " - 1" ) ; }
static String FirstAndLast ( String str ) { String [ ] arrOfStr = str . split ( " ▁ " ) ; String res = " " ; for ( String a : arrOfStr ) { res += a . substring ( 1 , a . length ( ) - 1 ) + " ▁ " ; } return res ; }
public static void countWays ( int a [ ] , int n ) { int i , j ; long suff [ ] = new long [ n ] ; if ( a [ n - 1 ] == 2 ) suff [ n - 1 ] = 1 ; for ( i = n - 2 ; i >= 0 ; i -- ) { if ( a [ i ] == 2 ) suff [ i ] = suff [ i + 1 ] + 1 ; else suff [ i ] = suff [ i + 1 ] ; } long ss = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) ss += suff [ i ] ; } for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { if ( a [ i ] == 1 && a [ j ] == 1 && suff [ j ] >= 2 ) { ss += ( suff [ j ] ) * ( suff [ j ] - 1 ) / 2 ; } } } for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { if ( a [ i ] == 1 && a [ j ] == 1 && ( suff [ i ] - suff [ j ] ) >= 1 && suff [ j ] >= 1 ) { ss += ( suff [ i ] - suff [ j ] ) * suff [ j ] ; } } } System . out . println ( ss ) ; }
static String find_number ( int N , int K ) { String r ; if ( N % 100 == 0 ) { N += 1 ; r = String . valueOf ( N ) ; } else { r = String . valueOf ( N ) ; } for ( int i = 1 ; i <= K ; i ++ ) r += "00" ; return r ; }
static int distinct_year ( String str ) { String str2 = " " ; Set < String > uniqueDates = new HashSet < > ( ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( Character . isDigit ( str . charAt ( i ) ) ) { str2 += ( str . charAt ( i ) ) ; } if ( str . charAt ( i ) == ' - ' ) { str2 = " " ; } if ( str2 . length ( ) == 4 ) { uniqueDates . add ( str2 ) ; str2 = " " ; } } return uniqueDates . size ( ) ; }
static void isSubsetAndZero ( int array [ ] , int length , int N ) { int arrAnd = array [ 0 ] ; for ( int i = 1 ; i < length ; i ++ ) { arrAnd = arrAnd & array [ i ] ; } if ( ( arrAnd & N ) == 0 ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; }
static void ReplaceElements ( int arr [ ] , int n ) { int prod = 1 ; for ( int i = 0 ; i < n ; ++ i ) { prod *= arr [ i ] ; } for ( int i = 0 ; i < n ; ++ i ) { arr [ i ] = prod / arr [ i ] ; } }
static int countSubarrays ( int a [ ] , int n , int x ) { int count = 0 ; int number = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > x ) { count += 1 ; } else { number += ( count ) * ( count + 1 ) / 2 ; count = 0 ; } } if ( count != 0 ) number += ( count ) * ( count + 1 ) / 2 ; return number ; }
static int cntSquares ( int n ) { return n * ( n + 1 ) * ( 2 * n + 1 ) / 6 ; }
static void countDistinct ( int arr [ ] , int k ) { HashMap < Integer , Integer > hM = new HashMap < Integer , Integer > ( ) ; int dist_count = 0 ; for ( int i = 0 ; i < k ; i ++ ) { if ( hM . get ( arr [ i ] ) == null ) { hM . put ( arr [ i ] , 1 ) ; dist_count ++ ; } else { int count = hM . get ( arr [ i ] ) ; hM . put ( arr [ i ] , count + 1 ) ; } } System . out . println ( dist_count ) ; for ( int i = k ; i < arr . length ; i ++ ) { if ( hM . get ( arr [ i - k ] ) == 1 ) { hM . remove ( arr [ i - k ] ) ; dist_count -- ; } else { int count = hM . get ( arr [ i - k ] ) ; hM . put ( arr [ i - k ] , count - 1 ) ; } if ( hM . get ( arr [ i ] ) == null ) { hM . put ( arr [ i ] , 1 ) ; dist_count ++ ; } else { int count = hM . get ( arr [ i ] ) ; hM . put ( arr [ i ] , count + 1 ) ; } System . out . println ( dist_count ) ; } }
static int maxSubStr ( char [ ] str1 , int len1 , char [ ] str2 , int len2 ) { if ( len1 > len2 ) return 0 ; int freq1 [ ] = new int [ MAX ] ; for ( int i = 0 ; i < len1 ; i ++ ) freq1 [ i ] = 0 ; for ( int i = 0 ; i < len1 ; i ++ ) freq1 [ str1 [ i ] - ' a ' ] ++ ; int freq2 [ ] = new int [ MAX ] ; for ( int i = 0 ; i < len2 ; i ++ ) freq2 [ i ] = 0 ; for ( int i = 0 ; i < len2 ; i ++ ) freq2 [ str2 [ i ] - ' a ' ] ++ ; int minPoss = Integer . MAX_VALUE ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( freq1 [ i ] == 0 ) continue ; if ( freq1 [ i ] > freq2 [ i ] ) return 0 ; minPoss = Math . min ( minPoss , freq2 [ i ] / freq1 [ i ] ) ; } return minPoss ; }
static double findMinValue ( double arr [ ] , double n ) { double sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ( double ) Math . log10 ( arr [ i ] ) + EPS ; double xl = ( double ) ( sum / n + EPS ) ; double res = Math . pow ( ( double ) 10.0 , ( double ) xl ) + EPS ; return ( double ) Math . ceil ( res + EPS ) ; }
static int totalSumDivisibleByNum ( int n , int number ) { int firstnum = ( int ) Math . pow ( 10 , n - 1 ) ; int lastnum = ( int ) Math . pow ( 10 , n ) ; int sum = 0 ; for ( int i = firstnum ; i < lastnum ; i ++ ) if ( i % number == 0 ) sum += i ; return sum ; }
static int MinDeletion ( int a [ ] , int n ) { Map < Integer , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . containsKey ( a [ i ] ) ) { mp . put ( a [ i ] , mp . get ( a [ i ] ) + 1 ) ; } else { mp . put ( a [ i ] , 1 ) ; } } int ans = 0 ; for ( Map . Entry < Integer , Integer > i : mp . entrySet ( ) ) { int x = i . getKey ( ) ; int frequency = i . getValue ( ) ; if ( x <= frequency ) { ans += ( frequency - x ) ; } else ans += frequency ; } return ans ; }
static void sortedAdjacentDifferences ( int arr [ ] , int n ) { int [ ] ans = new int [ n ] ; Arrays . sort ( arr ) ; int l = 0 , r = n - 1 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( i % 2 == 1 ) { ans [ i ] = arr [ l ] ; l ++ ; } else { ans [ i ] = arr [ r ] ; r -- ; } } for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( ans [ i ] + " ▁ " ) ; } }
static boolean check ( int a [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] == 1 ) return true ; return false ; }
static void findRemainder ( int n ) { int l = n % 10 ; while ( n >= 10 ) n /= 10 ; int f = n ; int remainder = f % l ; System . out . println ( remainder ) ; }
public static int findNth ( int n ) { int nthElement = 19 + ( n - 1 ) * 9 ; int outliersCount = ( int ) Math . log10 ( nthElement ) - 1 ; nthElement += 9 * outliersCount ; return nthElement ; }
static void find ( int n ) { int b = n ; int a = b * ( n - 1 ) ; if ( a * b > n && a / b < n ) { System . out . print ( " a ▁ = ▁ " + a + " , ▁ b ▁ = ▁ " + b ) ; } else System . out . println ( - 1 ) ; }
static int maxAbsDiff ( int arr [ ] , int n ) { int minEle = arr [ 0 ] ; int maxEle = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { minEle = Math . min ( minEle , arr [ i ] ) ; maxEle = Math . max ( maxEle , arr [ i ] ) ; } return ( maxEle - minEle ) ; }
static boolean canBecomeEmpty ( String str , String sub_str ) { while ( str . length ( ) > 0 ) { int idx = str . indexOf ( sub_str ) ; if ( idx == - 1 ) { break ; } str = str . replaceFirst ( sub_str , " " ) ; } return ( str . length ( ) == 0 ) ; }
static void printNumberWithDR ( int k , int d ) { if ( d == 0 && k != 1 ) System . out . print ( " - 1" ) ; else { System . out . print ( d ) ; k -- ; while ( k -- > 0 ) System . out . print ( "0" ) ; } }
static boolean areSetBitsIncreasing ( int n ) { int prev_count = Integer . MAX_VALUE ; while ( n > 0 ) { while ( n > 0 && n % 2 == 0 ) n = n / 2 ; int curr_count = 1 ; while ( n > 0 && n % 2 == 1 ) { n = n / 2 ; curr_count ++ ; } if ( curr_count >= prev_count ) return false ; prev_count = curr_count ; } return true ; }
static int maximumSumSubarray ( int arr [ ] , int n ) { int min_prefix_sum = 0 ; int res = Integer . MIN_VALUE ; int prefix_sum [ ] = new int [ n ] ; prefix_sum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) prefix_sum [ i ] = prefix_sum [ i - 1 ] + arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { res = Math . max ( res , prefix_sum [ i ] - min_prefix_sum ) ; min_prefix_sum = Math . min ( min_prefix_sum , prefix_sum [ i ] ) ; } return res ; }
static boolean ifPossible ( int arr [ ] , int n ) { int copy [ ] = Arrays . copyOf ( arr , arr . length ) ; Arrays . sort ( copy ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! ( arr [ i ] == copy [ i ] ) && ! ( arr [ n - 1 - i ] == copy [ i ] ) ) return false ; } return true ; }
static int inversegrayCode ( int n ) { int inv = 0 ; for ( ; n != 0 ; n = n >> 1 ) inv ^= n ; return inv ; }
static float squareRoot ( int number , int precision ) { int start = 0 , end = number ; int mid ; double ans = 0.0 ; while ( start <= end ) { mid = ( start + end ) / 2 ; if ( mid * mid == number ) { ans = mid ; break ; } if ( mid * mid < number ) { start = mid + 1 ; ans = mid ; } else { end = mid - 1 ; } } double increment = 0.1 ; for ( int i = 0 ; i < precision ; i ++ ) { while ( ans * ans <= number ) { ans += increment ; } ans = ans - increment ; increment = increment / 10 ; } return ( float ) ans ; }
static int dayofweek ( int d , int m , int y ) { int t [ ] = { 0 , 3 , 2 , 5 , 0 , 3 , 5 , 1 , 4 , 6 , 2 , 4 } ; y -= ( m < 3 ) ? 1 : 0 ; return ( y + y / 4 - y / 100 + y / 400 + t [ m - 1 ] + d ) % 7 ; }
public static int countZeroso ( int [ ] a , int n ) { int count2 = 0 , count5 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( a [ i ] % 2 == 0 ) { a [ i ] = a [ i ] / 2 ; count2 ++ ; } while ( a [ i ] % 5 == 0 ) { a [ i ] = a [ i ] / 5 ; count5 ++ ; } } return ( count2 < count5 ) ? count2 : count5 ; }
static int minimizeDiff ( int [ ] arr , int n , int k ) { int max = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; int min = Arrays . stream ( arr ) . min ( ) . getAsInt ( ) ; if ( ( max - min ) <= k ) { return ( max - min ) ; } int avg = ( max + min ) / 2 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > avg ) { arr [ i ] -= k ; } else { arr [ i ] += k ; } } max = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; min = Arrays . stream ( arr ) . min ( ) . getAsInt ( ) ; return ( max - min ) ; }
static float findWater ( int i , int j , float X ) { if ( j > i ) { System . out . println ( " Incorrect ▁ Input " ) ; System . exit ( 0 ) ; } int ll = Math . round ( ( i * ( i + 1 ) ) ) ; float [ ] glass = new float [ ll + 2 ] ; int index = 0 ; glass [ index ] = X ; for ( int row = 1 ; row <= i ; ++ row ) { for ( int col = 1 ; col <= row ; ++ col , ++ index ) { X = glass [ index ] ; glass [ index ] = ( X >= 1.0f ) ? 1.0f : X ; X = ( X >= 1.0f ) ? ( X - 1 ) : 0.0f ; glass [ index + row ] += X / 2 ; glass [ index + row + 1 ] += X / 2 ; } } return glass [ ( int ) ( i * ( i - 1 ) / 2 + j - 1 ) ] ; }
static int findLen ( int [ ] arr , int i , int curr , int n , int m ) { if ( i == n ) { if ( curr == m ) return 0 ; else return - 1 ; } if ( v [ i ] [ curr ] ) return dp [ i ] [ curr ] ; v [ i ] [ curr ] = true ; int l = findLen ( arr , i + 1 , curr , n , m ) ; int r = findLen ( arr , i + 1 , curr | arr [ i ] , n , m ) ; dp [ i ] [ curr ] = l ; if ( r != - 1 ) dp [ i ] [ curr ] = Math . max ( dp [ i ] [ curr ] , r + 1 ) ; return dp [ i ] [ curr ] ; }
static int count_pairs ( String s1 [ ] , String s2 [ ] , int n1 , int n2 ) { HashMap < String , Integer > mp = new HashMap < String , Integer > ( ) ; for ( int i = 0 ; i < n1 ; i ++ ) mp . put ( s1 [ i ] , 0 ) ; for ( int i = 0 ; i < n1 ; i ++ ) mp . put ( s1 [ i ] , mp . get ( s1 [ i ] ) + 1 ) ; int cnt = 0 ; for ( int i = 0 ; i < n2 ; i ++ ) { if ( mp . get ( s2 [ i ] ) > 0 ) { cnt ++ ; mp . put ( s2 [ i ] , mp . get ( s2 [ i ] ) - 1 ) ; } } return cnt ; }
static int maxPrimefactorNum ( int N ) { if ( N < 2 ) return 0 ; boolean [ ] arr = new boolean [ N + 1 ] ; int prod = 1 , res = 0 ; for ( int p = 2 ; p * p <= N ; p ++ ) { if ( arr [ p ] == false ) { for ( int i = p * 2 ; i <= N ; i += p ) arr [ i ] = true ; prod *= p ; if ( prod > N ) return res ; res ++ ; } } return res ; }
static void findAndPrintUncommonChars ( String str1 , String str2 ) { int present [ ] = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { present [ i ] = 0 ; } int l1 = str1 . length ( ) ; int l2 = str2 . length ( ) ; for ( int i = 0 ; i < l1 ; i ++ ) { present [ str1 . charAt ( i ) - ' a ' ] = 1 ; } for ( int i = 0 ; i < l2 ; i ++ ) { if ( present [ str2 . charAt ( i ) - ' a ' ] == 1 || present [ str2 . charAt ( i ) - ' a ' ] == - 1 ) { present [ str2 . charAt ( i ) - ' a ' ] = - 1 ; } else { present [ str2 . charAt ( i ) - ' a ' ] = 2 ; } } for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { if ( present [ i ] == 1 || present [ i ] == 2 ) { System . out . print ( ( char ) ( i + ' a ' ) + " ▁ " ) ; } } }
static int xorEqualsOrCount ( int N ) { int count = 0 ; int bit ; while ( N > 0 ) { bit = N % 2 ; if ( bit == 0 ) count ++ ; N = N / 2 ; } return ( int ) Math . pow ( 2 , count ) ; }
static void minRange ( int arr [ ] , int n , int k ) { int l = 0 , r = n ; for ( int i = 0 ; i < n ; i ++ ) { Set < Integer > s = new HashSet < Integer > ( ) ; int j ; for ( j = i ; j < n ; j ++ ) { s . add ( arr [ j ] ) ; if ( s . size ( ) == k ) { if ( ( j - i ) < ( r - l ) ) { r = j ; l = i ; } break ; } } if ( j == n ) break ; } if ( l == 0 && r == n ) System . out . println ( " Invalid ▁ k " ) ; else System . out . println ( l + " ▁ " + r ) ; }
static void pattern ( int nos , int i , int space ) { char prt = ' $ ' ; int s , j ; for ( s = nos ; s >= 1 ; s -- ) { System . out . print ( " ▁ ▁ " ) ; } for ( j = 1 ; j <= i ; j ++ ) { if ( space != 0 ) { if ( i == 9 && j == 1 ) { continue ; } } if ( i == 1 || i == 9 ) { System . out . print ( prt + " " ) ; } else if ( j == 1 || j == i ) { System . out . print ( prt + " " ) ; } else { System . out . print ( " ▁ ▁ " ) ; } } }
static void solve ( int A , int B ) { int count = 0 ; for ( int i = 0 ; i < 32 ; i ++ ) { if ( ( ( A >> i ) & 1 ) != ( ( B >> i ) & 1 ) ) { count ++ ; } } System . out . println ( " Number ▁ of ▁ different ▁ bits ▁ : ▁ " + count ) ; }
static void findSubArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( Math . abs ( arr [ i ] - arr [ i + 1 ] ) >= 2 ) { System . out . print ( arr [ i ] + " ▁ " + arr [ i + 1 ] ) ; return ; } } System . out . print ( - 1 ) ; }
static void pattern ( int n ) { int i , j ; for ( i = 1 ; i <= n ; i ++ ) { for ( j = 1 ; j <= ( 2 * n ) ; j ++ ) { if ( i > ( n - j + 1 ) ) System . out . print ( " ▁ " ) ; else System . out . print ( " * " ) ; if ( ( i + n ) > j ) System . out . print ( " ▁ " ) ; else System . out . print ( " * " ) ; } System . out . println ( " " ) ; } for ( i = 1 ; i <= n ; i ++ ) { for ( j = 1 ; j <= ( 2 * n ) ; j ++ ) { if ( i < j ) System . out . print ( " ▁ " ) ; else System . out . print ( " * " ) ; if ( i <= ( ( 2 * n ) - j ) ) System . out . print ( " ▁ " ) ; else System . out . print ( " * " ) ; } System . out . println ( " " ) ; } }
static void encode ( String s , int k ) { String newS = " " ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) { int val = s . charAt ( i ) ; int dup = k ; if ( val + k > 122 ) { k -= ( 122 - val ) ; k = k % 26 ; newS += ( char ) ( 96 + k ) ; } else { newS += ( char ) ( val + k ) ; } k = dup ; } System . out . println ( newS ) ; }
static void pushZerosToEnd ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != 0 ) arr [ count ++ ] = arr [ i ] ; while ( count < n ) arr [ count ++ ] = 0 ; }
static int properDivisorSum ( int n ) { int sum = 0 ; int i ; for ( i = 1 ; i <= n ; ++ i ) sum += ( n / i ) * i ; return sum - n * ( n + 1 ) / 2 ; }
public static void FindAllElements ( int n , int k ) { int sum = k ; int [ ] A = new int [ k ] ; Arrays . fill ( A , 0 , k , 1 ) ; for ( int i = k - 1 ; i >= 0 ; -- i ) { while ( sum + A [ i ] <= n ) { sum += A [ i ] ; A [ i ] *= 2 ; } } if ( sum != n ) { System . out . print ( " Impossible " ) ; } else { for ( int i = 0 ; i < k ; ++ i ) System . out . print ( A [ i ] + " ▁ " ) ; } }
static int pairCount ( int arr [ ] , int n ) { int max_val = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; Vector < Boolean > prime = new Vector < > ( max_val + 1 ) ; for ( int i = 0 ; i < max_val + 1 ; i ++ ) { prime . add ( true ) ; } prime . add ( 0 , Boolean . FALSE ) ; prime . add ( 1 , Boolean . FALSE ) ; for ( int p = 2 ; p * p <= max_val ; p ++ ) { if ( prime . get ( p ) == true ) { for ( int i = p * 2 ; i <= max_val ; i += p ) { prime . add ( i , Boolean . FALSE ) ; } } } int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime . get ( arr [ i ] ) ) { count ++ ; } } return ( count * ( count - 1 ) ) / 2 ; }
public static void pattern ( int n ) { for ( int i = 1 ; i <= n * 2 ; i ++ ) System . out . print ( " ▁ " ) ; System . out . print ( 0 + " \n " ) ; for ( int i = 1 ; i <= ( n * 2 ) - 1 ; i ++ ) { if ( i < n ) { for ( int j = 1 ; j <= ( n - i ) * 2 ; j ++ ) System . out . print ( " ▁ " ) ; } else { for ( int j = 1 ; j <= ( i % n ) * 2 ; j ++ ) System . out . print ( " ▁ " ) ; } if ( i < n ) { for ( int j = 0 ; j <= i % n ; j ++ ) System . out . print ( j + " ▁ " ) ; for ( int j = ( i % n ) - 1 ; j > 0 ; j -- ) System . out . print ( j + " ▁ " ) ; System . out . print ( 0 ) ; } else if ( i > n ) { for ( int j = 0 ; j <= n - ( i - n ) ; j ++ ) System . out . print ( j + " ▁ " ) ; for ( int j = ( n - ( i - n ) ) - 1 ; j > 0 ; j -- ) System . out . print ( j + " ▁ " ) ; System . out . print ( 0 ) ; } else { for ( int j = 0 ; j <= n ; j ++ ) System . out . print ( j + " ▁ " ) ; for ( int j = n - 1 ; j > 0 ; j -- ) System . out . print ( j + " ▁ " ) ; System . out . print ( 0 ) ; } System . out . print ( " \n " ) ; } for ( int i = 1 ; i <= n * 2 ; i ++ ) System . out . print ( " ▁ " ) ; System . out . print ( 0 ) ; }
static int countManipulations ( String s1 , String s2 ) { int count = 0 ; int char_count [ ] = new int [ 26 ] ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) char_count [ s1 . charAt ( i ) - ' a ' ] ++ ; for ( int i = 0 ; i < s2 . length ( ) ; i ++ ) if ( char_count [ s2 . charAt ( i ) - ' a ' ] -- <= 0 ) count ++ ; return count ; }
static boolean lineExists ( int x [ ] , int y [ ] , int v [ ] , int n ) { int size = ( 2 * MAX ) + 1 ; long [ ] arr = new long [ size ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ x [ i ] + MAX ] += v [ i ] ; } for ( int i = 1 ; i < size ; i ++ ) arr [ i ] += arr [ i - 1 ] ; if ( arr [ size - 1 ] == 0 ) return true ; if ( arr [ size - 1 ] - arr [ 0 ] == 0 ) return true ; for ( int i = 1 ; i < size - 1 ; i ++ ) { if ( arr [ i - 1 ] == arr [ size - 1 ] - arr [ i - 1 ] ) return true ; if ( arr [ i - 1 ] == arr [ size - 1 ] - arr [ i ] ) return true ; if ( arr [ i ] == arr [ size - 1 ] - arr [ i ] ) return true ; } if ( arr [ size - 2 ] == 0 ) return true ; return false ; }
static int countZeros ( int x ) { int total_bits = sizeofInt * 8 ; int res = 0 ; while ( ( x & ( 1 << ( total_bits - 1 ) ) ) == 0 ) { x = ( x << 1 ) ; res ++ ; } return res ; }
static boolean isPresent ( String s , String q ) { int [ ] freq = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) freq [ s . charAt ( i ) ] ++ ; for ( int i = 0 ; i < q . length ( ) ; i ++ ) { freq [ q . charAt ( i ) ] -- ; if ( freq [ q . charAt ( i ) ] < 0 ) return false ; } return true ; }
public static void print ( char a [ ] , int n , int ind ) { char [ ] b = new char [ ( 2 * n ) ] ; for ( int i = 0 ; i < n ; i ++ ) b [ i ] = b [ n + i ] = a [ i ] ; for ( int i = ind ; i < n + ind ; i ++ ) System . out . print ( b [ i ] + " ▁ " ) ; }
static int countNonEmptySubstr ( String str ) { int n = str . length ( ) ; return n * ( n + 1 ) / 2 ; }
static int countIndices ( int arr [ ] , int n ) { int cnt = 0 ; int max = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( max < arr [ i ] ) { max = arr [ i ] ; cnt ++ ; } } return cnt ; }
static void findTriplets ( int x ) { Vector < Integer > fact = new Vector < Integer > ( ) ; HashSet < Integer > factors = new HashSet < Integer > ( ) ; for ( int i = 2 ; i <= Math . sqrt ( x ) ; i ++ ) { if ( x % i == 0 ) { fact . add ( i ) ; if ( x / i != i ) fact . add ( x / i ) ; factors . add ( i ) ; factors . add ( x / i ) ; } } boolean found = false ; int k = fact . size ( ) ; for ( int i = 0 ; i < k ; i ++ ) { int a = fact . get ( i ) ; for ( int j = 0 ; j < k ; j ++ ) { int b = fact . get ( j ) ; if ( ( a != b ) && ( x % ( a * b ) == 0 ) && ( x / ( a * b ) != a ) && ( x / ( a * b ) != b ) && ( x / ( a * b ) != 1 ) ) { System . out . print ( a + " ▁ " + b + " ▁ " + ( x / ( a * b ) ) ) ; found = true ; break ; } } if ( found ) break ; } if ( ! found ) System . out . print ( " - 1" ) ; }
static Vector < Integer > processQueries ( int Q [ ] , int m , int n ) { int [ ] a = new int [ m + 1 ] ; int [ ] pos = new int [ m + 1 ] ; for ( int i = 1 ; i <= m ; i ++ ) { a [ i - 1 ] = i ; pos [ i ] = i - 1 ; } Vector < Integer > ans = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int q = Q [ i ] ; int p = pos [ q ] ; ans . add ( p ) ; for ( int j = p ; j > 0 ; j -- ) { a [ j ] = a [ j ] + a [ j - 1 ] ; a [ j - 1 ] = a [ j ] - a [ j - 1 ] ; a [ j ] = a [ j ] - a [ j - 1 ] ; pos [ a [ j ] ] = j ; } pos [ a [ 0 ] ] = 0 ; } return ans ; }
static void solve ( char [ ] a , char [ ] b ) { int l = a . length ; int min = 0 , max = 0 ; for ( int i = 0 ; i < l ; i ++ ) { if ( a [ i ] == ' + ' || b [ i ] == ' + ' || a [ i ] != b [ i ] ) max ++ ; if ( a [ i ] != ' + ' && b [ i ] != ' + ' && a [ i ] != b [ i ] ) min ++ ; } System . out . print ( min + max + " \n " ) ; }
static void checksum ( int n ) { if ( n == 0 ) { System . out . println ( " - 1 ▁ 0 ▁ 1" ) ; return ; } int inc ; if ( n > 0 ) inc = 1 ; else inc = - 1 ; for ( int i = 0 ; i <= n - 2 ; i += inc ) { if ( i + i + 1 + i + 2 == n ) { System . out . println ( i + " ▁ " + ( i + 1 ) + " ▁ " + ( i + 2 ) ) ; return ; } } System . out . println ( " - 1" ) ; }
static int calculateLeaps ( int n ) { if ( n == 0 ) return 1 ; return ( 1 << ( n - 1 ) ) ; }
static boolean isDivisible7 ( String num ) { int n = num . length ( ) ; if ( n == 0 && num . charAt ( 0 ) == '0' ) return true ; if ( n % 3 == 1 ) num = "00" + num ; if ( n % 3 == 2 ) num = "0" + num ; n = num . length ( ) ; int gSum = 0 , p = 1 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { int group = 0 ; group += num . charAt ( i -- ) - '0' ; group += ( num . charAt ( i -- ) - '0' ) * 10 ; group += ( num . charAt ( i ) - '0' ) * 100 ; gSum = gSum + group * p ; p = p * - 1 ; } return ( gSum % 7 == 0 ) ; }
static void getXandYintercept ( int P [ ] , int Q [ ] ) { int a = P [ 1 ] - Q [ 1 ] ; int b = P [ 0 ] - Q [ 0 ] ; if ( b == 0 ) { System . out . println ( P [ 0 ] ) ; System . out . println ( " infinity " ) ; return ; } if ( a == 0 ) { System . out . println ( " infinity " ) ; System . out . println ( P [ 1 ] ) ; return ; } double m = a / ( b * 1.0 ) ; int x = P [ 0 ] ; int y = P [ 1 ] ; double c = y - m * x ; y = 0 ; double r = ( y - c ) / ( m * 1.0 ) ; System . out . println ( r ) ; x = 0 ; y = ( int ) ( m * x + c ) ; System . out . print ( c ) ; }
public static int getMaxLength ( int arr [ ] ) { int l = arr . length ; int i = 0 , maxlen = 0 ; while ( i < l ) { int j = i ; while ( i + 1 < l && ( Math . abs ( arr [ i ] - arr [ i + 1 ] ) == 1 || Math . abs ( arr [ i ] - arr [ i + 1 ] ) == 0 ) ) { i ++ ; } int currLen = i - j + 1 ; if ( maxlen < currLen ) maxlen = currLen ; if ( j == i ) i ++ ; } maxlen = ( maxlen == 1 ) ? 0 : maxlen ; return maxlen ; }
static int countPairs ( String str ) { int result = 0 ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 1 ; ( i + j ) < n && j <= MAX_CHAR ; j ++ ) if ( ( Math . abs ( str . charAt ( i + j ) - str . charAt ( i ) ) == j ) ) result ++ ; return result ; }
static float area ( float a ) { if ( a < 0 ) return - 1 ; float area = ( float ) Math . sqrt ( a ) / 6 ; return area ; }
static int minOperations ( int n , int m ) { int a = 0 , k = 1 ; int p = Math . max ( n , m ) ; while ( n != m ) { float s = ( float ) ( p - n + p - m ) ; float q = ( float ) ( ( - 1 + Math . sqrt ( 8 * s + 1 ) ) / 2 ) ; if ( q - Math . floor ( q ) == 0 ) { a = ( int ) q ; n = m ; } p = p + 1 ; } return a ; }
static int surfaceArea ( int b , int s ) { return 2 * b * s + ( int ) Math . pow ( b , 2 ) ; }
static void solve ( int d1 , int d2 , int d3 ) { int maxx = Math . max ( d1 , Math . max ( d2 , d3 ) ) ; int sum = ( d1 + d2 + d3 ) ; if ( 2 * maxx > sum || sum % 2 == 1 ) { System . out . print ( " - 1" ) ; return ; } int x1 = 0 , y1 = 0 ; int x2 = d1 , y2 = 0 ; int x3 = ( d1 + d2 - d3 ) / 2 ; int y3 = ( d2 + d3 - d1 ) / 2 ; System . out . print ( " ( " + x1 + " , ▁ " + y1 + " ) , ▁ ( " + x2 + " , ▁ " + y2 + " ) ▁ and ▁ ( " + x3 + " , ▁ " + y3 + " ) " ) ; }
static int maxSumArrangement ( int A [ ] , int R [ ] [ ] , int N , int M ) { int count [ ] = new int [ N ] ; int i ; for ( i = 0 ; i < M ; ++ i ) { int l = R [ i ] [ 0 ] , r = R [ i ] [ 1 ] + 1 ; l -- ; r -- ; count [ l ] ++ ; if ( r < N ) count [ r ] -- ; } for ( i = 1 ; i < N ; ++ i ) { count [ i ] += count [ i - 1 ] ; } int ans = 0 ; Arrays . sort ( count ) ; Arrays . sort ( A ) ; for ( i = N - 1 ; i >= 0 ; -- i ) { ans += A [ i ] * count [ i ] ; } return ans ; }
static String getMinNumberForPattern ( String seq ) { int n = seq . length ( ) ; if ( n >= 9 ) return " - 1" ; char result [ ] = new char [ n + 1 ] ; int count = 1 ; for ( int i = 0 ; i <= n ; i ++ ) { if ( i == n || seq . charAt ( i ) == ' I ' ) { for ( int j = i - 1 ; j >= - 1 ; j -- ) { result [ j + 1 ] = ( char ) ( ( int ) '0' + count ++ ) ; if ( j >= 0 && seq . charAt ( j ) == ' I ' ) break ; } } } return new String ( result ) ; }
static boolean checkConcurrent ( int a1 , int b1 , int c1 , int a2 , int b2 , int c2 , int a3 , int b3 , int c3 ) { return ( a3 * ( b1 * c2 - b2 * c1 ) + b3 * ( c1 * a2 - c2 * a1 ) + c3 * ( a1 * b2 - a2 * b1 ) == 0 ) ; }
static void compressString ( String s , int n ) { int freq [ ] = new int [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) { freq [ s . charAt ( i ) - ' a ' ] ++ ; } for ( int i = 0 ; i < MAX ; i ++ ) { if ( freq [ i ] == 0 ) continue ; System . out . print ( ( char ) ( i + ' a ' ) + " " + freq [ i ] ) ; } }
static int cntWays ( int arr [ ] , int n ) { if ( n == 1 ) { return 0 ; } int tot_sum = 0 , sum = 0 , ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { tot_sum += arr [ i ] ; } for ( int i = 0 ; i < n - 1 ; i ++ ) { sum += arr [ i ] ; if ( sum == tot_sum / 2 ) { ans ++ ; } } return ans ; }
static boolean isPower ( int x , int y ) { int res1 = ( int ) Math . log ( y ) / ( int ) Math . log ( x ) ; double res2 = Math . log ( y ) / Math . log ( x ) ; return ( res1 == res2 ) ; }
static int sum ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } sum = sum * ( int ) Math . pow ( 2 , n - 1 ) ; return sum ; }
static int traverseMatrix ( int arr [ ] [ ] , int current_row , int current_col ) { if ( current_col >= M ) return 0 ; if ( current_row >= N ) return 1 ; System . out . print ( arr [ current_row ] [ current_col ] + " , ▁ " ) ; if ( traverseMatrix ( arr , current_row , current_col + 1 ) == 1 ) return 1 ; return traverseMatrix ( arr , current_row + 1 , 0 ) ; }
public static int counLastDigitK ( int low , int high , int k ) { int count = ( high - low ) / 10 ; if ( high % 10 >= k ) count ++ ; if ( low % 10 > k ) count -- ; return count ; }
