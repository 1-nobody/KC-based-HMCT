def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT
def doublefactorial ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT return n * doublefactorial ( n - 2 ) ; NEW_LINE DEDENT
def countSquares ( row , column ) : NEW_LINE INDENT topLeft = min ( row , column ) - 1 NEW_LINE bottomRight = 8 - max ( row , column ) NEW_LINE topRight = min ( row , 9 - column ) - 1 NEW_LINE bottomLeft = 8 - max ( row , 9 - column ) NEW_LINE return ( topLeft + topRight + bottomRight + bottomLeft ) NEW_LINE DEDENT
def perfectSquare ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE ans = - 1 NEW_LINE num = " " NEW_LINE for i in range ( 1 , ( 1 << n ) ) : NEW_LINE INDENT str = " " NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if ( ( i >> j ) & 1 ) : NEW_LINE INDENT str = str + s [ j ] NEW_LINE DEDENT DEDENT if ( str [ 0 ] != '0' ) : NEW_LINE INDENT temp = 0 ; NEW_LINE for j in range ( 0 , len ( str ) ) : NEW_LINE INDENT temp = ( temp * 10 + ( ord ( str [ j ] ) - ord ( '0' ) ) ) NEW_LINE DEDENT k = int ( math . sqrt ( temp ) ) NEW_LINE if ( k * k == temp ) : NEW_LINE INDENT if ( ans < len ( str ) ) : NEW_LINE INDENT ans = len ( str ) NEW_LINE num = str NEW_LINE DEDENT DEDENT DEDENT DEDENT if ( ans == - 1 ) : NEW_LINE INDENT return ans NEW_LINE DEDENT else : NEW_LINE INDENT print ( " { } ▁ " . format ( num ) , end = " " ) NEW_LINE return n - ans NEW_LINE DEDENT DEDENT
def eggDrop ( n , k ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( k + 1 ) ] NEW_LINE x = 0 ; NEW_LINE while ( dp [ x ] [ n ] < k ) : NEW_LINE INDENT x += 1 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ x ] [ i ] = dp [ x - 1 ] [ i - 1 ] +   \ NEW_LINE INDENT dp [ x - 1 ] [ i ] + 1 ; NEW_LINE DEDENT DEDENT DEDENT return x ; NEW_LINE DEDENT
def binarySearchCount ( arr , n , key ) : NEW_LINE INDENT left = 0 NEW_LINE right = n NEW_LINE mid = 0 NEW_LINE while ( left < right ) : NEW_LINE INDENT mid = ( right + left ) // 2 NEW_LINE if ( arr [ mid ] == key ) : NEW_LINE INDENT while ( mid + 1 < n and arr [ mid + 1 ] == key ) : NEW_LINE INDENT mid += 1 NEW_LINE DEDENT break NEW_LINE DEDENT elif ( arr [ mid ] > key ) : NEW_LINE INDENT right = mid NEW_LINE DEDENT else : NEW_LINE INDENT left = mid + 1 NEW_LINE DEDENT DEDENT while ( mid > - 1 and arr [ mid ] > key ) : NEW_LINE INDENT mid -= 1 NEW_LINE DEDENT return mid + 1 NEW_LINE DEDENT
def getClosest ( a , b , x ) : NEW_LINE INDENT num = pow ( a , b ) NEW_LINE floor = num // x NEW_LINE numOnLeft = x * floor NEW_LINE numOnRight = x * ( floor + 1 ) NEW_LINE if ( ( num - numOnLeft ) < ( numOnRight - num ) ) : NEW_LINE INDENT return numOnLeft NEW_LINE DEDENT else : NEW_LINE INDENT return numOnRight NEW_LINE DEDENT DEDENT
def findSum ( N ) : NEW_LINE INDENT return ( ( N * ( N + 1 ) * ( 2 * N - 5 ) + 4 * N ) / 2 ) NEW_LINE DEDENT
def Loss ( SP , P ) : NEW_LINE INDENT loss = 0 NEW_LINE loss = ( ( 2 * P * P * SP ) / ( 100 * 100 - P * P ) ) NEW_LINE print ( " Loss ▁ = " , round ( loss , 3 ) ) NEW_LINE DEDENT
def maxCount ( a ) : NEW_LINE INDENT freq = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] in freq ) : NEW_LINE INDENT freq [ a [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT freq [ a [ i ] ] = 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for key , value in freq . items ( ) : NEW_LINE INDENT if ( key + 1 in freq ) : NEW_LINE INDENT ans = max ( ans , freq [ key ] + freq [ key + 1 ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def getMaxLength ( arr , n ) : NEW_LINE INDENT start = 0 NEW_LINE preCnt = 0 NEW_LINE while ( start < n and arr [ start ] == 1 ) : NEW_LINE INDENT preCnt = preCnt + 1 NEW_LINE start = start + 1 NEW_LINE DEDENT end = n - 1 NEW_LINE suffCnt = 0 NEW_LINE while ( end >= 0 and arr [ end ] == 1 ) : NEW_LINE INDENT suffCnt = suffCnt + 1 NEW_LINE end = end - 1 NEW_LINE DEDENT if ( start > end ) : NEW_LINE INDENT return n NEW_LINE DEDENT midCnt = 0 NEW_LINE i = start NEW_LINE result = 0 NEW_LINE while ( i <= end ) : NEW_LINE INDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT midCnt = midCnt + 1 NEW_LINE result = max ( result , midCnt ) NEW_LINE DEDENT else : NEW_LINE INDENT midCnt = 0 NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT return max ( result , preCnt + suffCnt ) NEW_LINE DEDENT
def printWords ( h , m ) : NEW_LINE INDENT nums = [ " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " , " ten " , " eleven " , " twelve " , " thirteen " , " fourteen " , " fifteen " , " sixteen " , " seventeen " , " eighteen " , " nineteen " , " twenty " , " twenty ▁ one " , " twenty ▁ two " , " twenty ▁ three " , " twenty ▁ four " , " twenty ▁ five " , " twenty ▁ six " , " twenty ▁ seven " , " twenty ▁ eight " , " twenty ▁ nine " ] ; NEW_LINE if ( m == 0 ) : NEW_LINE INDENT print ( nums [ h ] , " o ' ▁ clock " ) ; NEW_LINE DEDENT elif ( m == 1 ) : NEW_LINE INDENT print ( " one ▁ minute ▁ past " , nums [ h ] ) ; NEW_LINE DEDENT elif ( m == 59 ) : NEW_LINE INDENT print ( " one ▁ minute ▁ to " , nums [ ( h % 12 ) + 1 ] ) ; NEW_LINE DEDENT elif ( m == 15 ) : NEW_LINE INDENT print ( " quarter ▁ past " , nums [ h ] ) ; NEW_LINE DEDENT elif ( m == 30 ) : NEW_LINE INDENT print ( " half ▁ past " , nums [ h ] ) ; NEW_LINE DEDENT elif ( m == 45 ) : NEW_LINE INDENT print ( " quarter ▁ to " , ( nums [ ( h % 12 ) + 1 ] ) ) ; NEW_LINE DEDENT elif ( m <= 30 ) : NEW_LINE INDENT print ( nums [ m ] , " minutes ▁ past " , nums [ h ] ) ; NEW_LINE DEDENT elif ( m > 30 ) : NEW_LINE INDENT print ( nums [ 60 - m ] , " minutes ▁ to " , nums [ ( h % 12 ) + 1 ] ) ; NEW_LINE DEDENT DEDENT
def printMaxValPair ( v , n ) : NEW_LINE INDENT v . sort ( ) NEW_LINE N = v [ n - 1 ] NEW_LINE if N % 2 == 1 : NEW_LINE INDENT first_maxima = N // 2 NEW_LINE second_maxima = first_maxima + 1 NEW_LINE ans1 , ans2 = 3 * ( 10 ** 18 ) , 3 * ( 10 ** 18 ) NEW_LINE from_left , from_right = - 1 , - 1 NEW_LINE _from = - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if v [ i ] > first_maxima : NEW_LINE INDENT _from = i NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT diff = first_maxima - v [ i ] NEW_LINE if diff < ans1 : NEW_LINE INDENT ans1 = diff NEW_LINE from_left = v [ i ] NEW_LINE DEDENT DEDENT DEDENT from_right = v [ _from ] NEW_LINE diff1 = first_maxima - from_left NEW_LINE diff2 = from_right - second_maxima NEW_LINE if diff1 < diff2 : NEW_LINE INDENT print ( N , from_left ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( N , from_right ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT maxima = N // 2 NEW_LINE ans1 = 3 * ( 10 ** 18 ) NEW_LINE R = - 1 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT diff = abs ( v [ i ] - maxima ) NEW_LINE if diff < ans1 : NEW_LINE INDENT ans1 = diff NEW_LINE R = v [ i ] NEW_LINE DEDENT DEDENT print ( N , R ) NEW_LINE DEDENT DEDENT
def findProduct ( arr , n ) : NEW_LINE INDENT prod = 1 NEW_LINE s = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] not in s . keys ( ) ) : NEW_LINE INDENT prod *= arr [ i ] NEW_LINE s [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT return prod NEW_LINE DEDENT
def maxSum ( p0 , p1 , a , pos , n ) : NEW_LINE INDENT if ( pos == n ) : NEW_LINE INDENT if ( p0 == p1 ) : NEW_LINE INDENT return p0 ; NEW_LINE DEDENT else : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT ans = maxSum ( p0 , p1 , a , pos + 1 , n ) ; NEW_LINE ans = max ( ans , maxSum ( p0 + a [ pos ] , p1 , a , pos + 1 , n ) ) ; NEW_LINE ans = max ( ans , maxSum ( p0 , p1 + a [ pos ] , a , pos + 1 , n ) ) ; NEW_LINE return ans ; NEW_LINE DEDENT
def decideWinner ( a , n ) : NEW_LINE INDENT count0 = 0 NEW_LINE count1 = 0 NEW_LINE count2 = 0 NEW_LINE count3 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] % 4 == 0 ) : NEW_LINE INDENT count0 += 1 NEW_LINE DEDENT elif ( a [ i ] % 4 == 1 ) : NEW_LINE INDENT count1 += 1 NEW_LINE DEDENT elif ( a [ i ] % 4 == 2 ) : NEW_LINE INDENT count2 += 1 NEW_LINE DEDENT elif ( a [ i ] % 4 == 3 ) : NEW_LINE INDENT count3 += 1 NEW_LINE DEDENT DEDENT if ( count0 % 2 == 0 and count1 % 2 == 0 and count2 % 2 == 0 and count3 == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 2 NEW_LINE DEDENT DEDENT
def sumPairs ( arr , n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = sum + ( arr [ i ] * ( 2 * n ) ) ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT
def getMinVal ( p , q ) : NEW_LINE INDENT if q % p == 0 : NEW_LINE INDENT return p NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def find_Area ( a ) : NEW_LINE INDENT R = a * ( 2.0 - sqrt ( 2 ) ) ; NEW_LINE area = 3.14 * R * R / 2.0 ; NEW_LINE return area ; NEW_LINE DEDENT
def getSum ( arr , n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE hashSet = set ( ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT hashSet . add ( arr [ i ] ) ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT sqrtCurrent = math . sqrt ( arr [ i ] ) ; NEW_LINE if ( math . floor ( sqrtCurrent ) != math . ceil ( sqrtCurrent ) ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT if ( int ( sqrtCurrent ) in hashSet ) : NEW_LINE INDENT sum += int ( sqrtCurrent * sqrtCurrent ) ; NEW_LINE DEDENT DEDENT return sum ; NEW_LINE DEDENT
def maxSum ( arr , n ) : NEW_LINE INDENT res = - sys . maxsize NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT curr_sum = 0 NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT index = int ( ( i + j ) % n ) NEW_LINE curr_sum += j * arr [ index ] NEW_LINE DEDENT res = max ( res , curr_sum ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def findSubSeq ( arr , n ) : NEW_LINE INDENT arr . sort ( ) ; NEW_LINE count = [ 1 ] * n ; NEW_LINE prev = [ - 1 ] * n ; NEW_LINE max = 0 ; NEW_LINE maxprev = - 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] % arr [ j ] == 0 and count [ j ] + 1 > count [ i ] ) : NEW_LINE INDENT count [ i ] = count [ j ] + 1 ; NEW_LINE prev [ i ] = j ; NEW_LINE DEDENT DEDENT if ( max < count [ i ] ) : NEW_LINE INDENT max = count [ i ] ; NEW_LINE maxprev = i ; NEW_LINE DEDENT DEDENT i = maxprev ; NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT if ( arr [ i ] != - 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT i = prev [ i ] ; NEW_LINE DEDENT DEDENT
def minCost ( graph , n ) : NEW_LINE INDENT cost1 , cost2 = 0 , 0 ; NEW_LINE start = [ False ] * ( n + 1 ) ; NEW_LINE end = [ False ] * ( n + 1 ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT a = graph [ i ] [ 0 ] ; NEW_LINE b = graph [ i ] [ 1 ] ; NEW_LINE c = graph [ i ] [ 2 ] ; NEW_LINE if ( start [ a ] or end [ b ] ) : NEW_LINE INDENT cost2 += c ; NEW_LINE start [ b ] = True ; NEW_LINE end [ a ] = True ; NEW_LINE DEDENT else : NEW_LINE INDENT cost1 += c ; NEW_LINE start [ a ] = True ; NEW_LINE end [ b ] = True ; NEW_LINE DEDENT DEDENT return min ( cost1 , cost2 ) ; NEW_LINE DEDENT
def minRevolutions ( r , x1 , y1 , x2 , y2 ) : NEW_LINE INDENT d = math . sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ) NEW_LINE return math . ceil ( d // ( 2 * r ) ) NEW_LINE DEDENT
def findArea ( a , b , c ) : NEW_LINE INDENT if ( a < 0 or b < 0 or c < 0 or ( a + b <= c ) or ( a + c <= b ) or ( b + c <= a ) ) : NEW_LINE INDENT print ( ' Not ▁ a ▁ valid ▁ trianglen ' ) NEW_LINE return NEW_LINE DEDENT s = ( a + b + c ) / 2 NEW_LINE area = ( s * ( s - a ) * ( s - b ) * ( s - c ) ) ** 0.5 NEW_LINE print ( ' Area ▁ of ▁ a ▁ traingle ▁ is ▁ % f ' % area ) NEW_LINE DEDENT
def printProbability ( L , n ) : NEW_LINE INDENT p = ( 1 << ( n - 1 ) ) NEW_LINE return 1.0 - ( float ( n ) / float ( p ) ) NEW_LINE DEDENT
def countRotations ( n ) : NEW_LINE INDENT l = len ( n ) NEW_LINE if ( l == 1 ) : NEW_LINE INDENT oneDigit = ( int ) ( n [ 0 ] ) NEW_LINE if ( oneDigit % 4 == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( 0 , l - 1 ) : NEW_LINE INDENT twoDigit = ( int ) ( n [ i ] ) * 10 + ( int ) ( n [ i + 1 ] ) NEW_LINE if ( twoDigit % 4 == 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT twoDigit = ( int ) ( n [ l - 1 ] ) * 10 + ( int ) ( n [ 0 ] ) NEW_LINE if ( twoDigit % 4 == 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def checkFibinnary ( n ) : NEW_LINE INDENT prev_last = 0 NEW_LINE while ( n ) : NEW_LINE INDENT if ( ( n & 1 ) and prev_last ) : NEW_LINE INDENT return False NEW_LINE DEDENT prev_last = n & 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT
def sumMaxOccuring ( arr ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT if arr [ i ] [ j ] in mp : NEW_LINE INDENT mp [ arr [ i ] [ j ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] [ j ] ] = 1 NEW_LINE DEDENT DEDENT DEDENT s = 0 NEW_LINE maxFreq = - sys . maxsize NEW_LINE for i in mp : NEW_LINE INDENT if mp [ i ] > maxFreq : NEW_LINE INDENT maxFreq = mp [ i ] NEW_LINE DEDENT DEDENT for i in mp : NEW_LINE INDENT if mp [ i ] == maxFreq : NEW_LINE INDENT s += i * mp [ i ] NEW_LINE DEDENT DEDENT return s NEW_LINE DEDENT
def solveQuery ( n , q , qi , qj ) : NEW_LINE INDENT arr = [ None ] * MAX NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT arr [ i ] = 0 NEW_LINE DEDENT for k in range ( q ) : NEW_LINE INDENT flag = 0 NEW_LINE if ( qj [ k ] < qi [ k ] ) : NEW_LINE INDENT qj [ k ] , qi [ k ] = qi [ k ] , qj [ k ] NEW_LINE DEDENT if ( arr [ qi [ k ] ] != 0 or arr [ qj [ k ] ] != 0 ) : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT elif ( qi [ k ] == qj [ k ] ) : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 1 , qi [ k ] ) : NEW_LINE INDENT if ( arr [ i ] != 0 and arr [ i ] < qj [ k ] and qi [ k ] < arr [ i ] ) : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag == 0 ) : NEW_LINE INDENT for i in range ( qi [ k ] + 1 , qj [ k ] ) : NEW_LINE INDENT if ( arr [ i ] != 0 and arr [ i ] > qj [ k ] ) : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT if ( flag == 0 ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE arr [ qi [ k ] ] = qj [ k ] NEW_LINE arr [ qj [ k ] ] = qi [ k ] NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT DEDENT
def egyptianFraction ( nr , dr ) : NEW_LINE INDENT print ( " The ▁ Egyptian ▁ Fraction ▁ " + " Representation ▁ of ▁ { 0 } / {1 } ▁ is " . format ( nr , dr ) , end = " \n " ) NEW_LINE ef = [ ] NEW_LINE while nr != 0 : NEW_LINE INDENT x = math . ceil ( dr / nr ) NEW_LINE ef . append ( x ) NEW_LINE nr = x * nr - dr NEW_LINE dr = dr * x NEW_LINE DEDENT for i in range ( len ( ef ) ) : NEW_LINE INDENT if i != len ( ef ) - 1 : NEW_LINE INDENT print ( " ▁ 1 / { 0 } ▁ + " . format ( ef [ i ] ) , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " ▁ 1 / { 0 } " . format ( ef [ i ] ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def calculateSum ( n ) : NEW_LINE INDENT a = int ( n ) NEW_LINE return ( 2 * ( pow ( n , 6 ) + 15 * pow ( n , 4 ) + 15 * pow ( n , 2 ) + 1 ) ) NEW_LINE DEDENT
def numOfWhiteHats ( arr , n ) : NEW_LINE INDENT freq = [ 0 for i in range ( n + 1 + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] >= n ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT freq [ arr [ i ] ] += 1 NEW_LINE DEDENT diffFreq = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( freq [ i ] ) : NEW_LINE INDENT diffFreq += 1 NEW_LINE DEDENT DEDENT if ( diffFreq == 1 and freq [ n - 1 ] == n ) : NEW_LINE INDENT return n NEW_LINE DEDENT if ( diffFreq == 1 and freq [ 0 ] == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( diffFreq != 2 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT for k in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT if ( freq [ k ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( freq [ k - 1 ] == k and freq [ k ] + k == n ) : NEW_LINE INDENT return freq [ k - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT
def solve ( s ) : NEW_LINE INDENT area = ( 1.732 * s ** 2 ) / 8 NEW_LINE return area NEW_LINE DEDENT
def countWays ( arr , n ) : NEW_LINE INDENT max_val = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT max_val = max ( max_val , arr [ i ] ) NEW_LINE DEDENT freq = [ 0 for i in range ( max_val + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ arr [ i ] ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE ans += ( freq [ 0 ] * ( freq [ 0 ] - 1 ) * ( freq [ 0 ] - 2 ) // 6 ) NEW_LINE for i in range ( 1 , max_val + 1 ) : NEW_LINE INDENT ans += ( freq [ 0 ] * freq [ i ] * ( freq [ i ] - 1 ) // 2 ) NEW_LINE DEDENT for i in range ( 1 , ( max_val + 1 ) // 2 ) : NEW_LINE INDENT ans += ( freq [ i ] * ( freq [ i ] - 1 ) // 2 * freq [ 2 * i ] ) NEW_LINE DEDENT for i in range ( 1 , max_val + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , max_val - i + 1 ) : NEW_LINE INDENT ans += freq [ i ] * freq [ j ] * freq [ i + j ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def print_max ( a , n , k ) : NEW_LINE INDENT max_upto = [ 0 for i in range ( n ) ] NEW_LINE s = [ ] NEW_LINE s . append ( 0 ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT while ( len ( s ) > 0 and a [ s [ - 1 ] ] < a [ i ] ) : NEW_LINE INDENT max_upto [ s [ - 1 ] ] = i - 1 NEW_LINE del s [ - 1 ] NEW_LINE DEDENT s . append ( i ) NEW_LINE DEDENT while ( len ( s ) > 0 ) : NEW_LINE INDENT max_upto [ s [ - 1 ] ] = n - 1 NEW_LINE del s [ - 1 ] NEW_LINE DEDENT j = 0 NEW_LINE for i in range ( n - k + 1 ) : NEW_LINE INDENT while ( j < i or max_upto [ j ] < i + k - 1 ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT print ( a [ j ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT
def smallestIndexsum ( arr , n ) : NEW_LINE INDENT i = n - 1 ; NEW_LINE while ( i >= 0 and arr [ i ] % 2 == 1 ) : NEW_LINE INDENT i -= 1 ; NEW_LINE DEDENT sum = 0 ; NEW_LINE for j in range ( 0 , i + 1 ) : NEW_LINE INDENT sum += arr [ j ] ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT
def minRotation ( input , unlock_code ) : NEW_LINE INDENT rotation = 0 ; NEW_LINE while ( input > 0 or unlock_code > 0 ) : NEW_LINE INDENT input_digit = input % 10 ; NEW_LINE code_digit = unlock_code % 10 ; NEW_LINE rotation += min ( abs ( input_digit - code_digit ) , 10 - abs ( input_digit - code_digit ) ) ; NEW_LINE input = int ( input / 10 ) ; NEW_LINE unlock_code = int ( unlock_code / 10 ) ; NEW_LINE DEDENT return rotation ; NEW_LINE DEDENT
def divisibilityCheck ( arr , n ) : NEW_LINE INDENT s = dict ( ) NEW_LINE max_ele = - 10 ** 9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s [ arr [ i ] ] = 1 NEW_LINE max_ele = max ( max_ele , arr [ i ] ) NEW_LINE DEDENT res = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] != 0 ) : NEW_LINE INDENT for j in range ( arr [ i ] * 2 , max_ele + 1 , arr [ i ] ) : NEW_LINE INDENT if ( j in s . keys ( ) ) : NEW_LINE INDENT res [ j ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT for x in res : NEW_LINE INDENT print ( x , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def findMaxCock ( ar ) : NEW_LINE INDENT if ( R < 3 or C < 3 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT max_sum = - sys . maxsize - 1 NEW_LINE for i in range ( R - 2 ) : NEW_LINE INDENT for j in range ( C - 2 ) : NEW_LINE INDENT sum = ( ( ar [ i ] [ j ] + ar [ i ] [ j + 2 ] ) + ( ar [ i + 1 ] [ j + 1 ] ) + ( ar [ i + 2 ] [ j ] + ar [ i + 2 ] [ j + 1 ] + ar [ i + 2 ] [ j + 2 ] ) ) NEW_LINE max_sum = max ( max_sum , sum ) NEW_LINE DEDENT DEDENT return max_sum ; NEW_LINE DEDENT
def aliquotSum ( n ) : NEW_LINE INDENT sm = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT sm = sm + i NEW_LINE DEDENT DEDENT return sm NEW_LINE DEDENT
def minOperations ( a , n , K ) : NEW_LINE INDENT map = dict . fromkeys ( a , False ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( map [ a [ i ] ] ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT map [ a [ i ] ] = True ; NEW_LINE DEDENT b = [ 0 ] * n ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT b [ i ] = a [ i ] ^ K ; NEW_LINE DEDENT map . clear ( ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] != b [ i ] ) : NEW_LINE INDENT map [ b [ i ] ] = True ; NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if a [ i ] in map : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT DEDENT map . clear ( ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if b [ i ] in map : NEW_LINE INDENT return 2 ; NEW_LINE DEDENT map [ b [ i ] ] = True ; NEW_LINE DEDENT return - 1 ; NEW_LINE DEDENT
def bit_check ( n ) : NEW_LINE INDENT if ( ( n & ( n - 1 ) ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def sumOfSeries ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += i * i * i NEW_LINE DEDENT return sum NEW_LINE DEDENT
def count ( n ) : NEW_LINE INDENT if ( n < 4 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT rem = n % 4 NEW_LINE if ( rem == 0 ) : NEW_LINE INDENT return n // 4 NEW_LINE DEDENT if ( rem == 1 ) : NEW_LINE INDENT if ( n < 9 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return ( n - 9 ) // 4 + 1 NEW_LINE DEDENT if ( rem == 2 ) : NEW_LINE INDENT return ( n - 6 ) // 4 + 1 NEW_LINE DEDENT if ( rem == 3 ) : NEW_LINE INDENT if ( n < 15 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return ( n - 15 ) // 4 + 2 NEW_LINE DEDENT DEDENT
def countSquares ( m , n ) : NEW_LINE INDENT if ( n < m ) : NEW_LINE INDENT temp = m NEW_LINE m = n NEW_LINE n = temp NEW_LINE DEDENT return n * ( n + 1 ) * ( 3 * m - n + 1 ) // 6 NEW_LINE DEDENT
def fib ( n ) : NEW_LINE INDENT i = n - 1 NEW_LINE x = ( p ** i - q ** i ) / ( p - q ) NEW_LINE return int ( x ) NEW_LINE DEDENT
def count ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ( n * count ( n - 1 ) ) + ( ( n - 1 ) * count ( n - 2 ) ) NEW_LINE DEDENT DEDENT
def findNumber ( n ) : NEW_LINE INDENT num = n - 1 ; NEW_LINE num = 2 * ( 4 ** num ) ; NEW_LINE num = num // 3 ; NEW_LINE return num ; NEW_LINE DEDENT
def sortString ( str ) : NEW_LINE INDENT charCount = [ 0 for i in range ( MAX_CHAR ) ] NEW_LINE for i in range ( 0 , len ( str ) , 1 ) : NEW_LINE INDENT charCount [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 0 , MAX_CHAR , 1 ) : NEW_LINE INDENT for j in range ( 0 , charCount [ i ] , 1 ) : NEW_LINE INDENT print ( chr ( ord ( ' a ' ) + i ) , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def binomialCoeffSum ( n ) : NEW_LINE INDENT C = [ [ 0 ] * ( n + 2 ) for i in range ( 0 , n + 2 ) ] NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT for j in range ( 0 , min ( i , n ) + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT sum = 0 NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT sum += C [ n ] [ i ] NEW_LINE DEDENT return sum NEW_LINE DEDENT
def minCost ( cost , n ) : NEW_LINE INDENT totalCost = 0 NEW_LINE boardingBus = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( cost [ boardingBus ] > cost [ i ] ) : NEW_LINE INDENT totalCost += ( ( i - boardingBus ) * cost [ boardingBus ] ) NEW_LINE boardingBus = i NEW_LINE DEDENT DEDENT totalCost += ( ( n - boardingBus ) * cost [ boardingBus ] ) NEW_LINE return totalCost NEW_LINE DEDENT
def findLength ( st , n ) : NEW_LINE INDENT total = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT total [ i ] = ( total [ i - 1 ] + int ( st [ i - 1 ] ) - int ( '0' ) ) NEW_LINE DEDENT ans = 0 NEW_LINE l = 2 NEW_LINE while ( l <= n ) : NEW_LINE INDENT for i in range ( n - l + 1 ) : NEW_LINE INDENT j = i + l - 1 NEW_LINE if ( total [ i + int ( l / 2 ) ] - total [ i ] == total [ i + l ] - total [ i + int ( l / 2 ) ] ) : NEW_LINE INDENT ans = max ( ans , l ) NEW_LINE DEDENT DEDENT l = l + 2 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def Divide ( a , b ) : NEW_LINE INDENT dividend = a ; NEW_LINE divisor = b ; NEW_LINE sign = - 1 if ( ( dividend < 0 ) ^ ( divisor < 0 ) ) else 1 ; NEW_LINE dividend = abs ( dividend ) ; NEW_LINE divisor = abs ( divisor ) ; NEW_LINE if ( divisor == 0 ) : NEW_LINE INDENT print ( " Cannot ▁ Divide ▁ by ▁ 0" ) ; NEW_LINE DEDENT if ( dividend == 0 ) : NEW_LINE INDENT print ( a , " / " , b , " is ▁ equal ▁ to ▁ : " , 0 ) ; NEW_LINE DEDENT if ( divisor == 1 ) : NEW_LINE INDENT print ( a , " / " , b , " is ▁ equal ▁ to ▁ : " , ( sign * dividend ) ) ; NEW_LINE DEDENT print ( a , " / " , b , " is ▁ equal ▁ to ▁ : " , math . floor ( sign * math . exp ( math . log ( dividend ) - math . log ( divisor ) ) ) ) ; NEW_LINE DEDENT
def getCount ( N ) : NEW_LINE INDENT if ( N % 2 == 1 ) : NEW_LINE INDENT return "0" NEW_LINE DEDENT result = "9" NEW_LINE for i in range ( 1 , N // 2 ) : NEW_LINE INDENT result = result + "0" NEW_LINE DEDENT return result NEW_LINE DEDENT
def maxOnesIndex ( arr , n ) : NEW_LINE INDENT max_count = 0 NEW_LINE max_index = 0 NEW_LINE prev_zero = - 1 NEW_LINE prev_prev_zero = - 1 NEW_LINE for curr in range ( n ) : NEW_LINE INDENT if ( arr [ curr ] == 0 ) : NEW_LINE INDENT if ( curr - prev_prev_zero > max_count ) : NEW_LINE INDENT max_count = curr - prev_prev_zero NEW_LINE max_index = prev_zero NEW_LINE DEDENT prev_prev_zero = prev_zero NEW_LINE prev_zero = curr NEW_LINE DEDENT DEDENT if ( n - prev_prev_zero > max_count ) : NEW_LINE INDENT max_index = prev_zero NEW_LINE DEDENT return max_index NEW_LINE DEDENT
def removeDuplicates ( arr , n ) : NEW_LINE INDENT st = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i < n - 2 and arr [ i ] == arr [ i + 1 ] and arr [ i ] == arr [ i + 2 ] ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT else : NEW_LINE INDENT arr [ st ] = arr [ i ] ; NEW_LINE st += 1 ; NEW_LINE DEDENT DEDENT print ( " { " , end = " " ) NEW_LINE for i in range ( st ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) ; NEW_LINE if ( i != st - 1 ) : NEW_LINE INDENT print ( " , ▁ " , end = " " ) ; NEW_LINE DEDENT DEDENT print ( " } " , end = " " ) ; NEW_LINE DEDENT
def shufleArray ( a , n ) : NEW_LINE INDENT n = n // 2 NEW_LINE start = n + 1 NEW_LINE j = n + 1 NEW_LINE for done in range ( 2 * n - 2 ) : NEW_LINE INDENT if ( start == j ) : NEW_LINE INDENT start -= 1 NEW_LINE j -= 1 NEW_LINE DEDENT i = j - n if j > n else j NEW_LINE j = 2 * i if j > n else 2 * i - 1 NEW_LINE a [ start ] , a [ j ] = a [ j ] , a [ start ] NEW_LINE DEDENT DEDENT
def countSolutions ( a ) : NEW_LINE INDENT count = bin ( a ) . count ( '1' ) NEW_LINE return 2 ** count NEW_LINE DEDENT
def evenFibSum ( limit ) : NEW_LINE INDENT if ( limit < 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ef1 = 0 NEW_LINE ef2 = 2 NEW_LINE sm = ef1 + ef2 NEW_LINE while ( ef2 <= limit ) : NEW_LINE INDENT ef3 = 4 * ef2 + ef1 NEW_LINE if ( ef3 > limit ) : NEW_LINE INDENT break NEW_LINE DEDENT ef1 = ef2 NEW_LINE ef2 = ef3 NEW_LINE sm = sm + ef2 NEW_LINE DEDENT return sm NEW_LINE DEDENT
def printPrevGreater ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT it = [ x for x in s if x >= arr [ i ] ] NEW_LINE if len ( it ) == 0 : NEW_LINE INDENT print ( " - 1" , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( min ( it ) , end = " ▁ " ) NEW_LINE DEDENT s . add ( arr [ i ] ) NEW_LINE DEDENT DEDENT
def countSolutions ( a ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( a + 1 ) : NEW_LINE INDENT if ( a == ( i + ( a ^ i ) ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def maxCost ( a , n , l , r ) : NEW_LINE INDENT mx = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT mx = max ( mx , a [ i ] ) NEW_LINE DEDENT count = [ 0 ] * ( mx + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ a [ i ] ] += 1 NEW_LINE DEDENT res = [ 0 ] * ( mx + 1 ) NEW_LINE res [ 0 ] = 0 NEW_LINE l = min ( l , r ) NEW_LINE for num in range ( 1 , mx + 1 ) : NEW_LINE INDENT k = max ( num - l - 1 , 0 ) NEW_LINE res [ num ] = max ( res [ num - 1 ] , num * count [ num ] + res [ k ] ) NEW_LINE DEDENT return res [ mx ] NEW_LINE DEDENT
def sum ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 2 ; NEW_LINE DEDENT else : NEW_LINE INDENT return ( n * ( n + 1 ) + sum ( n - 1 ) ) ; NEW_LINE DEDENT DEDENT
def nonDecNums ( n ) : NEW_LINE INDENT a = np . zeros ( ( n + 1 , 10 ) ) NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT a [ 0 ] [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT a [ i ] [ 9 ] = 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 8 , - 1 , - 1 ) : NEW_LINE INDENT a [ i ] [ j ] = a [ i - 1 ] [ j ] + a [ i ] [ j + 1 ] NEW_LINE DEDENT DEDENT return int ( a [ n ] [ 0 ] ) NEW_LINE DEDENT
def newvol ( x ) : NEW_LINE INDENT print ( " percentage ▁ increase ▁ in ▁ the " , pow ( x , 3 ) / 10000 + 3 * x + ( 3 * pow ( x , 2 ) ) / 100 , " % " ) DEDENT
def isDivisible ( n ) : NEW_LINE INDENT while n // 100 : NEW_LINE INDENT d = n % 10 NEW_LINE n //= 10 NEW_LINE n = abs ( n - ( d * 14 ) ) NEW_LINE DEDENT return ( n % 47 == 0 ) NEW_LINE DEDENT
def isProductEven ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( ( arr [ i ] & 1 ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def getMinMax ( low , high , arr ) : NEW_LINE INDENT arr_max = arr [ low ] NEW_LINE arr_min = arr [ low ] NEW_LINE if low == high : NEW_LINE INDENT arr_max = arr [ low ] NEW_LINE arr_min = arr [ low ] NEW_LINE return ( arr_max , arr_min ) NEW_LINE DEDENT elif high == low + 1 : NEW_LINE INDENT if arr [ low ] > arr [ high ] : NEW_LINE INDENT arr_max = arr [ low ] NEW_LINE arr_min = arr [ high ] NEW_LINE DEDENT else : NEW_LINE INDENT arr_max = arr [ high ] NEW_LINE arr_min = arr [ low ] NEW_LINE DEDENT return ( arr_max , arr_min ) NEW_LINE DEDENT else : NEW_LINE INDENT mid = int ( ( low + high ) / 2 ) NEW_LINE arr_max1 , arr_min1 = getMinMax ( low , mid , arr ) NEW_LINE arr_max2 , arr_min2 = getMinMax ( mid + 1 , high , arr ) NEW_LINE DEDENT return ( max ( arr_max1 , arr_max2 ) , min ( arr_min1 , arr_min2 ) ) NEW_LINE DEDENT
def countOperations ( n ) : NEW_LINE INDENT i = 2 NEW_LINE while ( ( i * i ) < n and ( n % i ) ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if ( ( i * i ) > n ) : NEW_LINE INDENT i = n NEW_LINE DEDENT return ( 1 + ( n - i ) // 2 ) NEW_LINE DEDENT
def printStrings ( s , l , m ) : NEW_LINE INDENT c = set ( ) NEW_LINE s = s + s NEW_LINE for i in range ( l ) : NEW_LINE INDENT c . add ( s [ i : i + m ] ) NEW_LINE DEDENT for i in c : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def getMissingNo ( a , n ) : NEW_LINE INDENT i , total = 0 , 1 NEW_LINE for i in range ( 2 , n + 2 ) : NEW_LINE INDENT total += i NEW_LINE total -= a [ i - 2 ] NEW_LINE DEDENT return total NEW_LINE DEDENT
def sumOddOccuring ( arr ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT if arr [ i ] [ j ] in mp : NEW_LINE INDENT mp [ arr [ i ] [ j ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] [ j ] ] = 1 NEW_LINE DEDENT DEDENT DEDENT s = 0 NEW_LINE for i in mp : NEW_LINE INDENT if mp [ i ] % 2 == 0 : NEW_LINE INDENT x = mp [ i ] NEW_LINE s += i * mp [ i ] NEW_LINE DEDENT DEDENT return s NEW_LINE DEDENT
def removeElements ( arr , n , l , r ) : NEW_LINE INDENT mp = { i : 0 for i in range ( len ( arr ) ) } NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( mp [ arr [ i ] ] < l or mp [ arr [ i ] > r ] ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def checkTriangularSumRepresentation ( n ) : NEW_LINE INDENT tri = list ( ) ; NEW_LINE i = 1 ; NEW_LINE while ( 1 ) : NEW_LINE INDENT x = i * ( i + 1 ) // 2 ; NEW_LINE if ( x >= n ) : NEW_LINE INDENT break ; NEW_LINE DEDENT tri . append ( x ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT for tm in tri : NEW_LINE INDENT if n - tm in tri : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT return False ; NEW_LINE DEDENT
def findMinEqualSums ( a , N ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT sum = sum + a [ i ] NEW_LINE DEDENT sum1 = 0 NEW_LINE sum2 = 0 NEW_LINE min = sys . maxsize NEW_LINE for i in range ( 0 , N - 1 ) : NEW_LINE INDENT sum1 += a [ i ] NEW_LINE sum2 = sum - sum1 NEW_LINE if ( abs ( sum1 - sum2 ) < min ) : NEW_LINE INDENT min = abs ( sum1 - sum2 ) NEW_LINE DEDENT if ( min == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return min NEW_LINE DEDENT
def distinctCount ( arr , n ) : NEW_LINE INDENT count = n ; NEW_LINE i = 0 ; j = n - 1 ; sum = 0 ; NEW_LINE while ( i < j ) : NEW_LINE INDENT while ( i != j and arr [ i ] == arr [ i + 1 ] ) : NEW_LINE INDENT count = count - 1 ; NEW_LINE i = i + 1 ; NEW_LINE DEDENT while ( i != j and arr [ j ] == arr [ j - 1 ] ) : NEW_LINE INDENT count = count - 1 ; NEW_LINE j = j - 1 ; NEW_LINE DEDENT if ( i == j ) : NEW_LINE INDENT break ; NEW_LINE DEDENT sum = arr [ i ] + arr [ j ] ; NEW_LINE if ( sum == 0 ) : NEW_LINE INDENT count = count - 1 ; NEW_LINE i = i + 1 ; NEW_LINE j = j - 1 ; NEW_LINE DEDENT elif ( sum < 0 ) : NEW_LINE INDENT i = i + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT j = j - 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT
def minAbsSumPair ( arr , arr_size ) : NEW_LINE INDENT inv_count = 0 NEW_LINE if arr_size < 2 : NEW_LINE INDENT print ( " Invalid ▁ Input " ) NEW_LINE return NEW_LINE DEDENT min_l = 0 NEW_LINE min_r = 1 NEW_LINE min_sum = arr [ 0 ] + arr [ 1 ] NEW_LINE for l in range ( 0 , arr_size - 1 ) : NEW_LINE INDENT for r in range ( l + 1 , arr_size ) : NEW_LINE INDENT sum = arr [ l ] + arr [ r ] NEW_LINE if abs ( min_sum ) > abs ( sum ) : NEW_LINE INDENT min_sum = sum NEW_LINE min_l = l NEW_LINE min_r = r NEW_LINE DEDENT DEDENT DEDENT print ( " The ▁ two ▁ elements ▁ whose ▁ sum ▁ is ▁ minimum ▁ are " , arr [ min_l ] , " and ▁ " , arr [ min_r ] ) NEW_LINE DEDENT
def findLength ( arr , n ) : NEW_LINE INDENT x = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = max ( x , arr [ i ] ) ; NEW_LINE DEDENT ans = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] != x ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT j = i ; NEW_LINE while ( arr [ j ] == x ) : NEW_LINE INDENT j += 1 ; NEW_LINE if j >= n : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT ans = max ( ans , j - i ) ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT
def power ( x , y ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p ; NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % p NEW_LINE DEDENT return res % p NEW_LINE DEDENT
def maxPathSum ( tri ) : NEW_LINE INDENT ans = 0 ; NEW_LINE for i in range ( N - 2 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( 0 , N - i ) : NEW_LINE INDENT if ( j - 1 >= 0 ) : NEW_LINE INDENT tri [ i ] [ j ] += max ( tri [ i + 1 ] [ j ] , tri [ i + 1 ] [ j - 1 ] ) ; NEW_LINE DEDENT else : NEW_LINE INDENT tri [ i ] [ j ] += tri [ i + 1 ] [ j ] ; NEW_LINE DEDENT ans = max ( ans , tri [ i ] [ j ] ) ; NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def maximize ( A1 , A2 , n , x , y ) : NEW_LINE INDENT c = [ 0 for i in range ( n ) ] NEW_LINE Sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT c [ i ] = A2 [ i ] - A1 [ i ] NEW_LINE Sum += A1 [ i ] NEW_LINE DEDENT c . sort ( ) NEW_LINE c = c [ : : - 1 ] NEW_LINE maxi = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT Sum += c [ i ] NEW_LINE if ( i + 1 >= ( n - x ) ) : NEW_LINE INDENT maxi = max ( Sum , maxi ) NEW_LINE DEDENT DEDENT return maxi NEW_LINE DEDENT
def printEqualModNumbers ( arr , n ) : NEW_LINE INDENT arr . sort ( ) ; NEW_LINE d = arr [ n - 1 ] - arr [ 0 ] ; NEW_LINE // Case when all the array elements are same NEW_LINE if ( d == 0 ) : NEW_LINE INDENT print ( " Infinite ▁ solution " ) NEW_LINE return NEW_LINE DEDENT v = [ ] ; NEW_LINE i = 1 ; NEW_LINE while ( i * i <= d ) : NEW_LINE INDENT if ( d % i == 0 ) : NEW_LINE INDENT v . append ( i ) ; NEW_LINE if ( i != d / i ) : NEW_LINE INDENT v . append ( d / i ) ; NEW_LINE DEDENT DEDENT i += 1 ; NEW_LINE DEDENT for i in range ( len ( v ) ) : NEW_LINE INDENT temp = arr [ 0 ] % v [ i ] ; NEW_LINE j = 1 ; NEW_LINE while ( j < n ) : NEW_LINE INDENT if ( arr [ j ] % v [ i ] != temp ) : NEW_LINE INDENT break ; NEW_LINE DEDENT j += 1 ; NEW_LINE DEDENT if ( j == n ) : NEW_LINE INDENT print ( v [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT DEDENT
def toBinary ( n ) : NEW_LINE INDENT if ( n >= 1 or n <= 0 ) : NEW_LINE INDENT return " ERROR " NEW_LINE DEDENT answer = " " NEW_LINE frac = 0.5 NEW_LINE answer = answer + " . " NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( len ( answer ) >= 32 ) : NEW_LINE INDENT return " ERROR " NEW_LINE DEDENT b = n * 2 NEW_LINE if ( b >= 1 ) : NEW_LINE INDENT answer = answer + "1" NEW_LINE n = b - 1 NEW_LINE DEDENT else : NEW_LINE INDENT answer = answer + "0" NEW_LINE n = b NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT
def numberOfCells ( mat ) : NEW_LINE INDENT row = [ [ False for i in range ( N ) ] for i in range ( N ) ] NEW_LINE col = [ [ False for i in range ( N ) ] for i in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == 1 ) : NEW_LINE INDENT if j + 1 < N : NEW_LINE INDENT row [ i ] [ j ] = row [ i ] [ j + 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT row [ i ] [ j ] = True NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT row [ i ] [ j ] = False NEW_LINE DEDENT DEDENT DEDENT for j in range ( N ) : NEW_LINE INDENT for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == 1 ) : NEW_LINE INDENT if i + 1 < N : NEW_LINE INDENT col [ i ] [ j ] = col [ i + 1 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT col [ i ] [ j ] = True NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT col [ i ] [ j ] = False NEW_LINE DEDENT DEDENT DEDENT cnt = 0 NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT for j in range ( N - 1 ) : NEW_LINE INDENT if ( row [ i ] [ j ] and col [ i ] [ j ] ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT if ( col [ i ] [ N - 1 ] ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT for j in range ( N - 1 ) : NEW_LINE INDENT if ( row [ N - 1 ] [ j ] ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
def LongestSubarray ( arr , n , k ) : NEW_LINE INDENT count = 1 NEW_LINE max_lenght = 1 NEW_LINE prev_mod = arr [ 0 ] % k NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT curr_mod = arr [ i ] % k NEW_LINE if curr_mod == prev_mod : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT max_lenght = max ( max_lenght , count ) NEW_LINE count = 1 NEW_LINE prev_mod = curr_mod NEW_LINE DEDENT DEDENT return max_lenght NEW_LINE DEDENT
def printPattern ( n ) : NEW_LINE INDENT j , k = 0 , 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if i % 2 != 0 : NEW_LINE INDENT for j in range ( k + 1 , k + i ) : NEW_LINE INDENT print ( str ( j ) + " * " , end = " " ) NEW_LINE DEDENT j = k + i NEW_LINE print ( j ) NEW_LINE j += 1 NEW_LINE k = j NEW_LINE DEDENT else : NEW_LINE INDENT k = k + i - 1 NEW_LINE for j in range ( k , k - i + 1 , - 1 ) : NEW_LINE INDENT print ( str ( j ) + " * " , end = " " ) NEW_LINE DEDENT j = k - i + 1 NEW_LINE print ( j ) NEW_LINE DEDENT DEDENT DEDENT
def minMaxValues ( arr , n , m ) : NEW_LINE INDENT sum = 0 NEW_LINE INF = 1000000000 NEW_LINE MAX = 50 NEW_LINE for i in range ( 0 , ( n + m ) ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE arr [ i ] += 50 NEW_LINE DEDENT dp = [ [ 0 for x in range ( MAX * MAX + 1 ) ] for y in range ( MAX + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 0 , ( n + m ) ) : NEW_LINE INDENT for k in range ( min ( n , i + 1 ) , 0 , - 1 ) : NEW_LINE INDENT for j in range ( 0 , MAX * MAX + 1 ) : NEW_LINE INDENT if ( dp [ k - 1 ] [ j ] ) : NEW_LINE INDENT dp [ k ] [ j + arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT max_value = - 1 * INF NEW_LINE min_value = INF NEW_LINE for i in range ( 0 , MAX * MAX + 1 ) : NEW_LINE INDENT if ( dp [ n ] [ i ] ) : NEW_LINE INDENT temp = i - 50 * n NEW_LINE max_value = max ( max_value , temp * ( sum - temp ) ) NEW_LINE min_value = min ( min_value , temp * ( sum - temp ) ) NEW_LINE DEDENT DEDENT print ( " Maximum ▁ Value : ▁ { } \n Minimum ▁ Value : ▁ { } " . format ( max_value , min_value ) ) NEW_LINE DEDENT
def StrictlyPositiveXor ( A , N ) : NEW_LINE INDENT allxor = 0 ; NEW_LINE checkallzero = True ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT allxor ^= A [ i ] ; NEW_LINE if ( A [ i ] > 0 ) : NEW_LINE INDENT checkallzero = False ; NEW_LINE DEDENT DEDENT if ( allxor != 0 ) : NEW_LINE INDENT return N ; NEW_LINE DEDENT if ( checkallzero ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT l = N ; r = - 1 ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( A [ i ] > 0 ) : NEW_LINE INDENT l = i + 1 ; NEW_LINE break ; NEW_LINE DEDENT DEDENT for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( A [ i ] > 0 ) : NEW_LINE INDENT r = i + 1 ; NEW_LINE break ; NEW_LINE DEDENT DEDENT return max ( N - l , r - 1 ) ; NEW_LINE DEDENT
def findNthTerm ( n ) : NEW_LINE INDENT if n % 2 == 0 : NEW_LINE INDENT n //= 2 NEW_LINE print ( 3 ** ( n - 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT n = ( n // 2 ) + 1 NEW_LINE print ( 2 ** ( n - 1 ) ) NEW_LINE DEDENT DEDENT
def Squares ( n , m , a ) : NEW_LINE INDENT return ( ( ( m + a - 1 ) // a ) * ( ( n + a - 1 ) // a ) ) NEW_LINE DEDENT
def maxOnesIndex ( arr , n ) : NEW_LINE INDENT i = 0 NEW_LINE leftCnt = 0 NEW_LINE rightCnt = 0 NEW_LINE maxIndex = - 1 NEW_LINE lastInd = - 1 NEW_LINE maxCnt = 0 NEW_LINE while i < n : NEW_LINE INDENT if arr [ i ] == 1 : NEW_LINE INDENT rightCnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if lastInd != - 1 : NEW_LINE INDENT if rightCnt + leftCnt + 1 > maxCnt : NEW_LINE INDENT maxCnt = leftCnt + rightCnt + 1 NEW_LINE maxIndex = lastInd NEW_LINE DEDENT DEDENT lastInd = i NEW_LINE leftCnt = rightCnt NEW_LINE rightCnt = 0 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if lastInd != - 1 : NEW_LINE INDENT if leftCnt + rightCnt + 1 > maxCnt : NEW_LINE INDENT maxCnt = leftCnt + rightCnt + 1 NEW_LINE maxIndex = lastInd NEW_LINE DEDENT DEDENT return maxIndex NEW_LINE DEDENT
def closetAND ( arr , n , k ) : NEW_LINE INDENT ans = sys . maxsize ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT X = arr [ i ] ; NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT X &= arr [ j ] ; NEW_LINE ans = min ( ans , abs ( k - X ) ) ; NEW_LINE if ( X <= k ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT DEDENT return ans ; NEW_LINE DEDENT
def minOperations ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE freq = [ 0 ] * 1000001 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT freq [ arr [ i ] ] += 1 NEW_LINE DEDENT maxi = max ( arr ) NEW_LINE for i in range ( 1 , maxi + 1 ) : NEW_LINE INDENT if freq [ i ] != 0 : NEW_LINE INDENT for j in range ( i * 2 , maxi + 1 , i ) : NEW_LINE INDENT freq [ j ] = 0 NEW_LINE DEDENT result += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def min_elimination ( n , arr ) : NEW_LINE INDENT countOdd = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 ) : NEW_LINE INDENT countOdd += 1 NEW_LINE DEDENT DEDENT return min ( countOdd , n - countOdd ) NEW_LINE DEDENT
def minimumChanges ( n , a ) : NEW_LINE INDENT sf = [ 0 ] * ( n + 1 ) NEW_LINE sf [ n ] = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT sf [ i ] = sf [ i + 1 ] NEW_LINE if ( a [ i ] <= 0 ) : NEW_LINE INDENT sf [ i ] += 1 NEW_LINE DEDENT DEDENT pos = 0 NEW_LINE mn = n NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( a [ i ] >= 0 ) : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT mn = min ( mn , pos + sf [ i + 1 ] ) NEW_LINE DEDENT return mn NEW_LINE DEDENT
def squares ( l , b , a ) : NEW_LINE INDENT return math . ceil ( l / a ) * math . ceil ( b / a ) NEW_LINE DEDENT
def search ( ar , size ) : NEW_LINE INDENT a = 0 NEW_LINE b = size - 1 NEW_LINE mid = 0 NEW_LINE while b > a + 1 : NEW_LINE INDENT mid = ( a + b ) // 2 NEW_LINE if ( ar [ a ] - a ) != ( ar [ mid ] - mid ) : NEW_LINE INDENT b = mid NEW_LINE DEDENT elif ( ar [ b ] - b ) != ( ar [ mid ] - mid ) : NEW_LINE INDENT a = mid NEW_LINE DEDENT DEDENT return ar [ mid ] + 1 NEW_LINE DEDENT
def diagonalsMinMax ( mat ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT principalMin = mat [ 0 ] [ 0 ] NEW_LINE principalMax = mat [ 0 ] [ 0 ] NEW_LINE secondaryMin = mat [ n - 1 ] [ 0 ] NEW_LINE secondaryMax = mat [ n - 1 ] [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( mat [ i ] [ i ] < principalMin ) : NEW_LINE INDENT principalMin = mat [ i ] [ i ] NEW_LINE DEDENT if ( mat [ i ] [ i ] > principalMax ) : NEW_LINE INDENT principalMax = mat [ i ] [ i ] NEW_LINE DEDENT if ( mat [ n - 1 - i ] [ i ] < secondaryMin ) : NEW_LINE INDENT secondaryMin = mat [ n - 1 - i ] [ i ] NEW_LINE DEDENT if ( mat [ n - 1 - i ] [ i ] > secondaryMax ) : NEW_LINE INDENT secondaryMax = mat [ n - 1 - i ] [ i ] NEW_LINE DEDENT DEDENT print ( " Principal ▁ Diagonal ▁ Smallest ▁ Element : ▁ " , principalMin ) NEW_LINE print ( " Principal ▁ Diagonal ▁ Greatest ▁ Element ▁ : ▁ " , principalMax ) NEW_LINE print ( " Secondary ▁ Diagonal ▁ Smallest ▁ Element : ▁ " , secondaryMin ) NEW_LINE print ( " Secondary ▁ Diagonal ▁ Greatest ▁ Element : ▁ " , secondaryMax ) NEW_LINE DEDENT
def subgrids ( N , Z , row , col , r , d ) : NEW_LINE INDENT conrow = [ ] ; NEW_LINE concol = [ ] ; NEW_LINE K = int ( sqrt ( Z ) ) ; NEW_LINE conrow . append ( row [ 0 ] - 0 - 1 ) NEW_LINE conrow . append ( N + 1 - row [ r - 1 ] - 1 ) NEW_LINE for i in range ( 1 , r ) : NEW_LINE INDENT conrow . append ( row [ i ] - row [ i - 1 ] - 1 ) ; NEW_LINE DEDENT concol . append ( col [ 0 ] - 0 - 1 ) NEW_LINE concol . append ( N + 1 - col [ d - 1 ] - 1 ) NEW_LINE for i in range ( 1 , d ) : NEW_LINE INDENT concol . append ( col [ i ] - col [ i - 1 ] - 1 ) ; NEW_LINE DEDENT row_size = len ( conrow ) NEW_LINE col_size = len ( concol ) NEW_LINE answer = 0 NEW_LINE for i in range ( row_size ) : NEW_LINE INDENT for j in range ( col_size ) : NEW_LINE INDENT total = ( concol [ j ] // K ) *   \ NEW_LINE INDENT ( conrow [ i ] // K ) NEW_LINE DEDENT answer += ( total ) NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT
def toggleCase ( a ) : NEW_LINE INDENT for i in range ( len ( a ) ) : NEW_LINE INDENT a = a [ : i ] + chr ( ord ( a [ i ] ) ^ 32 ) + a [ i + 1 : ] ; NEW_LINE DEDENT return a ; NEW_LINE DEDENT
def findMinRemoval ( arr , n ) : NEW_LINE INDENT value = 0 NEW_LINE maximum = 0 NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( i != 0 and i != n - 1 ) : NEW_LINE INDENT value = value + abs ( arr [ i ] - arr [ i + 1 ] ) NEW_LINE temp = ( abs ( arr [ i ] - arr [ i + 1 ] ) + abs ( arr [ i ] - arr [ i - 1 ] ) - abs ( arr [ i - 1 ] - arr [ i + 1 ] ) ) NEW_LINE DEDENT elif ( i == 0 ) : NEW_LINE INDENT value = value + abs ( arr [ i ] - arr [ i + 1 ] ) NEW_LINE temp = abs ( arr [ i ] - arr [ i + 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT temp = abs ( arr [ i ] - arr [ i - 1 ] ) NEW_LINE DEDENT maximum = max ( maximum , temp ) NEW_LINE DEDENT return ( value - maximum ) NEW_LINE DEDENT
def divide ( n , m ) : NEW_LINE INDENT print ( " Remainder ▁ = ▁ " , ( ( n ) & ( m - 1 ) ) ) NEW_LINE print ( " Quotient ▁ = ▁ " , ( n >> ( int ) ( math . log2 ( m ) ) ) ) NEW_LINE DEDENT
def nthHarmonic ( N ) : NEW_LINE INDENT harmonic = 1.00 NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT harmonic += 1 / i NEW_LINE DEDENT return harmonic NEW_LINE DEDENT
def printSubstrings ( n ) : NEW_LINE INDENT s = int ( math . log10 ( n ) ) ; NEW_LINE d = ( math . pow ( 10 , s ) ) ; NEW_LINE k = d ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT while ( d > 0 ) : NEW_LINE INDENT print ( int ( n // d ) ) ; NEW_LINE d = int ( d / 10 ) ; NEW_LINE DEDENT n = int ( n % k ) ; NEW_LINE k = int ( k // 10 ) ; NEW_LINE d = k ; NEW_LINE DEDENT DEDENT
def checkArray ( a , b , n ) : NEW_LINE INDENT operations = 0 ; NEW_LINE i = 0 ; NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( a [ i ] - b [ i ] == 0 ) : NEW_LINE INDENT i += 1 ; NEW_LINE continue ; NEW_LINE DEDENT diff = a [ i ] - b [ i ] ; NEW_LINE i += 1 ; NEW_LINE while ( i < n and a [ i ] - b [ i ] == diff ) : NEW_LINE INDENT i += 1 ; NEW_LINE DEDENT operations += 1 ; NEW_LINE DEDENT print ( operations ) ; NEW_LINE DEDENT
def difference ( arr , n ) : NEW_LINE INDENT largest = arr [ 0 ] ; NEW_LINE i = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( largest < arr [ i ] ) : NEW_LINE INDENT largest = arr [ i ] ; NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = largest - arr [ i ] ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT
def isMagic ( n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE while ( n > 0 or sum > 9 ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT n = sum ; NEW_LINE sum = 0 ; NEW_LINE DEDENT sum = sum + n % 10 ; NEW_LINE n = int ( n / 10 ) ; NEW_LINE DEDENT return True if ( sum == 1 ) else False ; NEW_LINE DEDENT
def InscribedCircleArea ( n , a ) : NEW_LINE INDENT if ( a < 0 and n < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT r = a / ( 2 * tan ( ( 180 / n ) * 3.14159 / 180 ) ) ; NEW_LINE Area = 3.14 * r * r NEW_LINE return Area NEW_LINE DEDENT
def EvenOddProduct ( arr , n ) : NEW_LINE INDENT even = 1 NEW_LINE odd = 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT even *= arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT odd *= arr [ i ] NEW_LINE DEDENT DEDENT print ( " Even ▁ Index ▁ Product ▁ : ▁ " , even ) NEW_LINE print ( " Odd ▁ Index ▁ Product ▁ : ▁ " , odd ) NEW_LINE DEDENT
def isPairWithDiff ( mat , k ) : NEW_LINE INDENT s = dict ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT s [ mat [ i ] [ j ] ] = 1 NEW_LINE DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT if k + mat [ i ] [ j ] in s : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
def findVolume ( l , b , h ) : NEW_LINE INDENT return ( ( l * b * h ) / 2 ) NEW_LINE DEDENT
def countSetBits ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 + countSetBits ( n & ( n - 1 ) ) NEW_LINE DEDENT DEDENT
def countSteps ( val , n ) : NEW_LINE INDENT sol = 0 ; NEW_LINE vec = [ 1 , 0 ] ; NEW_LINE status [ 0 ] = - 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT status [ i ] = 0 ; NEW_LINE while ( len ( vec ) > 0 and val [ vec [ len ( vec ) - 1 ] ] >= val [ i ] ) : NEW_LINE INDENT status [ i ] = max ( status [ i ] , status [ len ( vec ) - 1 ] + 1 ) ; NEW_LINE vec . pop ( ) ; NEW_LINE DEDENT if ( len ( vec ) == 0 ) : NEW_LINE INDENT status [ i ] = - 1 ; NEW_LINE DEDENT vec . append ( i ) ; NEW_LINE sol = max ( sol , status [ i ] + 1 ) ; NEW_LINE DEDENT return sol ; NEW_LINE DEDENT
def odd_digits ( n ) : NEW_LINE INDENT if ( n < 10 ) : NEW_LINE INDENT return n ; NEW_LINE DEDENT elif ( n / 10 < 10 ) : NEW_LINE INDENT return 9 ; NEW_LINE DEDENT elif ( n / 100 < 10 ) : NEW_LINE INDENT return 9 + n - 99 ; NEW_LINE DEDENT elif ( n / 1000 < 10 ) : NEW_LINE INDENT return 9 + 900 ; NEW_LINE DEDENT elif ( n / 10000 < 10 ) : NEW_LINE INDENT return 909 + n - 9999 ; NEW_LINE DEDENT else : NEW_LINE INDENT return 90909 ; NEW_LINE DEDENT DEDENT
def even_or_odd ( N ) : NEW_LINE INDENT l = len ( N ) NEW_LINE if ( N [ l - 1 ] == '0' or N [ l - 1 ] == '2' or N [ l - 1 ] == '4' or N [ l - 1 ] == '6' or N [ l - 1 ] == '8' or N [ l - 1 ] == ' A ' or N [ l - 1 ] == ' C ' or N [ l - 1 ] == ' E ' ) : NEW_LINE INDENT return ( " Even " ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( " Odd " ) NEW_LINE DEDENT DEDENT
def parallel ( n , a ) : NEW_LINE INDENT x = True ; NEW_LINE y = True ; NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( 2 ) : NEW_LINE INDENT if ( a [ i ] [ 0 ] != a [ i + 1 ] [ 0 ] ) : NEW_LINE INDENT x = False ; NEW_LINE DEDENT if ( a [ i ] [ 1 ] != a [ i + 1 ] [ 1 ] ) : NEW_LINE INDENT y = False ; NEW_LINE DEDENT DEDENT DEDENT if ( x ) : NEW_LINE INDENT print ( " Parallel ▁ to ▁ X ▁ Axis " ) ; NEW_LINE DEDENT elif ( y ) : NEW_LINE INDENT print ( " Parallel ▁ to ▁ Y ▁ Axis " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Parallel ▁ to ▁ X ▁ and ▁ Y ▁ Axis " ) ; NEW_LINE DEDENT DEDENT
def sub_segments ( string , n ) : NEW_LINE INDENT l = len ( string ) NEW_LINE for x in range ( 0 , l , n ) : NEW_LINE INDENT newlist = string [ x : x + n ] NEW_LINE arr = [ ] NEW_LINE for y in newlist : NEW_LINE INDENT if y not in arr : NEW_LINE INDENT arr . append ( y ) NEW_LINE DEDENT DEDENT print ( ' ' . join ( arr ) ) NEW_LINE DEDENT DEDENT
def printNthElement ( n ) : NEW_LINE INDENT arr = [ 0 ] * ( n + 1 ) ; NEW_LINE arr [ 1 ] = 3 NEW_LINE arr [ 2 ] = 5 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT if ( i % 2 != 0 ) : NEW_LINE INDENT arr [ i ] = arr [ i // 2 ] * 10 + 3 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = arr [ ( i // 2 ) - 1 ] * 10 + 5 NEW_LINE DEDENT DEDENT return arr [ n ] NEW_LINE DEDENT
def lds ( arr , n ) : NEW_LINE INDENT lds = [ 0 for i in range ( n ) ] NEW_LINE lds [ 0 ] = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT lds [ i ] = 1 NEW_LINE for j in range ( i ) : NEW_LINE INDENT if ( lds [ j ] != 0 and arr [ i ] % arr [ j ] == 0 ) : NEW_LINE INDENT lds [ i ] = max ( lds [ i ] , lds [ j ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT return max ( lds ) NEW_LINE DEDENT
def smallestIndex ( a , n ) : NEW_LINE INDENT right1 = 0 NEW_LINE right0 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == 1 ) : NEW_LINE INDENT right1 = i NEW_LINE DEDENT else : NEW_LINE INDENT right0 = i NEW_LINE DEDENT DEDENT return min ( right1 , right0 ) NEW_LINE DEDENT
def getMod ( _str , n , k ) : NEW_LINE INDENT pwrTwo = [ 0 ] * n NEW_LINE pwrTwo [ 0 ] = 1 % k NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT pwrTwo [ i ] = pwrTwo [ i - 1 ] * ( 2 % k ) NEW_LINE pwrTwo [ i ] %= k NEW_LINE DEDENT res = 0 NEW_LINE i = 0 NEW_LINE j = n - 1 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( _str [ j ] == '1' ) : NEW_LINE INDENT res += ( pwrTwo [ i ] ) NEW_LINE res %= k NEW_LINE DEDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
def isPerfect ( n ) : NEW_LINE INDENT sum = 1 NEW_LINE i = 2 NEW_LINE while i * i <= n : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT sum = sum + i + n / i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return ( True if sum == n and n != 1 else False ) NEW_LINE DEDENT
def maxProd ( arr , n , k ) : NEW_LINE INDENT product = 1 ; NEW_LINE s = dict . fromkeys ( arr , 0 ) ; NEW_LINE arr . sort ( ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ arr [ i ] ] == 0 ) : NEW_LINE INDENT product = product * arr [ i ] ; NEW_LINE DEDENT s [ arr [ i ] ] = s [ arr [ i ] ] + 1 ; NEW_LINE DEDENT j = n - 1 ; NEW_LINE while ( j >= 0 and k > 0 ) : NEW_LINE INDENT if ( ( k > ( s [ arr [ j ] ] - 1 ) ) and ( ( s [ arr [ j ] ] - 1 ) > 0 ) ) : NEW_LINE INDENT product *= pow ( arr [ j ] , s [ arr [ j ] ] - 1 ) ; NEW_LINE k = k - s [ arr [ j ] ] + 1 ; NEW_LINE s [ arr [ j ] ] = 0 ; NEW_LINE DEDENT if ( k <= ( s [ arr [ j ] ] - 1 ) and ( ( s [ arr [ j ] ] - 1 ) > 0 ) ) : NEW_LINE INDENT product *= pow ( arr [ j ] , k ) ; NEW_LINE break ; NEW_LINE DEDENT j -= 1 NEW_LINE DEDENT return product ; NEW_LINE DEDENT
def findLength ( string ) : NEW_LINE INDENT n = len ( string ) NEW_LINE maxlen = 0 NEW_LINE Sum = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT Sum [ i ] [ i ] = int ( string [ i ] ) NEW_LINE DEDENT for length in range ( 2 , n + 1 ) : NEW_LINE INDENT for i in range ( 0 , n - length + 1 ) : NEW_LINE INDENT j = i + length - 1 NEW_LINE k = length // 2 NEW_LINE Sum [ i ] [ j ] = ( Sum [ i ] [ j - k ] + Sum [ j - k + 1 ] [ j ] ) NEW_LINE if ( length % 2 == 0 and Sum [ i ] [ j - k ] == Sum [ ( j - k + 1 ) ] [ j ] and length > maxlen ) : NEW_LINE INDENT maxlen = length NEW_LINE DEDENT DEDENT DEDENT return maxlen NEW_LINE DEDENT
def KthCharacter ( m , n , k ) : NEW_LINE INDENT distance = pow ( 2 , n ) NEW_LINE Block_number = int ( k / distance ) NEW_LINE remaining = k % distance NEW_LINE s = [ 0 ] * 32 NEW_LINE x = 0 NEW_LINE while ( m > 0 ) : NEW_LINE INDENT s [ x ] = m % 2 NEW_LINE m = int ( m / 2 ) NEW_LINE x += 1 NEW_LINE DEDENT root = s [ x - 1 - Block_number ] NEW_LINE if ( remaining == 0 ) : NEW_LINE INDENT print ( root ) NEW_LINE return NEW_LINE DEDENT flip = True NEW_LINE while ( remaining > 1 ) : NEW_LINE INDENT if ( remaining & 1 ) : NEW_LINE INDENT flip = not ( flip ) NEW_LINE DEDENT remaining = remaining >> 1 NEW_LINE DEDENT if ( flip ) : NEW_LINE INDENT print ( not ( root ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( root ) NEW_LINE DEDENT DEDENT
def getMaxMedian ( arr , n , k ) : NEW_LINE INDENT size = n + k NEW_LINE arr . sort ( reverse = False ) NEW_LINE if ( size % 2 == 0 ) : NEW_LINE INDENT median = ( arr [ int ( size / 2 ) - 1 ] + arr [ int ( size / 2 ) ] ) / 2 NEW_LINE return median NEW_LINE DEDENT median = arr [ int ( size / 2 ) ] NEW_LINE return median NEW_LINE DEDENT
def powerfulIntegers ( x , y , bound ) : NEW_LINE INDENT s = set ( ) NEW_LINE powersOfY = [ ] NEW_LINE powersOfY . append ( 1 ) NEW_LINE i = y NEW_LINE while i < bound : NEW_LINE INDENT powersOfY . append ( i ) NEW_LINE i *= y NEW_LINE DEDENT i = 0 NEW_LINE while ( True ) : NEW_LINE INDENT xPowI = pow ( x , i ) NEW_LINE if ( xPowI >= bound ) : NEW_LINE INDENT break NEW_LINE DEDENT for j in powersOfY : NEW_LINE INDENT num = xPowI + j NEW_LINE if ( num <= bound ) : NEW_LINE INDENT s . add ( num ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT for itr in s : NEW_LINE INDENT print ( itr , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def judgeSquareSum ( n ) : NEW_LINE INDENT i = 2 ; NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT count = 0 ; NEW_LINE if ( n % i == 0 ) : NEW_LINE INDENT while ( n % i == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE n = int ( n / i ) ; NEW_LINE DEDENT if ( i % 4 == 3 and count % 2 != 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT i += 1 ; NEW_LINE DEDENT return n % 4 != 3 ; NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return pow ( n , 2 ) + 2 * n + 2 NEW_LINE DEDENT
def Cel_To_Fah ( n ) : NEW_LINE INDENT return ( n * 1.8 ) + 32 NEW_LINE DEDENT
def divisorSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += int ( n / i ) * i NEW_LINE DEDENT return int ( sum ) NEW_LINE DEDENT
def centeredTetrahedralNumber ( n ) : NEW_LINE INDENT return ( 2 * n + 1 ) * ( n * n + n + 3 ) // 3 NEW_LINE DEDENT
def sumOfSeries ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum = sum + ( 2 * i - 1 ) * ( 2 * i - 1 ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def countFreq ( a , n ) : NEW_LINE INDENT hm = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT hm [ a [ i ] ] = hm . get ( a [ i ] , 0 ) + 1 NEW_LINE DEDENT cumul = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT cumul += hm [ a [ i ] ] NEW_LINE if ( hm [ a [ i ] ] > 0 ) : NEW_LINE INDENT print ( a [ i ] , " - > " , cumul ) NEW_LINE DEDENT hm [ a [ i ] ] = 0 NEW_LINE DEDENT DEDENT
def count_flips ( a , n , k ) : NEW_LINE INDENT min_diff , ans , set = n , 0 , False NEW_LINE for i in range ( k ) : NEW_LINE INDENT curr_index , segment , \ NEW_LINE count_zero , count_one = \ NEW_LINE INDENT i , 0 , 0 , 0 NEW_LINE DEDENT while curr_index < n : NEW_LINE INDENT if segment % 2 == 0 : NEW_LINE INDENT if a [ curr_index ] == 1 : NEW_LINE INDENT count_zero += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_one += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if a [ curr_index ] == 0 : NEW_LINE INDENT count_zero += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_one += 1 NEW_LINE DEDENT DEDENT curr_index += k NEW_LINE segment += 1 NEW_LINE DEDENT ans += min ( count_zero , count_one ) NEW_LINE if count_one < count_zero : NEW_LINE INDENT set = not set NEW_LINE DEDENT min_diff = min ( min_diff , \ abs ( count_zero - count_one ) ) NEW_LINE DEDENT if set : NEW_LINE INDENT return ans NEW_LINE DEDENT else : NEW_LINE INDENT return ans + min_diff NEW_LINE DEDENT DEDENT
def findNumber ( n ) : NEW_LINE INDENT x = int ( math . floor ( ( - 1 + math . sqrt ( 1 + 8 * n - 8 ) ) / 2 ) ) NEW_LINE base = ( x * ( x + 1 ) ) / 2 + 1 NEW_LINE return n - base + 1 NEW_LINE DEDENT
def countPairs ( arr , n ) : NEW_LINE INDENT count_2 , count_others = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] == 2 : NEW_LINE INDENT count_2 += 1 NEW_LINE DEDENT elif arr [ i ] > 2 : NEW_LINE INDENT count_others += 1 NEW_LINE DEDENT DEDENT ans = ( count_2 * count_others + ( count_others * ( count_others - 1 ) ) // 2 ) NEW_LINE return ans NEW_LINE DEDENT
def getMinimumOps ( ar , k ) : NEW_LINE INDENT n = len ( ar ) NEW_LINE dp = [ [ 0 for i in range ( k + 1 ) ] for i in range ( n ) ] NEW_LINE dp [ 0 ] [ 1 ] = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT maxGroups = min ( k , i + 1 ) NEW_LINE for j in range ( 1 , maxGroups + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = 10 ** 9 NEW_LINE if ( j == 1 ) : NEW_LINE INDENT freq1 = dict ( ) NEW_LINE freqOfMode = 0 NEW_LINE for it in range ( 0 , i + 1 ) : NEW_LINE INDENT freq1 [ ar [ it ] ] = freq1 . get ( ar [ it ] , 0 ) + 1 NEW_LINE newElementFreq = freq1 [ ar [ it ] ] NEW_LINE if ( newElementFreq > freqOfMode ) : NEW_LINE INDENT freqOfMode = newElementFreq NEW_LINE DEDENT DEDENT dp [ i ] [ 1 ] = ( i + 1 ) - freqOfMode NEW_LINE DEDENT else : NEW_LINE INDENT freq = dict ( ) NEW_LINE freqOfMode = 0 NEW_LINE for it in range ( i , j - 2 , - 1 ) : NEW_LINE INDENT freq [ ar [ it ] ] = freq . get ( ar [ it ] , 0 ) + 1 NEW_LINE newElementFreq = freq [ ar [ it ] ] NEW_LINE if ( newElementFreq > freqOfMode ) : NEW_LINE INDENT freqOfMode = newElementFreq NEW_LINE DEDENT elementsToChange = i - it + 1 NEW_LINE elementsToChange -= freqOfMode NEW_LINE dp [ i ] [ j ] = min ( dp [ it - 1 ] [ j - 1 ] + elementsToChange , dp [ i ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return dp [ n - 1 ] [ k ] NEW_LINE DEDENT
def maxArea ( perimeter ) : NEW_LINE INDENT length = int ( ceil ( perimeter / 4 ) ) NEW_LINE breadth = int ( floor ( perimeter / 4 ) ) NEW_LINE return length * breadth NEW_LINE DEDENT
def getRemainder ( num , divisor ) : NEW_LINE INDENT return ( num - divisor * ( num // divisor ) ) NEW_LINE DEDENT
def isDivisible ( arr , n ) : NEW_LINE INDENT lastDigit = arr [ n - 1 ] % 10 ; NEW_LINE if ( lastDigit == 0 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT
def maxRepeating ( str ) : NEW_LINE INDENT l = len ( str ) NEW_LINE count = 0 NEW_LINE res = str [ 0 ] NEW_LINE for i in range ( l ) : NEW_LINE INDENT cur_count = 1 NEW_LINE for j in range ( i + 1 , l ) : NEW_LINE INDENT if ( str [ i ] != str [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT cur_count += 1 NEW_LINE DEDENT if cur_count > count : NEW_LINE INDENT count = cur_count NEW_LINE res = str [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def printFun ( test ) : NEW_LINE INDENT if ( test < 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT else : NEW_LINE INDENT print ( test , end = " ▁ " ) NEW_LINE printFun ( test - 1 ) NEW_LINE print ( test , end = " ▁ " ) NEW_LINE return NEW_LINE DEDENT DEDENT
def rainDayProbability ( a , n ) : NEW_LINE INDENT count = a . count ( 1 ) NEW_LINE m = count / n NEW_LINE return m NEW_LINE DEDENT
def minCost ( s ) : NEW_LINE INDENT alphabets = [ False for i in range ( 26 ) ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT alphabets [ ord ( s [ i ] ) - 97 ] = True NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ( alphabets [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def largestPower ( n , p ) : NEW_LINE INDENT x = 0 NEW_LINE while n : NEW_LINE INDENT n /= p NEW_LINE x += n NEW_LINE DEDENT return x NEW_LINE DEDENT
def hexadecagonalNum ( n ) : NEW_LINE INDENT return ( ( 14 * n * n ) - 12 * n ) // 2 NEW_LINE DEDENT
def calSum ( n ) : NEW_LINE INDENT a = 3 NEW_LINE b = 0 NEW_LINE c = 2 NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return 3 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 3 NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT return 5 NEW_LINE DEDENT sum = 5 NEW_LINE while ( n > 2 ) : NEW_LINE INDENT d = a + b NEW_LINE sum = sum + d NEW_LINE a = b NEW_LINE b = c NEW_LINE c = d NEW_LINE n = n - 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def SUM ( x , n ) : NEW_LINE INDENT total = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT total = total + ( ( x ** i ) / i ) NEW_LINE DEDENT return total NEW_LINE DEDENT
def max_sum ( a , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( 2 ) ] for j in range ( n + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 0 ; dp [ 0 ] [ 1 ] = - 999999 ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT dp [ i + 1 ] [ 0 ] = max ( dp [ i ] [ 0 ] + a [ i ] , dp [ i ] [ 1 ] - a [ i ] ) ; NEW_LINE dp [ i + 1 ] [ 1 ] = max ( dp [ i ] [ 0 ] - a [ i ] , dp [ i ] [ 1 ] + a [ i ] ) ; NEW_LINE DEDENT return dp [ n ] [ 0 ] ; NEW_LINE DEDENT
def minimumIncrease ( a , b , c ) : NEW_LINE INDENT arr = [ a , b , c ] NEW_LINE arr . sort ( ) NEW_LINE if arr [ 0 ] + arr [ 1 ] >= arr [ 2 ] : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return arr [ 2 ] - ( arr [ 0 ] + arr [ 1 ] ) NEW_LINE DEDENT DEDENT
def countPairs ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE for x in range ( 1 , n ) : NEW_LINE INDENT for y in range ( x + 1 , n + 1 ) : NEW_LINE INDENT if ( ( y + x ) % ( y ^ x ) == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT DEDENT return count ; NEW_LINE DEDENT
def sortString ( str ) : NEW_LINE INDENT str = ' ' . join ( sorted ( str ) ) NEW_LINE print ( str ) NEW_LINE DEDENT
def term ( n ) : NEW_LINE INDENT return n * ( n + 1 ) / 2 NEW_LINE DEDENT
def validateStackSequence ( pushed , popped ) : NEW_LINE INDENT j = 0 NEW_LINE stack = [ ] NEW_LINE for x in pushed : NEW_LINE INDENT stack . append ( x ) NEW_LINE while stack and j < len ( popped ) and stack [ - 1 ] == popped [ j ] : NEW_LINE INDENT stack . pop ( ) NEW_LINE j = j + 1 NEW_LINE DEDENT DEDENT return j == len ( popped ) NEW_LINE DEDENT
def getMinimumSum ( arr , n ) : NEW_LINE INDENT ans = sys . maxsize ; NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT for j in range ( i + 1 , n - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT ans = min ( ans , arr [ i ] + arr [ j ] + arr [ k ] ) ; NEW_LINE DEDENT DEDENT DEDENT return ans ; NEW_LINE DEDENT
def perfectCube ( N ) : NEW_LINE INDENT cube = 0 ; NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT cube = i * i * i ; NEW_LINE if ( cube == N ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE return ; NEW_LINE DEDENT elif ( cube > N ) : NEW_LINE INDENT print ( " NO " ) ; NEW_LINE return ; NEW_LINE DEDENT DEDENT DEDENT
def longest_gap ( N ) : NEW_LINE INDENT distance = 0 NEW_LINE count = 0 NEW_LINE first_1 = - 1 NEW_LINE last_1 = - 1 NEW_LINE while ( N > 0 ) : NEW_LINE INDENT count += 1 NEW_LINE r = N & 1 NEW_LINE if ( r == 1 ) : NEW_LINE INDENT if first_1 == - 1 : NEW_LINE INDENT first_1 = count NEW_LINE DEDENT else : NEW_LINE INDENT first_1 = first_1 NEW_LINE DEDENT last_1 = count NEW_LINE DEDENT N = N // 2 NEW_LINE DEDENT if ( last_1 <= first_1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT distance = last_1 - first_1 - 1 NEW_LINE return distance NEW_LINE DEDENT DEDENT
def findMaxValue ( arr , n ) : NEW_LINE INDENT if n < 4 : NEW_LINE INDENT print ( " The ▁ array ▁ should ▁ have ▁ atlest ▁ 4 ▁ elements " ) NEW_LINE return MIN NEW_LINE DEDENT table1 , table2 = [ MIN ] * ( n + 1 ) , [ MIN ] * n NEW_LINE table3 , table4 = [ MIN ] * ( n - 1 ) , [ MIN ] * ( n - 2 ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT table1 [ i ] = max ( table1 [ i + 1 ] , arr [ i ] ) NEW_LINE DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT table2 [ i ] = max ( table2 [ i + 1 ] , table1 [ i + 1 ] - arr [ i ] ) NEW_LINE DEDENT for i in range ( n - 3 , - 1 , - 1 ) : NEW_LINE INDENT table3 [ i ] = max ( table3 [ i + 1 ] , table2 [ i + 1 ] + arr [ i ] ) NEW_LINE DEDENT for i in range ( n - 4 , - 1 , - 1 ) : NEW_LINE INDENT table4 [ i ] = max ( table4 [ i + 1 ] , table3 [ i + 1 ] - arr [ i ] ) NEW_LINE DEDENT return table4 [ 0 ] NEW_LINE DEDENT
def squaresum ( n ) : NEW_LINE INDENT sm = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sm = sm + ( i * i ) NEW_LINE DEDENT return sm NEW_LINE DEDENT
def count ( arr ) : NEW_LINE INDENT diag1 = 0 ; diag2 = 0 ; row = 0 NEW_LINE col = 0 ; count = 0 ; j = n - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT diag1 += arr [ i ] [ i ] NEW_LINE diag2 += arr [ i ] [ j ] NEW_LINE j -= 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT row = 0 ; col = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT row += arr [ i ] [ j ] NEW_LINE DEDENT for j in range ( n ) : NEW_LINE INDENT col += arr [ j ] [ i ] NEW_LINE DEDENT if ( ( row == diag1 ) or ( row == diag2 ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( ( col == diag1 ) or ( col == diag2 ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def findMinDifference ( arr , n ) : NEW_LINE INDENT if ( arr [ 0 ] < arr [ 1 ] ) : NEW_LINE INDENT min__ = secondMax = arr [ 0 ] NEW_LINE DEDENT else : NEW_LINE INDENT min__ = secondMax = arr [ 1 ] NEW_LINE DEDENT if ( arr [ 0 ] < arr [ 1 ] ) : NEW_LINE INDENT max__ = secondMin = arr [ 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT max__ = secondMin = arr [ 0 ] NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if ( arr [ i ] > max__ ) : NEW_LINE INDENT secondMax = max__ NEW_LINE max__ = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > secondMax ) : NEW_LINE INDENT secondMax = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] < min__ ) : NEW_LINE INDENT secondMin = min__ NEW_LINE min__ = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] < secondMin ) : NEW_LINE INDENT secondMin = arr [ i ] NEW_LINE DEDENT DEDENT diff = min ( max__ - secondMin , secondMax - min__ ) NEW_LINE return diff NEW_LINE DEDENT
def minItems ( k , r ) : NEW_LINE INDENT for i in range ( 1 , 10 ) : NEW_LINE INDENT if ( ( i * k - r ) % 10 == 0 or ( i * k ) % 10 == 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return 10 ; NEW_LINE DEDENT
def max_intersection ( center , length , k ) : NEW_LINE INDENT center . sort ( ) ; NEW_LINE if ( center [ 2 ] - center [ 0 ] >= 2 * k + length ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT elif ( center [ 2 ] - center [ 0 ] >= 2 * k ) : NEW_LINE INDENT return ( 2 * k - ( center [ 2 ] - center [ 0 ] - length ) ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return length ; NEW_LINE DEDENT DEDENT
def maxProfit ( profitA , profitB , n ) : NEW_LINE INDENT preSum = [ 0 ] * n ; NEW_LINE preSum [ 0 ] = profitA [ 0 ] ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT preSum [ i ] = preSum [ i - 1 ] + profitA [ i ] ; NEW_LINE DEDENT suffSum = [ 0 ] * n ; NEW_LINE suffSum [ n - 1 ] = profitB [ n - 1 ] ; NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT suffSum [ i ] = suffSum [ i + 1 ] + profitB [ i ] ; NEW_LINE DEDENT res = preSum [ n - 1 ] ; NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT res = max ( res , preSum [ i ] + suffSum [ i + 1 ] ) ; NEW_LINE DEDENT res = max ( res , suffSum [ 0 ] ) ; NEW_LINE return res ; NEW_LINE DEDENT
def getMissingNo ( A ) : NEW_LINE INDENT n = len ( A ) NEW_LINE total = ( n + 1 ) * ( n + 2 ) / 2 NEW_LINE sum_of_A = sum ( A ) NEW_LINE return total - sum_of_A NEW_LINE DEDENT
def subArraySum ( arr , n , Sum ) : NEW_LINE INDENT Map = { } NEW_LINE curr_sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT curr_sum = curr_sum + arr [ i ] NEW_LINE if curr_sum == Sum : NEW_LINE INDENT print ( " Sum ▁ found ▁ between ▁ indexes ▁ 0 ▁ to " , i ) NEW_LINE return NEW_LINE DEDENT if ( curr_sum - Sum ) in Map : NEW_LINE INDENT print ( " Sum ▁ found ▁ between ▁ indexes " ,   \ Map [ curr_sum - Sum ] + 1 , " to " , i ) NEW_LINE return NEW_LINE DEDENT Map [ curr_sum ] = i NEW_LINE DEDENT print ( " No ▁ subarray ▁ with ▁ given ▁ sum ▁ exists " ) NEW_LINE DEDENT
def calTime ( arr , n ) : NEW_LINE INDENT work = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT work += 1 / arr [ i ] NEW_LINE DEDENT return 1 / work NEW_LINE DEDENT
def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while p * p <= MAX : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT i = p * 2 NEW_LINE while i <= MAX : NEW_LINE INDENT prime [ i ] = False NEW_LINE i += p NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT for i in range ( 1 , MAX + 1 ) : NEW_LINE INDENT if ( prime [ i ] == True ) : NEW_LINE INDENT sum [ i ] = 1 NEW_LINE DEDENT sum [ i ] += sum [ i - 1 ] NEW_LINE DEDENT DEDENT
def printDistinct ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT d = 0 NEW_LINE for j in range ( 0 , i ) : NEW_LINE INDENT if ( arr [ i ] == arr [ j ] ) : NEW_LINE INDENT d = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( d == 0 ) : NEW_LINE INDENT print ( arr [ i ] ) NEW_LINE DEDENT DEDENT DEDENT
def findMinimumX ( a , n ) : NEW_LINE INDENT st = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT st . add ( a [ i ] ) NEW_LINE DEDENT if ( len ( st ) == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( len ( st ) == 2 ) : NEW_LINE INDENT st = list ( st ) NEW_LINE el1 = st [ 0 ] NEW_LINE el2 = st [ 1 ] NEW_LINE if ( ( el2 - el1 ) % 2 == 0 ) : NEW_LINE INDENT return int ( ( el2 - el1 ) / 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( el2 - el1 ) NEW_LINE DEDENT DEDENT if ( len ( st ) == 3 ) : NEW_LINE INDENT st = list ( st ) NEW_LINE el1 = st [ 0 ] NEW_LINE el2 = st [ 1 ] NEW_LINE el3 = st [ 2 ] NEW_LINE if ( ( el2 - el1 ) == ( el3 - el2 ) ) : NEW_LINE INDENT return el2 - el1 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def grayCode ( n ) : NEW_LINE INDENT return n ^ ( n >> 1 ) NEW_LINE DEDENT
def oddEquivalent ( s , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return pow ( n , 2 ) - 2 * n + 2 NEW_LINE DEDENT
def findTriangles ( n ) : NEW_LINE INDENT num = n * ( n - 4 ) NEW_LINE print ( num ) NEW_LINE DEDENT
def removeRecur ( n ) : NEW_LINE INDENT prev_digit = n % 10 NEW_LINE pow = 10 NEW_LINE res = prev_digit NEW_LINE while ( n ) : NEW_LINE INDENT curr_digit = n % 10 NEW_LINE if ( curr_digit != prev_digit ) : NEW_LINE INDENT res += curr_digit * pow NEW_LINE prev_digit = curr_digit NEW_LINE pow *= 10 NEW_LINE DEDENT n = int ( n / 10 ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def countOddSquares ( n , m ) : NEW_LINE INDENT return ( int ( pow ( m , 0.5 ) ) - int ( pow ( n - 1 , 0.5 ) ) ) NEW_LINE DEDENT
def sumKRepeating ( arr , n , k ) : NEW_LINE INDENT Sum = 0 NEW_LINE mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in mp . keys ( ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT for x in mp : NEW_LINE INDENT if ( mp [ x ] == k ) : NEW_LINE INDENT Sum += x NEW_LINE DEDENT DEDENT return Sum NEW_LINE DEDENT
def findNumbers ( n , b ) : NEW_LINE INDENT even = 0 ; NEW_LINE odd = 0 ; NEW_LINE if ( b % 2 == 0 ) : NEW_LINE INDENT even = pow ( b , n ) - 2 ; NEW_LINE odd = pow ( b , n ) - 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT even = pow ( b , n ) - 1 ; NEW_LINE odd = pow ( b , n ) - 2 ; NEW_LINE DEDENT print ( " Even ▁ Number ▁ = ▁ " , int ( even ) ) ; NEW_LINE print ( " Odd ▁ Number ▁ = ▁ " , int ( odd ) ) ; NEW_LINE DEDENT
def pairORSum ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT ans = ans + ( arr [ i ] ^ arr [ j ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def CountSubSet ( arr , n , X ) : NEW_LINE INDENT N = 2 ** n ; NEW_LINE count = 0 ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( i & ( 1 << j ) ) : NEW_LINE INDENT if ( arr [ j ] == X ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT DEDENT DEDENT return count ; NEW_LINE DEDENT
def lis ( arr , n ) : NEW_LINE INDENT i , j , maxm = 0 , 0 , 0 NEW_LINE lst = [ 1 for s in range ( n ) ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 0 , i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and lst [ i ] < lst [ j ] + 1 ) : NEW_LINE INDENT lst [ i ] = lst [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if maxm < lst [ i ] : NEW_LINE INDENT maxm = lst [ i ] NEW_LINE DEDENT DEDENT return maxm NEW_LINE DEDENT
def distinctCount ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . add ( abs ( arr [ i ] ) ) NEW_LINE DEDENT return len ( s ) NEW_LINE DEDENT
def MaximumDivisors ( X , Y ) : NEW_LINE INDENT arr = [ 0 ] * ( Y - X + 1 ) NEW_LINE mx = 0 NEW_LINE cnt = 0 NEW_LINE i = 1 NEW_LINE while i * i <= Y : NEW_LINE INDENT sq = i * i NEW_LINE if ( ( X // i ) * i >= X ) : NEW_LINE INDENT first_divisible = ( X // i ) * i NEW_LINE DEDENT else : NEW_LINE INDENT first_divisible = ( X // i + 1 ) * i NEW_LINE DEDENT for j in range ( first_divisible , Y + 1 , i ) : NEW_LINE INDENT if j < sq : NEW_LINE INDENT continue NEW_LINE DEDENT elif j == sq : NEW_LINE INDENT arr [ j - X ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ j - X ] += 2 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT for i in range ( X , Y + 1 ) : NEW_LINE INDENT if arr [ i - X ] > mx : NEW_LINE INDENT cnt = 1 NEW_LINE mx = arr [ i - X ] NEW_LINE DEDENT elif arr [ i - X ] == mx : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
def printString ( n , str ) : NEW_LINE INDENT str2 = " " NEW_LINE extraChar = n % 26 NEW_LINE if ( extraChar >= 1 ) : NEW_LINE INDENT for i in range ( 26 - ( extraChar + 1 ) , 26 ) : NEW_LINE INDENT str2 += str [ i ] NEW_LINE DEDENT DEDENT countOfStr = n // 26 NEW_LINE for i in range ( 1 , countOfStr + 1 ) : NEW_LINE INDENT for j in range ( 26 ) : NEW_LINE INDENT str2 += str [ j ] NEW_LINE DEDENT DEDENT return str2 NEW_LINE DEDENT
def greaterK ( n , k ) : NEW_LINE INDENT index = 0 NEW_LINE p = [ 0 for i in range ( n + 2 ) ] NEW_LINE x = n NEW_LINE while ( x > 0 ) : NEW_LINE INDENT p [ index ] = x % k NEW_LINE x //= k NEW_LINE index += 1 NEW_LINE DEDENT idx = 0 NEW_LINE for i in range ( 0 , len ( p ) - 1 , 1 ) : NEW_LINE INDENT if ( p [ i ] >= 2 ) : NEW_LINE INDENT p [ i ] = 0 NEW_LINE p [ i + 1 ] += 1 NEW_LINE for j in range ( idx , i , 1 ) : NEW_LINE INDENT p [ j ] = 0 NEW_LINE DEDENT idx = i + 1 NEW_LINE DEDENT if ( p [ i ] == k ) : NEW_LINE INDENT p [ i ] = 0 NEW_LINE p [ i + 1 ] += 1 NEW_LINE DEDENT DEDENT j = len ( p ) - 1 NEW_LINE if ( p [ j ] >= 2 ) : NEW_LINE INDENT p [ index ] = 1 NEW_LINE index += 1 NEW_LINE DEDENT ans = 0 NEW_LINE i = len ( p ) - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT ans = ans * k + p [ i ] NEW_LINE i -= 1 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def line ( x0 , y0 ) : NEW_LINE INDENT c = 2 * y0 * x0 NEW_LINE print ( y0 , " x " , " + " , x0 , " y = " , c ) NEW_LINE DEDENT
def NthCharacter ( n ) : NEW_LINE INDENT s = " " NEW_LINE c = 1 NEW_LINE while ( True ) : NEW_LINE INDENT if ( c < 10 ) : NEW_LINE INDENT s += chr ( 48 + c ) NEW_LINE DEDENT else : NEW_LINE INDENT s1 = " " NEW_LINE dup = c NEW_LINE while ( dup > 0 ) : NEW_LINE INDENT s1 += chr ( ( dup % 10 ) + 48 ) NEW_LINE dup //= 10 NEW_LINE DEDENT s1 = " " . join ( reversed ( s1 ) ) NEW_LINE s += s1 NEW_LINE DEDENT c += 1 NEW_LINE if ( len ( s ) >= n ) : NEW_LINE INDENT return s [ n - 1 ] NEW_LINE DEDENT DEDENT DEDENT
def maxLength ( arr , N ) : NEW_LINE INDENT product = 1 NEW_LINE Len = 0 NEW_LINE for i in arr : NEW_LINE INDENT product *= i NEW_LINE DEDENT if ( product >= 0 ) : NEW_LINE INDENT return N NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT Len = max ( Len , max ( N - i - 1 , i ) ) NEW_LINE DEDENT DEDENT return Len NEW_LINE DEDENT
def countMultiples ( n ) : NEW_LINE INDENT return n / 3 + n / 7 - n / 21 ; NEW_LINE DEDENT
def maxEdges ( N ) : NEW_LINE INDENT edges = 0 ; NEW_LINE edges = ( N * N ) // 4 ; NEW_LINE return edges ; NEW_LINE DEDENT
def printSum ( m , s , n ) : NEW_LINE INDENT total = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT total += s [ i ] NEW_LINE total += ( m [ i ] * 60 ) NEW_LINE DEDENT print ( int ( total / 3600 ) , end = " ▁ : ▁ " ) NEW_LINE total %= 3600 NEW_LINE print ( int ( total / 60 ) , end = " : ▁ " ) NEW_LINE total %= 60 NEW_LINE print ( int ( total ) ) NEW_LINE DEDENT
def findEle ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if arr [ i ] == sum - arr [ i ] : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def findTriangles ( n ) : NEW_LINE INDENT num = n NEW_LINE print ( num , end = " ▁ " ) NEW_LINE print ( num * ( num - 4 ) * ( num - 5 ) // 6 ) NEW_LINE DEDENT
def center_nonadecagon_num ( n ) : NEW_LINE INDENT return ( 19 * n * n - 19 * n + 2 ) // 2 NEW_LINE DEDENT
def minReplacement ( string ) : NEW_LINE INDENT if len ( string ) > 26 : NEW_LINE INDENT print ( " IMPOSSIBLE " ) NEW_LINE DEDENT else : NEW_LINE INDENT Hash = [ 0 ] * 26 NEW_LINE for i in range ( 0 , len ( string ) ) : NEW_LINE INDENT Hash [ ord ( string [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( 0 , len ( string ) ) : NEW_LINE INDENT if Hash [ ord ( string [ i ] ) - ord ( ' a ' ) ] > 1 : NEW_LINE INDENT for j in range ( 0 , 26 ) : NEW_LINE INDENT if Hash [ j ] == 0 : NEW_LINE INDENT Hash [ ord ( string [ i ] ) - ord ( ' a ' ) ] -= 1 NEW_LINE string [ i ] = chr ( j + ord ( ' a ' ) ) NEW_LINE Hash [ j ] += 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( ' ' . join ( string ) ) NEW_LINE DEDENT DEDENT
def check ( n , x , y ) : NEW_LINE INDENT fact = 1 ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT fact *= i ; NEW_LINE DEDENT divisor = x ** y ; NEW_LINE if ( fact % divisor == 0 ) : NEW_LINE INDENT print ( " YES " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) ; NEW_LINE DEDENT DEDENT
def no_of_ways ( a , n ) : NEW_LINE INDENT count_0 = 0 NEW_LINE count_1 = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( a [ i ] == 0 ) : NEW_LINE INDENT count_0 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_1 += 1 NEW_LINE DEDENT DEDENT if ( count_1 % 2 == 0 ) : NEW_LINE INDENT return count_0 NEW_LINE DEDENT else : NEW_LINE INDENT return count_1 NEW_LINE DEDENT DEDENT
def findNth ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE curr = 19 ; NEW_LINE while ( True ) : NEW_LINE INDENT sum = 0 ; NEW_LINE x = curr ; NEW_LINE while ( x > 0 ) : NEW_LINE INDENT sum = sum + x % 10 ; NEW_LINE x = int ( x / 10 ) ; NEW_LINE DEDENT if ( sum == 10 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT if ( count == n ) : NEW_LINE INDENT return curr ; NEW_LINE DEDENT curr += 9 ; NEW_LINE DEDENT return - 1 ; NEW_LINE DEDENT
def calcProbability ( M , k ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n ) ] for i in range ( m ) ] NEW_LINE Sum = [ 0 for i in range ( n ) ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT dp [ 0 ] [ j ] = M [ 0 ] [ j ] NEW_LINE Sum [ 0 ] += dp [ 0 ] [ j ] NEW_LINE DEDENT for i in range ( 1 , m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT dp [ i ] [ j ] += ( dp [ i - 1 ] [ j ] / Sum [ i - 1 ] + M [ i ] [ j ] ) NEW_LINE Sum [ i ] += dp [ i ] [ j ] NEW_LINE DEDENT DEDENT return dp [ n - 1 ] [ k - 1 ] / Sum [ n - 1 ] NEW_LINE DEDENT
def kFactors ( n , k ) : NEW_LINE INDENT a = list ( ) NEW_LINE while n % 2 == 0 : NEW_LINE INDENT a . append ( 2 ) NEW_LINE n = n // 2 NEW_LINE DEDENT for i in range ( 3 , mt . ceil ( mt . sqrt ( n ) ) , 2 ) : NEW_LINE INDENT while n % i == 0 : NEW_LINE INDENT n = n / i ; NEW_LINE a . append ( i ) NEW_LINE DEDENT DEDENT if n > 2 : NEW_LINE INDENT a . append ( n ) NEW_LINE DEDENT if len ( a ) < k : NEW_LINE INDENT print ( " - 1" ) NEW_LINE return NEW_LINE DEDENT for i in range ( k - 1 ) : NEW_LINE INDENT print ( a [ i ] , end = " , ▁ " ) NEW_LINE DEDENT product = 1 NEW_LINE for i in range ( k - 1 , len ( a ) ) : NEW_LINE INDENT product *= a [ i ] NEW_LINE DEDENT print ( product ) NEW_LINE DEDENT
def isSumOfPowersOfTwo ( n ) : NEW_LINE INDENT if n % 2 == 1 : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT
def findNumbers ( arr , n ) : NEW_LINE INDENT sumN = ( n * ( n + 1 ) ) / 2 ; NEW_LINE sumSqN = ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; NEW_LINE sum = 0 ; NEW_LINE sumSq = 0 ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum = sum + arr [ i ] ; NEW_LINE sumSq = sumSq + ( math . pow ( arr [ i ] , 2 ) ) ; NEW_LINE DEDENT B = ( ( ( sumSq - sumSqN ) / ( sum - sumN ) ) + sumN - sum ) / 2 ; NEW_LINE A = sum - sumN + B ; NEW_LINE print ( " A ▁ = ▁ " , int ( A ) ) ; NEW_LINE print ( " B ▁ = ▁ " , int ( B ) ) ; NEW_LINE DEDENT
def sumOfDivisblePowers ( L , R , P ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( L , R + 1 ) : NEW_LINE INDENT x = i NEW_LINE while ( x % P == 0 ) : NEW_LINE INDENT res += 1 NEW_LINE x /= P NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def pell ( n ) : NEW_LINE INDENT if ( n <= 2 ) : NEW_LINE INDENT return n NEW_LINE DEDENT return ( 2 * pell ( n - 1 ) + pell ( n - 2 ) ) NEW_LINE DEDENT
def countSubArrays ( arr , n , K ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT bitwise_or = 0 NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT bitwise_or = bitwise_or | arr [ k ] NEW_LINE DEDENT if ( bitwise_or >= K ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def countNumber ( n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT s = [ ] NEW_LINE if ( i <= n ) : NEW_LINE INDENT s . append ( i ) NEW_LINE result += 1 NEW_LINE DEDENT while len ( s ) != 0 : NEW_LINE INDENT tp = s [ - 1 ] NEW_LINE s . pop ( ) NEW_LINE for j in range ( tp % 10 , 10 ) : NEW_LINE INDENT x = tp * 10 + j NEW_LINE if ( x <= n ) : NEW_LINE INDENT s . append ( x ) NEW_LINE result += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def findMaxDiff ( arr , n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT print ( " Invalid ▁ " ) NEW_LINE return 0 NEW_LINE DEDENT res = - 2147483648 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( res < ( arr [ i ] - arr [ j ] - i + j ) ) : NEW_LINE INDENT res = ( arr [ i ] - arr [ j ] - i + j ) NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
def fun ( marks , n ) : NEW_LINE INDENT dp = [ 1 for i in range ( 0 , n ) ] NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if marks [ i ] > marks [ i + 1 ] : NEW_LINE INDENT temp = i NEW_LINE while True : NEW_LINE INDENT if marks [ temp ] > marks [ temp + 1 ] and temp >= 0 : NEW_LINE INDENT if dp [ temp ] > dp [ temp + 1 ] : NEW_LINE INDENT temp -= 1 NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT dp [ temp ] = dp [ temp + 1 ] + 1 NEW_LINE temp -= 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT elif marks [ i ] < marks [ i + 1 ] : NEW_LINE INDENT dp [ i + 1 ] = dp [ i ] + 1 NEW_LINE DEDENT DEDENT return ( sum ( dp ) ) NEW_LINE DEDENT
def maxLen ( arr , n ) : NEW_LINE INDENT min_val = min ( arr ) ; NEW_LINE freq = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == min_val ) : NEW_LINE INDENT freq += 1 ; NEW_LINE DEDENT DEDENT return freq ; NEW_LINE DEDENT
def normal ( m , n ) : NEW_LINE INDENT N = ( ( abs ( m ) * abs ( n ) ) / math . sqrt ( ( abs ( m ) * abs ( m ) ) + ( abs ( n ) * abs ( n ) ) ) ) ; NEW_LINE return N ; NEW_LINE DEDENT
def findNumber ( arr , n ) : NEW_LINE INDENT arr = sorted ( arr ) NEW_LINE Max = arr [ n - 1 ] NEW_LINE table = [ 10 ** 9 for i in range ( ( 2 * Max ) + 1 ) ] NEW_LINE table [ 0 ] = 0 NEW_LINE ans = - 1 NEW_LINE for i in range ( 1 , 2 * Max + 1 ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( arr [ j ] <= i ) : NEW_LINE INDENT res = table [ i - arr [ j ] ] NEW_LINE if ( res != 10 ** 9 and res + 1 < table [ i ] ) : NEW_LINE INDENT table [ i ] = res + 1 NEW_LINE DEDENT DEDENT DEDENT if ( i > arr [ n - 1 ] and table [ i ] == 10 ** 9 ) : NEW_LINE INDENT ans = i NEW_LINE break NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def setBitNumber ( n ) : NEW_LINE INDENT n |= n >> 1 NEW_LINE n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 8 NEW_LINE n |= n >> 16 NEW_LINE n = n + 1 NEW_LINE return ( n >> 1 ) NEW_LINE DEDENT
def permutatedRows ( mat , m , n , r ) : NEW_LINE INDENT s = set ( ) NEW_LINE for j in range ( n ) : NEW_LINE INDENT s . add ( mat [ r ] [ j ] ) NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT if i == r : NEW_LINE INDENT continue NEW_LINE DEDENT for j in range ( n ) : NEW_LINE INDENT if mat [ i ] [ j ] not in s : NEW_LINE INDENT j = j - 2 NEW_LINE break ; NEW_LINE DEDENT DEDENT if j + 1 != n : NEW_LINE INDENT continue NEW_LINE DEDENT print ( i ) NEW_LINE DEDENT DEDENT
def findMajority ( arr , n ) : NEW_LINE INDENT maxCount = 0 ; NEW_LINE index = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == arr [ j ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count > maxCount ) : NEW_LINE INDENT maxCount = count NEW_LINE index = i NEW_LINE DEDENT DEDENT if ( maxCount > n // 2 ) : NEW_LINE INDENT print ( arr [ index ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ Majority ▁ Element " ) NEW_LINE DEDENT DEDENT
def printSubArrays ( arr , start , end ) : NEW_LINE INDENT if end == len ( arr ) : NEW_LINE INDENT return NEW_LINE DEDENT elif start > end : NEW_LINE INDENT return printSubArrays ( arr , 0 , end + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( arr [ start : end + 1 ] ) NEW_LINE return printSubArrays ( arr , start + 1 , end ) NEW_LINE DEDENT DEDENT
def multipleOfThree ( K , dig0 , dig1 ) : NEW_LINE INDENT sum = 0 NEW_LINE temp = ( dig0 + dig1 ) % 10 NEW_LINE sum = dig0 + dig1 NEW_LINE if ( K == 2 ) : NEW_LINE INDENT if ( sum % 3 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT sum += temp NEW_LINE numberofGroups = ( K - 3 ) // 4 NEW_LINE remNumberofDigits = ( K - 3 ) % 4 NEW_LINE sum += ( numberofGroups * 20 ) NEW_LINE for i in range ( remNumberofDigits ) : NEW_LINE INDENT temp = ( 2 * temp ) % 10 NEW_LINE sum += temp NEW_LINE DEDENT if ( sum % 3 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def countDigit ( n ) : NEW_LINE INDENT prime = [ False ] * 10 NEW_LINE prime [ 2 ] = True NEW_LINE prime [ 3 ] = True ; NEW_LINE prime [ 5 ] = True NEW_LINE prime [ 7 ] = True ; NEW_LINE temp = n NEW_LINE count = 0 ; NEW_LINE while ( temp != 0 ) : NEW_LINE INDENT d = temp % 10 ; NEW_LINE temp //= 10 ; NEW_LINE if ( d > 0 and n % d == 0 and prime [ d ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def getSum ( n , d ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT if ( i % 10 == d ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def Valid ( a , b , c ) : NEW_LINE INDENT if ( ( a + b + c == 180 ) and a != 0 and b != 0 and c != 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def minOperations ( a , n , K ) : NEW_LINE INDENT map = dict . fromkeys ( a , 0 ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( map [ a [ i ] ] ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT map [ a [ i ] ] = True ; NEW_LINE DEDENT b = [ 0 ] * n ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT b [ i ] = a [ i ] | K ; NEW_LINE DEDENT map . clear ( ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] != b [ i ] ) : NEW_LINE INDENT map [ b [ i ] ] = True ; NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if a [ i ] not in map : NEW_LINE INDENT pass NEW_LINE DEDENT elif ( map [ a [ i ] ] ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT DEDENT map . clear ( ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( map [ b [ i ] ] ) : NEW_LINE INDENT return 2 ; NEW_LINE DEDENT map [ b [ i ] ] = true ; NEW_LINE DEDENT return - 1 ; NEW_LINE DEDENT
def square ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT x = 0.464 * a NEW_LINE return x NEW_LINE DEDENT
def getModulo ( n , d ) : NEW_LINE INDENT return ( n & ( d - 1 ) ) NEW_LINE DEDENT
def sumOfLastDig ( n , m ) : NEW_LINE INDENT sum = 0 ; NEW_LINE k = n // m ; NEW_LINE arr = [ 0 ] * 10 ; NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT arr [ i ] = m * ( i + 1 ) % 10 ; NEW_LINE sum += arr [ i ] ; NEW_LINE DEDENT rem = k % 10 ; NEW_LINE ans = ( k // 10 ) * sum ; NEW_LINE for i in range ( rem ) : NEW_LINE INDENT ans += arr [ i ] ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT
def Prime ( arr , n ) : NEW_LINE INDENT max_val = max ( arr ) NEW_LINE prime = [ True for i in range ( max_val + 1 ) ] NEW_LINE prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , mt . ceil ( mt . sqrt ( max_val ) ) ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( 2 * p , max_val + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT minimum = 10 ** 9 NEW_LINE maximum = - 10 ** 9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] == True ) : NEW_LINE INDENT minimum = min ( minimum , arr [ i ] ) NEW_LINE maximum = max ( maximum , arr [ i ] ) NEW_LINE DEDENT DEDENT print ( " Minimum ▁ : ▁ " , minimum ) NEW_LINE print ( " Maximum ▁ : ▁ " , maximum ) NEW_LINE DEDENT
def isPower ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT for x in range ( 2 , ( int ) ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT p = x NEW_LINE while ( p <= n ) : NEW_LINE INDENT p = p * x NEW_LINE if ( p == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
def isRotation ( x , y ) : NEW_LINE INDENT x64 = x | ( x << 32 ) NEW_LINE while ( x64 >= y ) : NEW_LINE INDENT if ( ( x64 ) == y ) : NEW_LINE INDENT return True NEW_LINE DEDENT x64 >>= 1 NEW_LINE DEDENT return False NEW_LINE DEDENT
def mod ( num , a ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , len ( num ) ) : NEW_LINE INDENT res = ( res * 10 + int ( num [ i ] ) ) % a ; NEW_LINE DEDENT return res NEW_LINE DEDENT
def printRepeating ( arr , size ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( size ) : NEW_LINE INDENT if arr [ i ] not in s : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE DEDENT DEDENT for i in s : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def isDefeat ( s1 , s2 , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( ( s1 [ i ] == '0' and s2 [ i ] == '1' ) or ( s1 [ i ] == '1' and s2 [ i ] == '0' ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT elif ( ( s1 [ i ] == '0' and s2 [ i ] == ' Z ' ) or ( s1 [ i ] == ' Z ' and s2 [ i ] == '0' ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def getInvCount ( arr , n ) : NEW_LINE INDENT inv_count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] ) : NEW_LINE INDENT inv_count += 1 NEW_LINE DEDENT DEDENT DEDENT return inv_count NEW_LINE DEDENT
def KthMinValAfterMconcatenate ( A , N , M , K ) : NEW_LINE INDENT V = [ ] NEW_LINE for i in range ( 0 , M ) : NEW_LINE INDENT for j in range ( 0 , N ) : NEW_LINE INDENT V . append ( A [ j ] ) NEW_LINE DEDENT DEDENT V . sort ( ) NEW_LINE return V [ K - 1 ] NEW_LINE DEDENT
def findNum ( div , rem , N ) : NEW_LINE INDENT num = rem [ N - 1 ] NEW_LINE i = N - 2 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT num = num * div [ i ] + rem [ i ] NEW_LINE i -= 1 NEW_LINE DEDENT return num NEW_LINE DEDENT
def printGP ( a , r , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT curr_term = a * pow ( r , i ) NEW_LINE print ( curr_term , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def MinimumCost ( a , n , x ) : NEW_LINE INDENT for i in range ( 1 , n , 1 ) : NEW_LINE INDENT a [ i ] = min ( a [ i ] , 2 * a [ i - 1 ] ) NEW_LINE DEDENT ind = 0 NEW_LINE sum = 0 NEW_LINE while ( x ) : NEW_LINE INDENT if ( x & 1 ) : NEW_LINE INDENT sum += a [ ind ] NEW_LINE DEDENT ind += 1 NEW_LINE x = x >> 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def possibleToReach ( a , b ) : NEW_LINE INDENT c = np . cbrt ( a * b ) NEW_LINE re1 = a // c NEW_LINE re2 = b // c NEW_LINE if ( ( re1 * re1 * re2 == a ) and ( re2 * re2 * re1 == b ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def Time ( arr , n , Emptypipe ) : NEW_LINE INDENT fill = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT fill += ( 1 / arr [ i ] ) NEW_LINE DEDENT fill = fill - ( 1 / float ( Emptypipe ) ) NEW_LINE return int ( 1 / fill ) NEW_LINE DEDENT
def findMissing ( arr , n , k , avg ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] ; NEW_LINE DEDENT num = ( avg * ( n + k ) ) - sum ; NEW_LINE den = k ; NEW_LINE if ( num % den != 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT return ( int ) ( num / den ) ; NEW_LINE DEDENT
def last_digit ( X , Y ) : NEW_LINE INDENT print ( X % Y ) ; NEW_LINE DEDENT
def max_element ( a , n ) : NEW_LINE INDENT pre = [ 0 ] * n ; NEW_LINE pre [ 0 ] = a [ 0 ] ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT pre [ i ] = max ( pre [ i - 1 ] , a [ i ] ) ; NEW_LINE DEDENT suf = [ 0 ] * n ; NEW_LINE suf [ n - 1 ] = a [ n - 1 ] ; NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT suf [ i ] = max ( suf [ i + 1 ] , a [ i ] ) ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT print ( suf [ i + 1 ] , end = " ▁ " ) ; NEW_LINE DEDENT elif ( i == n - 1 ) : NEW_LINE INDENT print ( pre [ i - 1 ] , end = " ▁ " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( max ( pre [ i - 1 ] , suf [ i + 1 ] ) , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT DEDENT
def checkSubarraySum ( arr , n , k , sum ) : NEW_LINE INDENT for i in range ( n - k + 1 ) : NEW_LINE INDENT current_sum = 0 ; NEW_LINE for j in range ( k ) : NEW_LINE INDENT current_sum = ( current_sum + arr [ i + j ] ) ; NEW_LINE DEDENT if ( current_sum == sum ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT return False ; NEW_LINE DEDENT
def Area ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT h = 1.268 * a NEW_LINE A = 0.70477 * math . pow ( h , 2 ) NEW_LINE return A NEW_LINE DEDENT
def operations ( op , n , k ) : NEW_LINE INDENT i , count = 0 , 0 NEW_LINE nVal = 0 NEW_LINE minimum = 10 ** 9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT nVal += op [ i ] NEW_LINE minimum = min ( minimum , nVal ) NEW_LINE if ( ( k + nVal ) <= 0 ) : NEW_LINE INDENT return ( i + 1 ) NEW_LINE DEDENT DEDENT if ( nVal >= 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT times = ( k - abs ( minimum ) ) // abs ( nVal ) NEW_LINE k = ( k - ( times * abs ( nVal ) ) ) NEW_LINE count = ( times * n ) NEW_LINE while ( k > 0 ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT k = k + op [ i ] NEW_LINE count += 1 NEW_LINE if ( k <= 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def getOccurence ( n , d ) : NEW_LINE INDENT result = 0 ; NEW_LINE itr = d ; NEW_LINE while ( itr <= n ) : NEW_LINE INDENT if ( itr % 10 == d ) : NEW_LINE INDENT result += 1 ; NEW_LINE DEDENT if ( itr != 0 and math . floor ( itr / 10 ) == d ) : NEW_LINE INDENT result += 1 ; NEW_LINE itr += 1 ; NEW_LINE DEDENT elif ( math . floor ( itr / 10 ) == d - 1 ) : NEW_LINE INDENT itr = itr + ( 10 - d ) ; NEW_LINE DEDENT else : NEW_LINE INDENT itr = itr + 10 ; NEW_LINE DEDENT DEDENT return result ; NEW_LINE DEDENT
def countSequences ( arr , n ) : NEW_LINE INDENT count = 1 NEW_LINE arr . sort ( ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( arr [ i ] + 1 != arr [ i + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def find ( n , k ) : NEW_LINE INDENT if ( n + 1 >= k ) : NEW_LINE INDENT return ( k - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( 2 * n + 1 - k ) NEW_LINE DEDENT DEDENT
def interLeaveQueue ( q ) : NEW_LINE INDENT if ( q . qsize ( ) % 2 != 0 ) : NEW_LINE INDENT print ( " Input ▁ even ▁ number ▁ of ▁ integers . " ) NEW_LINE DEDENT s = [ ] NEW_LINE halfSize = int ( q . qsize ( ) / 2 ) NEW_LINE for i in range ( halfSize ) : NEW_LINE INDENT s . append ( q . queue [ 0 ] ) NEW_LINE q . get ( ) NEW_LINE DEDENT while len ( s ) != 0 : NEW_LINE INDENT q . put ( s [ - 1 ] ) NEW_LINE s . pop ( ) NEW_LINE DEDENT for i in range ( halfSize ) : NEW_LINE INDENT q . put ( q . queue [ 0 ] ) NEW_LINE q . get ( ) NEW_LINE DEDENT for i in range ( halfSize ) : NEW_LINE INDENT s . append ( q . queue [ 0 ] ) NEW_LINE q . get ( ) NEW_LINE DEDENT while len ( s ) != 0 : NEW_LINE INDENT q . put ( s [ - 1 ] ) NEW_LINE s . pop ( ) NEW_LINE q . put ( q . queue [ 0 ] ) NEW_LINE q . get ( ) NEW_LINE DEDENT DEDENT
def divisibleBy36 ( num ) : NEW_LINE INDENT l = len ( num ) NEW_LINE if ( l == 0 ) : NEW_LINE INDENT return ( " No " ) NEW_LINE DEDENT if ( l == 1 and num [ 0 ] != '0' ) : NEW_LINE INDENT return ( " No " ) NEW_LINE DEDENT two_digit_num = ( ( ( int ) ( num [ l - 2 ] ) ) * 10 + ( int ) ( num [ l - 1 ] ) ) NEW_LINE if ( two_digit_num % 4 != 0 ) : NEW_LINE INDENT return " No " NEW_LINE DEDENT sm = 0 NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT sm = sm + ( int ) ( num [ i ] ) NEW_LINE DEDENT if ( sm % 9 != 0 ) : NEW_LINE INDENT return ( " No " ) NEW_LINE DEDENT return ( " Yes " ) NEW_LINE DEDENT
def countWays ( n , m ) : NEW_LINE INDENT count = [ ] NEW_LINE for i in range ( n + 2 ) : NEW_LINE INDENT count . append ( 0 ) NEW_LINE DEDENT count [ 0 ] = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i > m ) : NEW_LINE INDENT count [ i ] = count [ i - 1 ] + count [ i - m ] NEW_LINE DEDENT elif ( i < m ) : NEW_LINE INDENT count [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT count [ i ] = 2 NEW_LINE DEDENT DEDENT return count [ n ] NEW_LINE DEDENT
def countReduce ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE res = 0 NEW_LINE for i in range ( 0 , int ( n / 2 ) ) : NEW_LINE INDENT res += abs ( int ( ord ( str [ i ] ) ) - int ( ord ( str [ n - i - 1 ] ) ) ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT n &= ( n - 1 ) NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def countSubstr ( s , k ) : NEW_LINE INDENT n = len ( s ) NEW_LINE l = n - 1 NEW_LINE r = n - 1 NEW_LINE arr = [ 0 ] * n NEW_LINE last_indexof1 = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT arr [ i ] = i NEW_LINE last_indexof1 = i NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = last_indexof1 NEW_LINE DEDENT DEDENT no_of_substr = 0 NEW_LINE for r in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT l = r NEW_LINE while ( l >= 0 and ( r - l + 1 ) <= 64 and int ( s [ l : r + 1 ] , 2 ) < k ) : NEW_LINE INDENT l -= 1 NEW_LINE DEDENT if ( r - l + 1 <= 64 ) : NEW_LINE INDENT no_of_substr += l + 1 NEW_LINE DEDENT else : NEW_LINE INDENT no_of_substr += arr [ l + 1 ] + 1 NEW_LINE DEDENT DEDENT return no_of_substr NEW_LINE DEDENT
def lehmann ( n , t ) : NEW_LINE INDENT a = random . randint ( 2 , n - 1 ) NEW_LINE e = ( n - 1 ) / 2 NEW_LINE while ( t > 0 ) : NEW_LINE INDENT result = ( ( int ) ( a ** e ) ) % n NEW_LINE if ( ( result % n ) == 1 or ( result % n ) == ( n - 1 ) ) : NEW_LINE INDENT a = random . randint ( 2 , n - 1 ) NEW_LINE t -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT
def isLucky ( n ) : NEW_LINE INDENT ar = [ 0 ] * 10 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT digit = math . floor ( n % 10 ) NEW_LINE if ( ar [ digit ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ar [ digit ] = 1 NEW_LINE n = n / 10 NEW_LINE DEDENT return 1 NEW_LINE DEDENT
def check ( k , d0 , d1 ) : NEW_LINE INDENT s = ( ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 + ( 8 * ( d0 + d1 ) ) % 10 + ( 6 * ( d0 + d1 ) ) % 10 ) NEW_LINE a = ( k - 3 ) % 4 NEW_LINE if ( a == 0 ) : NEW_LINE INDENT x = 0 NEW_LINE DEDENT elif ( a == 1 ) : NEW_LINE INDENT x = ( 2 * ( d0 + d1 ) ) % 10 NEW_LINE DEDENT elif ( a == 2 ) : NEW_LINE INDENT x = ( ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 ) NEW_LINE DEDENT elif ( a == 3 ) : NEW_LINE INDENT x = ( ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 + ( 8 * ( d0 + d1 ) ) % 10 ) NEW_LINE DEDENT sum = d0 + d1 + ( ( k - 3 ) // 4 ) * s + x NEW_LINE if ( sum % 3 == 0 ) : NEW_LINE INDENT return " YES " NEW_LINE DEDENT else : NEW_LINE INDENT return " NO " NEW_LINE DEDENT DEDENT
def eggDrop ( n , k ) : NEW_LINE INDENT if ( k == 1 or k == 0 ) : NEW_LINE INDENT return k NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return k NEW_LINE DEDENT min = sys . maxsize NEW_LINE for x in range ( 1 , k + 1 ) : NEW_LINE INDENT res = max ( eggDrop ( n - 1 , x - 1 ) , eggDrop ( n , k - x ) ) NEW_LINE if ( res < min ) : NEW_LINE INDENT min = res NEW_LINE DEDENT DEDENT return min + 1 NEW_LINE DEDENT
def allBitsSetInTheGivenRange ( n , l , r ) : NEW_LINE INDENT num = ( ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ) NEW_LINE new_num = n & num NEW_LINE if ( new_num == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return false NEW_LINE DEDENT
def count ( n ) : NEW_LINE INDENT table = [ 0 for i in range ( n + 1 ) ] NEW_LINE table [ 0 ] = 1 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT table [ i ] += table [ i - 3 ] NEW_LINE DEDENT for i in range ( 5 , n + 1 ) : NEW_LINE INDENT table [ i ] += table [ i - 5 ] NEW_LINE DEDENT for i in range ( 10 , n + 1 ) : NEW_LINE INDENT table [ i ] += table [ i - 10 ] NEW_LINE DEDENT return table [ n ] NEW_LINE DEDENT
def addOne ( x ) : NEW_LINE INDENT m = 1 ; NEW_LINE while ( x & m ) : NEW_LINE INDENT x = x ^ m NEW_LINE m <<= 1 NEW_LINE DEDENT x = x ^ m NEW_LINE return x NEW_LINE DEDENT
def countNumberOfTriangles ( n ) : NEW_LINE INDENT return ( n * ( n - 1 ) * ( n - 2 ) // 6 ) NEW_LINE DEDENT
def polygonArea ( X , Y , n ) : NEW_LINE INDENT area = 0.0 NEW_LINE j = n - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) NEW_LINE j = i NEW_LINE DEDENT return int ( abs ( area / 2.0 ) ) NEW_LINE DEDENT
def countMinimumMoves ( arr , n , k ) : NEW_LINE INDENT for i in range ( k - 1 , n ) : NEW_LINE INDENT if ( arr [ i ] != arr [ k - 1 ] ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT for i in range ( k - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] != arr [ k - 1 ] ) : NEW_LINE INDENT return i + 1 NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT
def findSubString ( string , pat ) : NEW_LINE INDENT len1 = len ( string ) NEW_LINE len2 = len ( pat ) NEW_LINE if len1 < len2 : NEW_LINE INDENT print ( " No ▁ such ▁ window ▁ exists " ) NEW_LINE return " " NEW_LINE DEDENT hash_pat = [ 0 ] * no_of_chars NEW_LINE hash_str = [ 0 ] * no_of_chars NEW_LINE for i in range ( 0 , len2 ) : NEW_LINE INDENT hash_pat [ ord ( pat [ i ] ) ] += 1 NEW_LINE DEDENT start , start_index , min_len = 0 , - 1 , float ( ' inf ' ) NEW_LINE count = 0 NEW_LINE for j in range ( 0 , len1 ) : NEW_LINE INDENT hash_str [ ord ( string [ j ] ) ] += 1 NEW_LINE if ( hash_pat [ ord ( string [ j ] ) ] != 0 and hash_str [ ord ( string [ j ] ) ] <= hash_pat [ ord ( string [ j ] ) ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if count == len2 : NEW_LINE INDENT while ( hash_str [ ord ( string [ start ] ) ] > hash_pat [ ord ( string [ start ] ) ] or hash_pat [ ord ( string [ start ] ) ] == 0 ) : NEW_LINE INDENT if ( hash_str [ ord ( string [ start ] ) ] > hash_pat [ ord ( string [ start ] ) ] ) : NEW_LINE INDENT hash_str [ ord ( string [ start ] ) ] -= 1 NEW_LINE DEDENT start += 1 NEW_LINE DEDENT len_window = j - start + 1 NEW_LINE if min_len > len_window : NEW_LINE INDENT min_len = len_window NEW_LINE start_index = start NEW_LINE DEDENT DEDENT DEDENT if start_index == - 1 : NEW_LINE INDENT print ( " No ▁ such ▁ window ▁ exists " ) NEW_LINE return " " NEW_LINE DEDENT return string [ start_index : start_index + min_len ] NEW_LINE DEDENT
def countDigit ( n ) : NEW_LINE INDENT temp = n NEW_LINE sum = 0 NEW_LINE product = 1 NEW_LINE while ( temp != 0 ) : NEW_LINE INDENT d = temp % 10 NEW_LINE temp //= 10 NEW_LINE if ( d > 0 and n % d == 0 ) : NEW_LINE INDENT sum += d NEW_LINE product *= d NEW_LINE DEDENT DEDENT print ( " Sum ▁ = " , sum ) NEW_LINE print ( " Product ▁ = " , product ) NEW_LINE DEDENT
def countPairs ( str1 ) : NEW_LINE INDENT result = 0 ; NEW_LINE n = len ( str1 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( abs ( ord ( str1 [ i ] ) - ord ( str1 [ j ] ) ) == abs ( i - j ) ) : NEW_LINE INDENT result += 1 ; NEW_LINE DEDENT DEDENT DEDENT return result ; NEW_LINE DEDENT
def checkplusperfect ( x ) : NEW_LINE INDENT temp = x NEW_LINE n = 0 NEW_LINE while ( x != 0 ) : NEW_LINE INDENT x = x // 10 NEW_LINE n = n + 1 NEW_LINE DEDENT x = temp NEW_LINE sm = 0 NEW_LINE while ( x != 0 ) : NEW_LINE INDENT sm = sm + ( int ) ( math . pow ( x % 10 , n ) ) NEW_LINE x = x // 10 NEW_LINE DEDENT return ( sm == temp ) NEW_LINE DEDENT
def countIntersections ( n ) : NEW_LINE INDENT return n * ( n - 1 ) // 2 NEW_LINE DEDENT
def maxSortedAdjacentDiff ( arr , n ) : NEW_LINE INDENT maxVal , minVal = arr [ 0 ] , arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT maxVal = max ( maxVal , arr [ i ] ) NEW_LINE minVal = min ( minVal , arr [ i ] ) NEW_LINE DEDENT maxBucket = [ INT_MIN ] * ( n - 1 ) NEW_LINE minBucket = [ INT_MAX ] * ( n - 1 ) NEW_LINE delta = ( maxVal - minVal ) // ( n - 1 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if arr [ i ] == maxVal or arr [ i ] == minVal : NEW_LINE INDENT continue NEW_LINE DEDENT index = ( arr [ i ] - minVal ) // delta NEW_LINE if maxBucket [ index ] == INT_MIN : NEW_LINE INDENT maxBucket [ index ] = arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT maxBucket [ index ] = max ( maxBucket [ index ] , arr [ i ] ) NEW_LINE DEDENT if minBucket [ index ] == INT_MAX : NEW_LINE INDENT minBucket [ index ] = arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT minBucket [ index ] = min ( minBucket [ index ] , arr [ i ] ) NEW_LINE DEDENT DEDENT prev_val , max_gap = minVal , 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if minBucket [ i ] == INT_MAX : NEW_LINE INDENT continue NEW_LINE DEDENT max_gap = max ( max_gap , minBucket [ i ] - prev_val ) NEW_LINE prev_val = maxBucket [ i ] NEW_LINE DEDENT max_gap = max ( max_gap , maxVal - prev_val ) NEW_LINE return max_gap NEW_LINE DEDENT
def solve ( n ) : NEW_LINE INDENT a = float ( n / 2 ) ; NEW_LINE if ( n % 2 != 0 ) : NEW_LINE INDENT print ( ( math . ceil ( a ) - 1 ) , ( math . floor ( a ) + 1 ) ) ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( a % 2 == 0 ) : NEW_LINE INDENT print ( ( math . ceil ( a ) - 1 ) , ( math . floor ( a ) + 1 ) ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( math . ceil ( a ) - 2 ) , ( math . floor ( a ) + 2 ) ) ; NEW_LINE DEDENT DEDENT DEDENT
def getMissingNo ( a , n ) : NEW_LINE INDENT x1 = a [ 0 ] NEW_LINE x2 = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT x1 = x1 ^ a [ i ] NEW_LINE DEDENT for i in range ( 2 , n + 2 ) : NEW_LINE INDENT x2 = x2 ^ i NEW_LINE DEDENT return x1 ^ x2 NEW_LINE DEDENT
def isCyclic ( N ) : NEW_LINE INDENT num = N NEW_LINE count = 0 NEW_LINE digit = ( num % 10 ) NEW_LINE allSame = True NEW_LINE while ( num > 0 ) : NEW_LINE INDENT count += 1 NEW_LINE if ( num % 10 != digit ) : NEW_LINE INDENT allSame = False NEW_LINE DEDENT num = num // 10 NEW_LINE DEDENT if ( allSame == True ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( count % 2 == 0 ) : NEW_LINE INDENT halfPower = pow ( 10 , count // 2 ) NEW_LINE firstHalf = N % halfPower NEW_LINE secondHalf = N / halfPower NEW_LINE if ( firstHalf == firstHalf and isCyclic ( firstHalf ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT num = N NEW_LINE while ( True ) : NEW_LINE INDENT rem = num % 10 NEW_LINE div = num // 10 NEW_LINE num = pow ( 10 , count - 1 ) * rem + div NEW_LINE if ( num == N ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( num % N != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return 2 * pow ( n , 3 ) + pow ( n , 2 ) NEW_LINE DEDENT
def Nth_Term ( n ) : NEW_LINE INDENT return ( 3 * pow ( n , 2 ) - n + 2 ) // ( 2 ) NEW_LINE DEDENT
def Max_Sum ( a , n ) : NEW_LINE INDENT b = [ 0 for i in range ( n ) ] NEW_LINE S = 0 NEW_LINE res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT b [ i ] = res NEW_LINE res += a [ i ] NEW_LINE S += a [ i ] NEW_LINE res = max ( res , - S ) NEW_LINE DEDENT ans = S NEW_LINE ans = max ( ans , res ) NEW_LINE g = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT g -= a [ i ] NEW_LINE ans = max ( ans , g + b [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def lcs ( X , Y , m , n ) : NEW_LINE INDENT if ( m == 0 or n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( X [ m - 1 ] == Y [ n - 1 ] ) : NEW_LINE INDENT return 1 + lcs ( X , Y , m - 1 , n - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) ) NEW_LINE DEDENT DEDENT
def countSticks ( string ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT ch = string [ i ] ; NEW_LINE if ( ch >= ' A ' and ch <= ' Z ' ) : NEW_LINE INDENT cnt += sticks [ ord ( ch ) - ord ( ' A ' ) ] ; NEW_LINE DEDENT else : NEW_LINE INDENT cnt += number [ ord ( ch ) - ord ( '0' ) ] ; NEW_LINE DEDENT DEDENT return cnt ; NEW_LINE DEDENT
def countSubarrays ( arr , n ) : NEW_LINE INDENT difference = 0 NEW_LINE ans = 0 NEW_LINE hash_positive = [ 0 ] * ( n + 1 ) NEW_LINE hash_negative = [ 0 ] * ( n + 1 ) NEW_LINE hash_positive [ 0 ] = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] & 1 == 1 ) : NEW_LINE INDENT difference = difference + 1 NEW_LINE DEDENT else : NEW_LINE INDENT difference = difference - 1 NEW_LINE DEDENT if ( difference < 0 ) : NEW_LINE INDENT ans += hash_negative [ - difference ] NEW_LINE hash_negative [ - difference ] = hash_negative [ - difference ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += hash_positive [ difference ] NEW_LINE hash_positive [ difference ] = hash_positive [ difference ] + 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def Count ( s , pos ) : NEW_LINE INDENT c = s [ pos - 1 ] NEW_LINE counter = 0 NEW_LINE for i in range ( pos - 1 ) : NEW_LINE INDENT if s [ i ] == c : NEW_LINE INDENT counter = counter + 1 NEW_LINE DEDENT DEDENT return counter NEW_LINE DEDENT
def seriessum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += i * ( i + 1 ) / 2 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def countSubStr ( strr , lenn ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( lenn ) : NEW_LINE INDENT if ( strr [ i ] == '0' ) : NEW_LINE INDENT ans += ( i + 1 ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def findTransitionPoint ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def check ( a , b ) : NEW_LINE INDENT for i in range ( 1 , N , 1 ) : NEW_LINE INDENT for j in range ( 1 , M , 1 ) : NEW_LINE INDENT if ( a [ i ] [ j ] != b [ i ] [ j ] ) : NEW_LINE INDENT a [ i ] [ j ] ^= 1 NEW_LINE a [ 0 ] [ 0 ] ^= 1 NEW_LINE a [ 0 ] [ j ] ^= 1 NEW_LINE a [ i ] [ 0 ] ^= 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT if ( a [ i ] [ j ] != b [ i ] [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
def findevenPair ( A , N ) : NEW_LINE INDENT evenPair = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( ( A [ i ] & A [ j ] ) % 2 == 0 ) : NEW_LINE INDENT evenPair += 1 NEW_LINE DEDENT DEDENT DEDENT return evenPair NEW_LINE DEDENT
def minCost ( N , P , Q ) : NEW_LINE INDENT cost = 0 NEW_LINE while ( N > 0 ) : NEW_LINE INDENT if ( N & 1 ) : NEW_LINE INDENT cost += P NEW_LINE N -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT temp = N // 2 ; NEW_LINE if ( temp * P > Q ) : NEW_LINE INDENT cost += Q NEW_LINE DEDENT else : NEW_LINE INDENT cost += P * temp NEW_LINE DEDENT N //= 2 NEW_LINE DEDENT DEDENT return cost NEW_LINE DEDENT
def countPalindromes ( n , m , matrix ) : NEW_LINE INDENT count = n * m ; NEW_LINE length_of_sequence_row = 0 ; NEW_LINE length_of_sequence_column = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT length_of_sequence_row = min ( j , m - 1 - j ) ; NEW_LINE length_of_sequence_column = min ( i , n - i - 1 ) ; NEW_LINE for k in range ( 1 , length_of_sequence_row + 1 ) : NEW_LINE INDENT if ( matrix [ i ] [ j - k ] == matrix [ i ] [ j + k ] ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT for k in range ( 1 , length_of_sequence_column + 1 ) : NEW_LINE INDENT if ( matrix [ i - k ] [ j ] == matrix [ i + k ] [ j ] ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT DEDENT DEDENT return count ; NEW_LINE DEDENT
def Reverseorder ( n ) : NEW_LINE INDENT prime = [ True ] * ( n + 1 ) ; NEW_LINE p = 2 ; NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( ( p * 2 ) , ( n + 1 ) , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT p += 1 ; NEW_LINE DEDENT for p in range ( n , 1 , - 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT print ( p , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT DEDENT
def shortestLength ( n , x , y ) : NEW_LINE INDENT answer = 0 NEW_LINE i = 0 NEW_LINE while n > 0 : NEW_LINE INDENT if ( x [ i ] + y [ i ] > answer ) : NEW_LINE INDENT answer = x [ i ] + y [ i ] NEW_LINE DEDENT i += 1 NEW_LINE n -= 1 NEW_LINE DEDENT print ( " Length ▁ - > ▁ " + str ( answer ) ) NEW_LINE print ( " Path ▁ - > ▁ " + " ( ▁ 1 , ▁ " + str ( answer ) + " ▁ ) " + " and ▁ ( ▁ " + str ( answer ) + " , ▁ 1 ▁ ) " ) NEW_LINE DEDENT
def power ( x , y ) : NEW_LINE INDENT res = 1 NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( ( y & 1 ) == 1 ) : NEW_LINE INDENT res = res * x NEW_LINE DEDENT y = y >> 1 NEW_LINE x = x * x NEW_LINE DEDENT return res NEW_LINE DEDENT
def center_hexadecagonal_num ( n ) : NEW_LINE INDENT return 8 * n * n - 8 * n + 1 NEW_LINE DEDENT
def minCost ( n , arr , cost ) : NEW_LINE INDENT Sum , totalCost = 0 , 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT Sum += arr [ i ] NEW_LINE DEDENT totalCost += cost * Sum NEW_LINE arr [ n - 1 ] += Sum NEW_LINE totalCost += ( 2 * cost * arr [ n - 1 ] ) NEW_LINE return totalCost NEW_LINE DEDENT
def countNumbers ( n ) : NEW_LINE INDENT if n % 2 == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( 9 * pow ( 10 , n // 2 - 1 ) ) NEW_LINE DEDENT
def sumOfSeries ( n ) : NEW_LINE INDENT return int ( ( n * ( 2 * n - 1 ) * ( 2 * n + 1 ) ) / 3 ) NEW_LINE DEDENT
def solution ( a , b , n ) : NEW_LINE INDENT i = 0 NEW_LINE while i * a <= n : NEW_LINE INDENT if ( n - ( i * a ) ) % b == 0 : NEW_LINE INDENT print ( " x ▁ = ▁ " , i , " , ▁ y ▁ = ▁ " , int ( ( n - ( i * a ) ) / b ) ) NEW_LINE return 0 NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT print ( " No ▁ solution " ) NEW_LINE DEDENT
def countSetBitsRec ( num ) : NEW_LINE INDENT nibble = 0 ; NEW_LINE if ( 0 == num ) : NEW_LINE INDENT return num_to_bits [ 0 ] ; NEW_LINE DEDENT nibble = num & 0xf ; NEW_LINE return num_to_bits [ nibble ] + countSetBitsRec ( num >> 4 ) ; NEW_LINE DEDENT
def findCullen ( n ) : NEW_LINE INDENT return ( 1 << n ) * n + 1 NEW_LINE DEDENT
def calculate ( a ) : NEW_LINE INDENT a . sort ( ) NEW_LINE count = 1 NEW_LINE answer = 0 NEW_LINE for i in range ( 1 , len ( a ) ) : NEW_LINE INDENT if a [ i ] == a [ i - 1 ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT answer = answer + count * ( count - 1 ) // 2 NEW_LINE count = 1 NEW_LINE DEDENT DEDENT answer = answer + count * ( count - 1 ) // 2 NEW_LINE return answer NEW_LINE DEDENT
def recaman ( n ) : NEW_LINE INDENT arr = [ 0 ] * n NEW_LINE arr [ 0 ] = 0 NEW_LINE print ( arr [ 0 ] , end = " , ▁ " ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT curr = arr [ i - 1 ] - i NEW_LINE for j in range ( 0 , i ) : NEW_LINE INDENT if ( ( arr [ j ] == curr ) or curr < 0 ) : NEW_LINE INDENT curr = arr [ i - 1 ] + i NEW_LINE break NEW_LINE DEDENT DEDENT arr [ i ] = curr NEW_LINE print ( arr [ i ] , end = " , ▁ " ) NEW_LINE DEDENT DEDENT
def centeredHexagonalSeries ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( 3 * i * ( i - 1 ) + 1 , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def reverse ( str1 , x ) : NEW_LINE INDENT n = ( len ( str1 ) - x ) // 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( str1 [ i ] , end = " " ) NEW_LINE DEDENT for i in range ( n + x - 1 , n - 1 , - 1 ) : NEW_LINE INDENT print ( str1 [ i ] , end = " " ) NEW_LINE DEDENT for i in range ( n + x , len ( str1 ) ) : NEW_LINE INDENT print ( str1 [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def pairsInSortedRotated ( arr , n , x ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if arr [ i ] > arr [ i + 1 ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT l = ( i + 1 ) % n NEW_LINE r = i NEW_LINE cnt = 0 NEW_LINE while ( l != r ) : NEW_LINE INDENT if arr [ l ] + arr [ r ] == x : NEW_LINE INDENT cnt += 1 NEW_LINE if l == ( r - 1 + n ) % n : NEW_LINE INDENT return cnt NEW_LINE DEDENT l = ( l + 1 ) % n NEW_LINE r = ( r - 1 + n ) % n NEW_LINE DEDENT elif arr [ l ] + arr [ r ] < x : NEW_LINE INDENT l = ( l + 1 ) % n NEW_LINE DEDENT else : NEW_LINE INDENT r = ( n + r - 1 ) % n NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
def smallestFreq ( S1 , S2 ) : NEW_LINE INDENT banned = defaultdict ( lambda : 0 ) NEW_LINE i = 0 NEW_LINE while i < len ( S2 ) : NEW_LINE INDENT s = " " NEW_LINE while i < len ( S2 ) and S2 [ i ] != ' ▁ ' : NEW_LINE INDENT s += S2 [ i ] NEW_LINE i += 1 NEW_LINE DEDENT i += 1 NEW_LINE banned [ s ] += 1 NEW_LINE DEDENT result = defaultdict ( lambda : 0 ) NEW_LINE ans = " " NEW_LINE freq = 0 NEW_LINE i = 0 NEW_LINE while i < len ( S1 ) : NEW_LINE INDENT s = " " NEW_LINE while i < len ( S1 ) and S1 [ i ] != ' ▁ ' : NEW_LINE INDENT s += S1 [ i ] NEW_LINE i += 1 NEW_LINE DEDENT i += 1 NEW_LINE if banned [ s ] == 0 : NEW_LINE INDENT result [ s ] += 1 NEW_LINE if ( result [ s ] > freq or ( result [ s ] == freq and s < ans ) ) : NEW_LINE INDENT ans = s NEW_LINE freq = result [ s ] NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def isPowerOf2 ( sttr ) : NEW_LINE INDENT len_str = len ( sttr ) ; NEW_LINE sttr = list ( sttr ) ; NEW_LINE num = 0 ; NEW_LINE if ( len_str == 1 and sttr [ len_str - 1 ] == '1' ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT while ( len_str != 1 or sttr [ len_str - 1 ] != '1' ) : NEW_LINE INDENT if ( ( ord ( sttr [ len_str - 1 ] ) - ord ( '0' ) ) % 2 == 1 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT j = 0 ; NEW_LINE for i in range ( len_str ) : NEW_LINE INDENT num = num * 10 + ( ord ( sttr [ i ] ) - ord ( '0' ) ) ; NEW_LINE if ( num < 2 ) : NEW_LINE INDENT if ( i != 0 ) : NEW_LINE INDENT sttr [ j ] = '0' ; NEW_LINE j += 1 ; NEW_LINE DEDENT continue ; NEW_LINE DEDENT sttr [ j ] = chr ( ( num // 2 ) + ord ( '0' ) ) ; NEW_LINE j += 1 ; NEW_LINE num = ( num ) - ( num // 2 ) * 2 ; NEW_LINE DEDENT len_str = j ; NEW_LINE DEDENT return 1 ; NEW_LINE DEDENT
def breakEvenPoint ( exp , S , M ) : NEW_LINE INDENT earn = S - M NEW_LINE res = math . ceil ( exp / earn ) NEW_LINE return res NEW_LINE DEDENT
def numberOfPaths ( m , n ) : NEW_LINE INDENT count = [ [ 0 for x in range ( m ) ] for y in range ( n ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT count [ i ] [ 0 ] = 1 ; NEW_LINE DEDENT for j in range ( n ) : NEW_LINE INDENT count [ 0 ] [ j ] = 1 ; NEW_LINE DEDENT for i in range ( 1 , m ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT count [ i ] [ j ] = count [ i - 1 ] [ j ] + count [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT return count [ m - 1 ] [ n - 1 ] NEW_LINE DEDENT
def search ( arr , n , x ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( arr [ i ] == x ) : NEW_LINE INDENT return i NEW_LINE DEDENT i = i + abs ( arr [ i ] - x ) NEW_LINE DEDENT print ( " number ▁ is ▁ not ▁ present ! " ) NEW_LINE return - 1 NEW_LINE DEDENT
def findSum ( N , K ) : NEW_LINE INDENT ans = 0 ; NEW_LINE y = N / K ; NEW_LINE x = N % K ; NEW_LINE ans = ( ( K * ( K - 1 ) / 2 ) * y + ( x * ( x + 1 ) ) / 2 ) ; NEW_LINE return int ( ans ) ; NEW_LINE DEDENT
def count_even_odd ( min , max , steps ) : NEW_LINE INDENT beven = True NEW_LINE aeven = False NEW_LINE n = 2 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT a = steps [ i ] [ 0 ] NEW_LINE b = steps [ i ] [ 1 ] NEW_LINE if ( not ( aeven or a & 1 ) ) : NEW_LINE INDENT aeven = True NEW_LINE DEDENT if ( beven ) : NEW_LINE INDENT if ( b & 1 ) : NEW_LINE INDENT beven = False NEW_LINE DEDENT DEDENT elif ( not ( a & 1 ) ) : NEW_LINE INDENT if ( not ( b & 1 ) ) : NEW_LINE INDENT beven = True NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( b & 1 ) : NEW_LINE INDENT beven = True NEW_LINE DEDENT DEDENT DEDENT if ( beven ) : NEW_LINE INDENT even = ( int ( max / 2 ) - int ( ( min - 1 ) / 2 ) ) NEW_LINE odd = 0 NEW_LINE DEDENT else : NEW_LINE INDENT even = ( int ( max / 2 ) - int ( ( min - 1 ) / 2 ) ) NEW_LINE odd = 0 NEW_LINE DEDENT if ( not ( beven ^ aeven ) ) : NEW_LINE INDENT even += ( max - min + 1 - int ( max / 2 ) + int ( ( min - 1 ) / 2 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT odd += ( max - min + 1 - int ( max / 2 ) + int ( ( min - 1 ) / 2 ) ) NEW_LINE DEDENT print ( " even ▁ = ▁ " , even , " , ▁ odd ▁ = ▁ " , odd , sep = " " ) NEW_LINE DEDENT
def printBracketNumber ( exp , n ) : NEW_LINE INDENT left_bnum = 1 NEW_LINE right_bnum = list ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if exp [ i ] == ' ( ' : NEW_LINE INDENT print ( left_bnum , end = " ▁ " ) NEW_LINE right_bnum . append ( left_bnum ) NEW_LINE left_bnum += 1 NEW_LINE DEDENT elif exp [ i ] == ' ) ' : NEW_LINE INDENT print ( right_bnum [ - 1 ] , end = " ▁ " ) NEW_LINE right_bnum . pop ( ) NEW_LINE DEDENT DEDENT DEDENT
def findElement ( arr , size ) : NEW_LINE INDENT right_mul = 1 ; NEW_LINE left_mul = 1 ; NEW_LINE for i in range ( 1 , size ) : NEW_LINE INDENT right_mul = right_mul * arr [ i ] ; NEW_LINE DEDENT for i , j in zip ( range ( 0 , size ) , range ( 1 , size , 1 ) ) : NEW_LINE INDENT right_mul = right_mul / arr [ j ] ; NEW_LINE left_mul = left_mul * arr [ i ] ; NEW_LINE if ( left_mul == right_mul ) : NEW_LINE INDENT return arr [ i + 1 ] ; NEW_LINE DEDENT DEDENT return - 1 ; NEW_LINE DEDENT
def checkIsAP ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : return True NEW_LINE arr . sort ( ) NEW_LINE d = arr [ 1 ] - arr [ 0 ] NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if ( arr [ i ] - arr [ i - 1 ] != d ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def countOdd ( L , R ) : NEW_LINE INDENT N = ( R - L ) // 2 NEW_LINE if ( R % 2 != 0 or L % 2 != 0 ) : NEW_LINE INDENT N += 1 NEW_LINE DEDENT return N NEW_LINE DEDENT
def lucas_sequence ( s , n ) : NEW_LINE INDENT m = defaultdict ( lambda : 0 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT m [ s [ i ] ] += 1 NEW_LINE DEDENT v1 , v2 = [ ] , [ ] NEW_LINE for it in m : NEW_LINE INDENT v1 . append ( m [ it ] ) NEW_LINE DEDENT v1 . sort ( ) NEW_LINE if v1 [ 0 ] == 1 and v1 [ 1 ] == 2 : NEW_LINE INDENT v1 [ 0 ] , v1 [ 1 ] = 2 , 1 NEW_LINE DEDENT else : NEW_LINE INDENT return " NO " NEW_LINE DEDENT a , b = 2 , 1 NEW_LINE v2 . append ( a ) NEW_LINE v2 . append ( b ) NEW_LINE for i in range ( 0 , len ( v1 ) - 2 ) : NEW_LINE INDENT v2 . append ( a + b ) NEW_LINE a , b = b , a + b NEW_LINE DEDENT flag = 1 NEW_LINE for i in range ( 0 , len ( v1 ) ) : NEW_LINE INDENT if v1 [ i ] != v2 [ i ] : NEW_LINE INDENT flag = 0 NEW_LINE break NEW_LINE DEDENT DEDENT if flag == 1 : NEW_LINE INDENT return " YES " NEW_LINE DEDENT else : NEW_LINE INDENT return " NO " NEW_LINE DEDENT DEDENT
def firstkdigits ( n , k ) : NEW_LINE INDENT product = n * math . log ( n , 10 ) ; NEW_LINE decimal_part = product - math . floor ( product ) ; NEW_LINE decimal_part = pow ( 10 , decimal_part ) ; NEW_LINE digits = pow ( 10 , k - 1 ) ; NEW_LINE return math . floor ( decimal_part * digits ) ; NEW_LINE DEDENT
def answer ( X , K ) : NEW_LINE INDENT MIN = pow ( 10 , K - 1 ) NEW_LINE if ( MIN % X == 0 ) : NEW_LINE INDENT return ( MIN ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( MIN + X ) - ( ( MIN + X ) % X ) ) NEW_LINE DEDENT DEDENT
def MaximumHeight ( a , n ) : NEW_LINE INDENT result = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT y = ( i * ( i + 1 ) ) / 2 NEW_LINE if ( y < n ) : NEW_LINE INDENT result = i NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def findKthChar ( s , k ) : NEW_LINE INDENT len1 = len ( s ) NEW_LINE i = 0 NEW_LINE total_len = 0 NEW_LINE while ( i < len1 ) : NEW_LINE INDENT if ( s [ i ] . isalpha ( ) ) : NEW_LINE INDENT total_len += 1 NEW_LINE if ( total_len == k ) : NEW_LINE INDENT return s [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT n = 0 NEW_LINE while ( i < len1 and s [ i ] . isalpha ( ) == False ) : NEW_LINE INDENT n = n * 10 + ( ord ( s [ i ] ) - ord ( '0' ) ) NEW_LINE i += 1 NEW_LINE DEDENT next_total_len = total_len * n NEW_LINE if ( k <= next_total_len ) : NEW_LINE INDENT pos = k % total_len NEW_LINE if ( pos == 0 ) : NEW_LINE INDENT pos = total_len NEW_LINE DEDENT return findKthChar ( s , pos ) NEW_LINE DEDENT else : NEW_LINE INDENT total_len = next_total_len NEW_LINE DEDENT DEDENT DEDENT return - 1 NEW_LINE DEDENT
def countChanges ( arr , n ) : NEW_LINE INDENT s = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . append ( arr [ i ] ) NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if i not in s : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def findMaximumNum ( st , n , k ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( k < 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( st [ i ] != '9' ) : NEW_LINE INDENT st = st [ 0 : i ] + '9' + st [ i + 1 : ] NEW_LINE k -= 1 NEW_LINE DEDENT DEDENT return st NEW_LINE DEDENT
def countTripletsLessThanL ( n , L , arr ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE ways = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT mostDistantDistance = arr [ k ] - arr [ i ] NEW_LINE if ( mostDistantDistance <= L ) : NEW_LINE INDENT ways += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return ways NEW_LINE DEDENT
def checkEqualMatrix ( arr , n , m , k ) : NEW_LINE INDENT c = 0 ; cnt1 = 0 ; cnt2 = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( c % 2 == 0 ) : NEW_LINE INDENT if ( arr [ i ] [ j ] == k ) : NEW_LINE INDENT cnt1 += 1 ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( arr [ i ] [ j ] == k ) : NEW_LINE INDENT cnt2 += 1 ; NEW_LINE DEDENT DEDENT c = c + 1 ; NEW_LINE DEDENT DEDENT if ( cnt1 >= 1 and cnt2 >= 1 ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT DEDENT
def isMinHeap ( level , n ) : NEW_LINE INDENT for i in range ( int ( n / 2 ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if level [ i ] > level [ 2 * i + 1 ] : NEW_LINE INDENT return False NEW_LINE DEDENT if 2 * i + 2 < n : NEW_LINE INDENT if level [ i ] > level [ 2 * i + 2 ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
def haversine ( lat1 , lon1 , lat2 , lon2 ) : NEW_LINE INDENT dLat = ( lat2 - lat1 ) * math . pi / 180.0 NEW_LINE dLon = ( lon2 - lon1 ) * math . pi / 180.0 NEW_LINE lat1 = ( lat1 ) * math . pi / 180.0 NEW_LINE lat2 = ( lat2 ) * math . pi / 180.0 NEW_LINE a = ( pow ( math . sin ( dLat / 2 ) , 2 ) + pow ( math . sin ( dLon / 2 ) , 2 ) * math . cos ( lat1 ) * math . cos ( lat2 ) ) ; NEW_LINE rad = 6371 NEW_LINE c = 2 * math . asin ( math . sqrt ( a ) ) NEW_LINE return rad * c NEW_LINE DEDENT
def count ( n ) : NEW_LINE INDENT return pow ( 2 , n - 1 ) NEW_LINE DEDENT
def numberofterm ( digit , number ) : NEW_LINE INDENT firstnum = pow ( 10 , digit - 1 ) NEW_LINE lastnum = pow ( 10 , digit ) NEW_LINE firstnum = ( firstnum - firstnum % number ) + number NEW_LINE lastnum = ( lastnum - lastnum % number ) NEW_LINE return ( ( lastnum - firstnum ) // number + 1 ) ; NEW_LINE DEDENT
def findOddPair ( A , N ) : NEW_LINE INDENT oddPair = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( ( A [ i ] ^ A [ j ] ) % 2 != 0 ) : NEW_LINE INDENT oddPair += 1 NEW_LINE DEDENT DEDENT DEDENT return oddPair NEW_LINE DEDENT
def countOrderedPairs ( A , n ) : NEW_LINE INDENT orderedPairs = 0 NEW_LINE m = defaultdict ( lambda : 0 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT m [ A [ i ] ] += 1 NEW_LINE DEDENT for X , Y in m . items ( ) : NEW_LINE INDENT for j in range ( 1 , Y + 1 ) : NEW_LINE INDENT if m [ j ] >= X : NEW_LINE INDENT orderedPairs += 1 NEW_LINE DEDENT DEDENT DEDENT return orderedPairs NEW_LINE DEDENT
def firstkdigits ( n , k ) : NEW_LINE INDENT product = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT product *= n NEW_LINE DEDENT while ( ( product // pow ( 10 , k ) ) != 0 ) : NEW_LINE INDENT product = product // 10 NEW_LINE DEDENT return product NEW_LINE DEDENT
def largestCoprime ( N ) : NEW_LINE INDENT if N == 6 : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif N % 4 == 0 : NEW_LINE INDENT return N // 2 - 1 NEW_LINE DEDENT elif N % 2 == 0 : NEW_LINE INDENT return N // 2 - 2 NEW_LINE DEDENT else : NEW_LINE INDENT return ( N - 1 ) // 2 NEW_LINE DEDENT DEDENT
def getSum ( n , d ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( d <= n ) : NEW_LINE INDENT sum += d NEW_LINE d += 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def partSort ( arr , N , a , b ) : NEW_LINE INDENT l = min ( a , b ) NEW_LINE r = max ( a , b ) NEW_LINE temp = [ 0 for i in range ( r - l + 1 ) ] NEW_LINE j = 0 NEW_LINE for i in range ( l , r + 1 , 1 ) : NEW_LINE INDENT temp [ j ] = arr [ i ] NEW_LINE j += 1 NEW_LINE DEDENT temp . sort ( reverse = False ) NEW_LINE j = 0 NEW_LINE for i in range ( l , r + 1 , 1 ) : NEW_LINE INDENT arr [ i ] = temp [ j ] NEW_LINE j += 1 NEW_LINE DEDENT for i in range ( 0 , N , 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def minOperations ( arr , n ) : NEW_LINE INDENT mp = dict . fromkeys ( arr , 0 ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 ; NEW_LINE DEDENT maxFreq = - ( sys . maxsize - 1 ) ; NEW_LINE for key in mp : NEW_LINE INDENT maxFreq = max ( maxFreq , mp [ key ] ) ; NEW_LINE DEDENT return ( n - maxFreq ) ; NEW_LINE DEDENT
def thirdLargest ( arr , arr_size ) : NEW_LINE INDENT if ( arr_size < 3 ) : NEW_LINE INDENT print ( " ▁ Invalid ▁ Input ▁ " ) NEW_LINE return NEW_LINE DEDENT first = arr [ 0 ] NEW_LINE for i in range ( 1 , arr_size ) : NEW_LINE INDENT if ( arr [ i ] > first ) : NEW_LINE INDENT first = arr [ i ] NEW_LINE DEDENT DEDENT second = - sys . maxsize NEW_LINE for i in range ( 0 , arr_size ) : NEW_LINE INDENT if ( arr [ i ] > second and arr [ i ] < first ) : NEW_LINE INDENT second = arr [ i ] NEW_LINE DEDENT DEDENT third = - sys . maxsize NEW_LINE for i in range ( 0 , arr_size ) : NEW_LINE INDENT if ( arr [ i ] > third and arr [ i ] < second ) : NEW_LINE INDENT third = arr [ i ] NEW_LINE DEDENT DEDENT print ( " The ▁ Third ▁ Largest " , " element ▁ is " , third ) NEW_LINE DEDENT
def generateSequence ( n , g ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( i * g , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def findevenPair ( A , N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT if ( A [ i ] % 2 != 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT oddCount = count * ( count - 1 ) / 2 NEW_LINE return ( int ) ( ( N * ( N - 1 ) / 2 ) - oddCount ) NEW_LINE DEDENT
def findProduct ( arr , n , k ) : NEW_LINE INDENT prod = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % k == 0 ) : NEW_LINE INDENT prod *= arr [ i ] NEW_LINE DEDENT DEDENT return prod NEW_LINE DEDENT
def findNthNum ( N ) : NEW_LINE INDENT bit_L = 1 ; NEW_LINE last_num = 0 ; NEW_LINE while ( bit_L * ( bit_L + 1 ) / 2 < N ) : NEW_LINE INDENT last_num = last_num + bit_L ; NEW_LINE bit_L += 1 ; NEW_LINE DEDENT bit_R = N - last_num - 1 ; NEW_LINE print ( ( 1 << bit_L ) + ( 1 << bit_R ) ) ; NEW_LINE DEDENT
def multiplyWith4 ( n ) : NEW_LINE INDENT return ( n << 2 ) NEW_LINE DEDENT
def productDiagonals ( arr , n ) : NEW_LINE INDENT product = 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT product = product * arr [ i ] [ i ] ; NEW_LINE product = product * arr [ i ] [ n - i - 1 ] ; NEW_LINE DEDENT if ( n % 2 == 1 ) : NEW_LINE INDENT product = product // arr [ n // 2 ] [ n // 2 ] ; NEW_LINE DEDENT return product ; NEW_LINE DEDENT
def findTime ( T , K ) : NEW_LINE INDENT minutes = ( ( ( ord ( T [ 0 ] ) - ord ( '0' ) ) * 10 + ord ( T [ 1 ] ) - ord ( '0' ) ) * 60 + ( ( ord ( T [ 3 ] ) - ord ( '0' ) ) * 10 + ord ( T [ 4 ] ) - ord ( '0' ) ) ) ; NEW_LINE minutes += K NEW_LINE hour = ( int ( minutes / 60 ) ) % 24 NEW_LINE min = minutes % 60 NEW_LINE if ( hour < 10 ) : NEW_LINE INDENT print ( 0 , hour , " : " , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( hour , " : " , end = " ▁ " ) NEW_LINE DEDENT if ( min < 10 ) : NEW_LINE INDENT print ( 0 , min , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( min , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def count ( n ) : NEW_LINE INDENT x = ( n // 3 ) - 1 ; NEW_LINE if ( n % 3 > 0 ) : NEW_LINE INDENT x += 1 ; NEW_LINE DEDENT return ( 4 * x + 4 * n ) ; NEW_LINE DEDENT
def solve ( i , tight , sum_so_far , Sum , number , length ) : NEW_LINE INDENT if i == length : NEW_LINE INDENT if sum_so_far == Sum : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT ans = dp [ i ] [ tight ] [ sum_so_far ] NEW_LINE if ans != - 1 : NEW_LINE INDENT return ans NEW_LINE DEDENT ans = 0 NEW_LINE for currdigit in range ( 0 , 10 ) : NEW_LINE INDENT currdigitstr = str ( currdigit ) NEW_LINE if not tight and currdigitstr > number [ i ] : NEW_LINE INDENT break NEW_LINE DEDENT ntight = tight or currdigitstr < number [ i ] NEW_LINE nsum_so_far = sum_so_far + currdigit NEW_LINE ans += solve ( i + 1 , ntight , nsum_so_far , Sum , number , length ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def replace_elements ( arr , n ) : NEW_LINE INDENT pos = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT arr [ pos ] = arr [ i ] NEW_LINE pos = pos + 1 NEW_LINE while ( pos > 1 and arr [ pos - 2 ] == arr [ pos - 1 ] ) : NEW_LINE INDENT pos -= 1 NEW_LINE arr [ pos - 1 ] += 1 NEW_LINE DEDENT DEDENT for i in range ( 0 , pos ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def isPrime ( a , lower , upper ) : NEW_LINE INDENT n = 0 NEW_LINE for i in range ( lower - 1 , upper ) : NEW_LINE INDENT n = n + a [ i ] NEW_LINE DEDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def discriminant ( a , b , c ) : NEW_LINE INDENT discriminant = ( b ** 2 ) - ( 4 * a * c ) NEW_LINE if discriminant > 0 : NEW_LINE INDENT print ( ' Discriminant ▁ is ' , discriminant , " which ▁ is ▁ Positive " ) NEW_LINE print ( ' Hence ▁ Two ▁ Solutions ' ) NEW_LINE DEDENT elif discriminant == 0 : NEW_LINE INDENT print ( ' Discriminant ▁ is ' , discriminant , " which ▁ is ▁ Zero " ) NEW_LINE print ( ' Hence ▁ One ▁ Solution ' ) NEW_LINE DEDENT elif discriminant < 0 : NEW_LINE INDENT print ( ' Discriminant ▁ is ' , discriminant , " which ▁ is ▁ Negative " ) NEW_LINE print ( ' Hence ▁ No ▁ Real ▁ Solutions ' ) NEW_LINE DEDENT DEDENT
def getSum ( a , n ) : NEW_LINE INDENT P = [ 0 ] * n NEW_LINE P [ 0 ] = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT P [ i ] = a [ i ] + P [ i - 1 ] NEW_LINE DEDENT S = P [ n - 1 ] NEW_LINE hash = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash [ P [ i ] ] = 1 NEW_LINE DEDENT res = set ( ) NEW_LINE for i in range ( 1 , int ( sqrt ( S ) ) + 1 ) : NEW_LINE INDENT if ( S % i == 0 ) : NEW_LINE INDENT pres = True ; NEW_LINE div1 = i NEW_LINE div2 = S // i NEW_LINE for j in range ( div1 , S + 1 , div1 ) : NEW_LINE INDENT if j not in hash . keys ( ) : NEW_LINE INDENT pres = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( pres and div1 != S ) : NEW_LINE INDENT res . add ( div1 ) NEW_LINE DEDENT pres = True NEW_LINE for j in range ( S // i , S + 1 , S // i ) : NEW_LINE INDENT if j not in hash . keys ( ) : NEW_LINE INDENT pres = False ; NEW_LINE break NEW_LINE DEDENT DEDENT if ( pres and div2 != S ) : NEW_LINE INDENT res . add ( div2 ) NEW_LINE DEDENT DEDENT DEDENT if ( len ( res ) == 0 ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE return NEW_LINE DEDENT for i in res : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def count_pairs ( a , b , n , m ) : NEW_LINE INDENT odd1 = 0 NEW_LINE even1 = 0 NEW_LINE odd2 = 0 NEW_LINE even2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] % 2 ) : NEW_LINE INDENT odd1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even1 += 1 NEW_LINE DEDENT DEDENT for i in range ( m ) : NEW_LINE INDENT if ( b [ i ] % 2 ) : NEW_LINE INDENT odd2 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even2 += 1 NEW_LINE DEDENT DEDENT pairs = ( min ( odd1 , even2 ) + min ( odd2 , even1 ) ) NEW_LINE return pairs NEW_LINE DEDENT
def printUnique ( l , r ) : NEW_LINE INDENT for i in range ( l , r + 1 ) : NEW_LINE INDENT num = i ; NEW_LINE visited = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ; NEW_LINE while ( num ) : NEW_LINE INDENT if visited [ num % 10 ] == 1 : NEW_LINE INDENT break ; NEW_LINE DEDENT visited [ num % 10 ] = 1 ; NEW_LINE num = ( int ) ( num / 10 ) ; NEW_LINE DEDENT if num == 0 : NEW_LINE INDENT print ( i , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT DEDENT
def countPairs ( arr , n , k ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( ( arr [ i ] - arr [ j ] + k ) % k == 0 ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT DEDENT DEDENT print ( cnt ) ; NEW_LINE DEDENT
def check ( s , m ) : NEW_LINE INDENT l = len ( s ) ; NEW_LINE c1 = 0 ; NEW_LINE c2 = 0 ; NEW_LINE for i in range ( 0 , l - 1 ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT c2 = 0 ; NEW_LINE c1 = c1 + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT c1 = 0 ; NEW_LINE c2 = c2 + 1 ; NEW_LINE DEDENT if ( c1 == m or c2 == m ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT return False ; NEW_LINE DEDENT
def exponentiation ( bas , exp ) : NEW_LINE INDENT t = 1 ; NEW_LINE while ( exp > 0 ) : NEW_LINE INDENT if ( exp % 2 != 0 ) : NEW_LINE INDENT t = ( t * bas ) % N ; NEW_LINE DEDENT bas = ( bas * bas ) % N ; NEW_LINE exp = int ( exp / 2 ) ; NEW_LINE DEDENT return t % N ; NEW_LINE DEDENT
def findSumofEle ( arr1 , m , arr2 , n , k ) : NEW_LINE INDENT arraySum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT arraySum += arr2 [ i ] NEW_LINE DEDENT mean = arraySum / n NEW_LINE sumOfElements = 0 NEW_LINE difference = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT difference = arr1 [ i ] - mean NEW_LINE if ( ( difference < 0 ) and ( k > ( - 1 ) * difference ) ) : NEW_LINE INDENT sumOfElements += arr1 [ i ] NEW_LINE DEDENT if ( ( difference >= 0 ) and ( k > difference ) ) : NEW_LINE INDENT sumOfElements += arr1 [ i ] NEW_LINE DEDENT DEDENT return sumOfElements NEW_LINE DEDENT
def count ( str1 , str2 ) : NEW_LINE INDENT c = 0 ; j = 0 ; NEW_LINE for i in range ( len ( str1 ) ) : NEW_LINE INDENT if str1 [ i ] in str2 : NEW_LINE INDENT c += 1 ; NEW_LINE DEDENT j += 1 ; NEW_LINE DEDENT print ( " No . ▁ of ▁ matching ▁ characters ▁ are : ▁ " , c ) ; NEW_LINE DEDENT
def findDivisors ( n ) : NEW_LINE INDENT div = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if j * i <= n : NEW_LINE INDENT div [ i * j ] += 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( div [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def getSmallestAndLargest ( s , k ) : NEW_LINE INDENT currStr = s [ : k ] NEW_LINE lexMin = currStr NEW_LINE lexMax = currStr NEW_LINE for i in range ( k , len ( s ) ) : NEW_LINE INDENT currStr = currStr [ 1 : k ] + s [ i ] NEW_LINE if ( lexMax < currStr ) : NEW_LINE INDENT lexMax = currStr NEW_LINE DEDENT if ( lexMin > currStr ) : NEW_LINE INDENT lexMin = currStr NEW_LINE DEDENT DEDENT print ( lexMin ) NEW_LINE print ( lexMax ) NEW_LINE DEDENT
def maxSum ( arr , n , k ) : NEW_LINE INDENT max_sum = INT_MIN NEW_LINE for i in range ( n - k + 1 ) : NEW_LINE INDENT current_sum = 0 NEW_LINE for j in range ( k ) : NEW_LINE INDENT current_sum = current_sum + arr [ i + j ] NEW_LINE DEDENT max_sum = max ( current_sum , max_sum ) NEW_LINE DEDENT return max_sum NEW_LINE DEDENT
def decToHexa ( n ) : NEW_LINE INDENT hexaDeciNum = [ '0' ] * 100 ; NEW_LINE i = 0 ; NEW_LINE while ( n != 0 ) : NEW_LINE INDENT temp = 0 ; NEW_LINE temp = n % 16 ; NEW_LINE if ( temp < 10 ) : NEW_LINE INDENT hexaDeciNum [ i ] = chr ( temp + 48 ) ; NEW_LINE i = i + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT hexaDeciNum [ i ] = chr ( temp + 55 ) ; NEW_LINE i = i + 1 ; NEW_LINE DEDENT n = int ( n / 16 ) ; NEW_LINE DEDENT j = i - 1 ; NEW_LINE while ( j >= 0 ) : NEW_LINE INDENT print ( ( hexaDeciNum [ j ] ) , end = " " ) ; NEW_LINE j = j - 1 ; NEW_LINE DEDENT DEDENT
def ways ( s , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp [ 0 ] [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT temp = " " NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT temp += s [ j ] NEW_LINE test = " " NEW_LINE for k in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT test += s [ k ] NEW_LINE if ( test < temp ) : NEW_LINE INDENT dp [ i ] [ j ] += dp [ k ] [ i - 1 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += dp [ i ] [ n - 1 ] NEW_LINE DEDENT return ans NEW_LINE DEDENT
def noOfBinaryStrings ( N , k ) : NEW_LINE INDENT dp = [ 0 ] * 100002 ; NEW_LINE for i in range ( 1 , K ) : NEW_LINE INDENT dp [ i ] = 1 ; NEW_LINE DEDENT dp [ k ] = 2 ; NEW_LINE for i in range ( k + 1 , N + 1 ) : NEW_LINE INDENT dp [ i ] = ( dp [ i - 1 ] + dp [ i - k ] ) % mod ; NEW_LINE DEDENT return dp [ N ] ; NEW_LINE DEDENT
def countSubSeq ( a , n , k ) : NEW_LINE INDENT a . sort ( reverse = False ) NEW_LINE arr = [ ] NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT count = 1 NEW_LINE x = a [ i ] NEW_LINE i += 1 NEW_LINE while ( i < n and a [ i ] == x ) : NEW_LINE INDENT count += 1 NEW_LINE i += 1 NEW_LINE DEDENT arr . append ( count ) NEW_LINE DEDENT m = len ( arr ) NEW_LINE n = min ( m , k ) NEW_LINE count = 1 NEW_LINE dp = [ [ 0 for i in range ( m + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT dp [ 0 ] [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 , 1 ) : NEW_LINE INDENT j = m NEW_LINE while ( j >= 0 ) : NEW_LINE INDENT if ( j > m - i ) : NEW_LINE INDENT dp [ i ] [ j ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j + 1 ] +   \ NEW_LINE INDENT arr [ j ] * dp [ i - 1 ] [ j + 1 ] NEW_LINE DEDENT DEDENT j -= 1 NEW_LINE DEDENT count = count + dp [ i ] [ 0 ] NEW_LINE DEDENT return count NEW_LINE DEDENT
def squareFree ( n ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE i = 1 ; NEW_LINE while ( True ) : NEW_LINE INDENT isSqFree = True ; NEW_LINE j = 2 ; NEW_LINE while ( j * j <= i ) : NEW_LINE INDENT if ( i % ( j * j ) == 0 ) : NEW_LINE INDENT isSqFree = False ; NEW_LINE break ; NEW_LINE DEDENT j += 1 ; NEW_LINE DEDENT if ( isSqFree == True ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE if ( cnt == n ) : NEW_LINE INDENT return i ; NEW_LINE DEDENT DEDENT i += 1 ; NEW_LINE DEDENT return 0 ; NEW_LINE DEDENT
def getMaximumSumWithLCMN ( N ) : NEW_LINE INDENT sum = 0 NEW_LINE LIM = int ( math . sqrt ( N ) ) NEW_LINE for i in range ( 1 , LIM + 1 ) : NEW_LINE INDENT if ( N % i == 0 ) : NEW_LINE INDENT if ( i == ( N // i ) ) : NEW_LINE INDENT sum = sum + i NEW_LINE DEDENT else : NEW_LINE INDENT sum = sum + ( i + N // i ) NEW_LINE DEDENT DEDENT DEDENT return sum NEW_LINE DEDENT
def smallestSubWithSum ( arr , n , x ) : NEW_LINE INDENT min_len = n + 1 NEW_LINE for start in range ( 0 , n ) : NEW_LINE INDENT curr_sum = arr [ start ] NEW_LINE if ( curr_sum > x ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT for end in range ( start + 1 , n ) : NEW_LINE INDENT curr_sum += arr [ end ] NEW_LINE if curr_sum > x and ( end - start + 1 ) < min_len : NEW_LINE INDENT min_len = ( end - start + 1 ) NEW_LINE DEDENT DEDENT DEDENT return min_len ; NEW_LINE DEDENT
def converthenumber ( n ) : NEW_LINE INDENT s = str ( n ) ; NEW_LINE res = " " ; NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == '1' or s [ i ] == '3' or s [ i ] == '5' or s [ i ] == '7' or s [ i ] == '9' ) : NEW_LINE INDENT res += s [ i ] ; NEW_LINE DEDENT if ( len ( res ) == 2 ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT if ( len ( res ) == 2 ) : NEW_LINE INDENT print ( res ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " - 1" ) ; NEW_LINE DEDENT DEDENT
def find_Square_369 ( num ) : NEW_LINE INDENT if ( num [ 0 ] == '3' ) : NEW_LINE INDENT a = '1' NEW_LINE b = '0' NEW_LINE c = '8' NEW_LINE d = '9' NEW_LINE DEDENT elif ( num [ 0 ] == '6' ) : NEW_LINE INDENT a = '4' NEW_LINE b = '3' NEW_LINE c = '5' NEW_LINE d = '6' NEW_LINE DEDENT else : NEW_LINE INDENT a = '9' NEW_LINE b = '8' NEW_LINE c = '0' NEW_LINE d = '1' NEW_LINE DEDENT result = " " NEW_LINE size = len ( num ) NEW_LINE for i in range ( 1 , size ) : NEW_LINE INDENT result += a NEW_LINE DEDENT result += b NEW_LINE for i in range ( 1 , size ) : NEW_LINE INDENT result += c NEW_LINE DEDENT result += d NEW_LINE return result NEW_LINE DEDENT
def product_subarrays ( arr , n ) : NEW_LINE INDENT product = 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT product *= arr [ j ] ; NEW_LINE DEDENT DEDENT print ( product ) ; NEW_LINE DEDENT
def smallestKFreq ( arr , n , k ) : NEW_LINE INDENT mp = defaultdict ( lambda : 0 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT res = sys . maxsize NEW_LINE res1 = sys . maxsize NEW_LINE for key , values in mp . items ( ) : NEW_LINE INDENT if values == k : NEW_LINE INDENT res = min ( res , key ) NEW_LINE DEDENT DEDENT return res if res != res1 else - 1 NEW_LINE DEDENT
def rotate ( arr , n ) : NEW_LINE INDENT x = arr [ n - 1 ] NEW_LINE for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT arr [ i ] = arr [ i - 1 ] ; NEW_LINE DEDENT arr [ 0 ] = x ; NEW_LINE DEDENT
def findMin ( arr , n ) : NEW_LINE INDENT m = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT m = max ( m , arr [ i ] ) NEW_LINE DEDENT freq = [ 0 ] * ( m + 2 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( 1 , m + 2 ) : NEW_LINE INDENT j = i NEW_LINE cnt = 0 NEW_LINE while ( j <= m ) : NEW_LINE INDENT cnt += freq [ j ] NEW_LINE j += i NEW_LINE DEDENT if ( not cnt ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return m + 1 NEW_LINE DEDENT
def CalculateRatio ( m , n ) : NEW_LINE INDENT return ( 2 * m - 1 ) / ( 2 * n - 1 ) ; NEW_LINE DEDENT
def kBitDifferencePairs ( arr , n , k ) : NEW_LINE INDENT MAX = max ( arr ) NEW_LINE count = [ 0 for i in range ( MAX + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ arr [ i ] ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE if ( k == 0 ) : NEW_LINE INDENT for i in range ( MAX + 1 ) : NEW_LINE INDENT ans += ( count [ i ] * ( count [ i ] - 1 ) ) // 2 NEW_LINE DEDENT return ans NEW_LINE DEDENT for i in range ( MAX + 1 ) : NEW_LINE INDENT if ( count [ i ] == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT for j in range ( i + 1 , MAX + 1 ) : NEW_LINE INDENT if ( bin ( i ^ j ) . count ( '1' ) == k ) : NEW_LINE INDENT ans += count [ i ] * count [ j ] NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def isDivisible ( n ) : NEW_LINE INDENT while n // 100 : NEW_LINE INDENT d = n % 10 NEW_LINE n //= 10 NEW_LINE n = abs ( n - ( d * 3 ) ) NEW_LINE DEDENT return ( n % 31 == 0 ) NEW_LINE DEDENT
def findMinCost ( arr , n , choc_cost ) : NEW_LINE INDENT choc_buy = arr [ 0 ] NEW_LINE curr_choc = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT choc = arr [ i ] - arr [ i + 1 ] NEW_LINE curr_choc += choc NEW_LINE if ( curr_choc < 0 ) : NEW_LINE INDENT choc_buy += abs ( curr_choc ) NEW_LINE curr_choc = 0 NEW_LINE DEDENT DEDENT return choc_buy * choc_cost NEW_LINE DEDENT
def binaryToDecimal ( n ) : NEW_LINE INDENT num = n ; NEW_LINE dec_value = 0 ; NEW_LINE base = 1 ; NEW_LINE temp = num ; NEW_LINE while ( temp ) : NEW_LINE INDENT last_digit = temp % 10 ; NEW_LINE temp = int ( temp / 10 ) ; NEW_LINE dec_value += last_digit * base ; NEW_LINE base = base * 2 ; NEW_LINE DEDENT return dec_value ; NEW_LINE DEDENT
def profitLoss ( N , M ) : NEW_LINE INDENT if ( N == M ) : NEW_LINE INDENT print ( " No ▁ Profit ▁ nor ▁ Loss " ) NEW_LINE DEDENT else : NEW_LINE INDENT result = 0.0 NEW_LINE result = float ( abs ( N - M ) ) / M NEW_LINE if ( N - M < 0 ) : NEW_LINE INDENT print ( " Loss ▁ = ▁ - " , ' { 0 : . 6 } ' . format ( result * 100 ) , " % " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Profit ▁ = ▁ " , ' { 0 : . 6 } ' . format ( result * 100 ) , " % " ) NEW_LINE DEDENT DEDENT DEDENT
def swapDiagonal ( matrix ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT matrix [ i ] [ i ] , matrix [ i ] [ N - i - 1 ] =   \ NEW_LINE INDENT matrix [ i ] [ N - i - 1 ] , matrix [ i ] [ i ] NEW_LINE DEDENT DEDENT DEDENT
def count ( S , m , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n < 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( m <= 0 and n >= 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return count ( S , m - 1 , n ) + count ( S , m , n - S [ m - 1 ] ) ; NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return 7 * pow ( n , 2 ) - 7 * n + 7 NEW_LINE DEDENT
def longestFibonacciSubarray ( n , a ) : NEW_LINE INDENT if ( n <= 2 ) : NEW_LINE INDENT return n NEW_LINE DEDENT Len = 2 NEW_LINE mx = - 10 ** 9 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if ( a [ i ] == a [ i - 1 ] + a [ i - 2 ] ) : NEW_LINE INDENT Len += 1 NEW_LINE DEDENT else : NEW_LINE INDENT Len = 2 NEW_LINE DEDENT mx = max ( mx , Len ) NEW_LINE DEDENT return mx NEW_LINE DEDENT
def term ( n ) : NEW_LINE INDENT x = ( ( ( 1 ) + math . sqrt ( 1 + ( 8 * n ) ) ) / 2 ) NEW_LINE return x NEW_LINE DEDENT
def polydiagonal ( n , a ) : NEW_LINE INDENT if ( a < 0 and n < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return ( 2 * a * mt . sin ( ( ( ( n - 2 ) * 180 ) / ( 2 * n ) ) * 3.14159 / 180 ) ) NEW_LINE DEDENT
def angle ( n ) : NEW_LINE INDENT return 2 * n NEW_LINE DEDENT
def substringConversions ( s , k , b ) : NEW_LINE INDENT l = len ( s ) ; NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( ( i + k ) < l + 1 ) : NEW_LINE INDENT sub = s [ i : i + k ] ; NEW_LINE sum , counter = 0 , 0 ; NEW_LINE for i in range ( len ( sub ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT sum = sum + ( ( ord ( sub [ i ] ) - ord ( '0' ) ) * pow ( b , counter ) ) ; NEW_LINE counter += 1 ; NEW_LINE DEDENT print ( sum , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT DEDENT
def maxSum ( a , n ) : NEW_LINE INDENT ans = 0 NEW_LINE arr = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT arr [ i ] = a [ i - 1 ] NEW_LINE DEDENT dp = [ [ 0 for i in range ( 3 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = max ( arr [ i ] , dp [ i - 1 ] [ 0 ] + arr [ i ] ) NEW_LINE dp [ i ] [ 1 ] = max ( 0 , dp [ i - 1 ] [ 0 ] ) - arr [ i ] NEW_LINE if i >= 2 : NEW_LINE INDENT dp [ i ] [ 1 ] = max ( dp [ i ] [ 1 ] , dp [ i - 1 ] [ 1 ] + arr [ i ] ) NEW_LINE DEDENT if i >= 2 : NEW_LINE INDENT dp [ i ] [ 2 ] = dp [ i - 1 ] [ 1 ] - arr [ i ] NEW_LINE DEDENT if i >= 3 : NEW_LINE INDENT dp [ i ] [ 2 ] = max ( dp [ i ] [ 2 ] , dp [ i - 1 ] [ 2 ] + arr [ i ] ) NEW_LINE DEDENT ans = max ( ans , dp [ i ] [ 0 ] ) NEW_LINE ans = max ( ans , dp [ i ] [ 1 ] ) NEW_LINE ans = max ( ans , dp [ i ] [ 2 ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def findLen ( arr , n , m ) : NEW_LINE INDENT filter = [ ] ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( arr [ i ] & m ) == m ) : NEW_LINE INDENT filter . append ( arr [ i ] ) ; NEW_LINE DEDENT DEDENT if ( len ( filter ) == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT c_and = filter [ 0 ] ; NEW_LINE for i in range ( 1 , len ( filter ) ) : NEW_LINE INDENT c_and &= filter [ i ] ; NEW_LINE DEDENT if ( c_and == m ) : NEW_LINE INDENT return len ( filter ) ; NEW_LINE DEDENT DEDENT
def minNumber ( a , n , x ) : NEW_LINE INDENT l = 0 NEW_LINE h = 0 NEW_LINE e = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == x : NEW_LINE INDENT e += 1 NEW_LINE DEDENT elif a [ i ] > x : NEW_LINE INDENT h += 1 NEW_LINE DEDENT elif a [ i ] < x : NEW_LINE INDENT l += 1 NEW_LINE DEDENT DEDENT ans = 0 ; NEW_LINE if l > h : NEW_LINE INDENT ans = l - h NEW_LINE DEDENT elif l < h : NEW_LINE INDENT ans = h - l - 1 ; NEW_LINE DEDENT return ans + 1 - e NEW_LINE DEDENT
def printTaxicab2 ( N ) : NEW_LINE INDENT i , count = 1 , 0 NEW_LINE while ( count < N ) : NEW_LINE INDENT int_count = 0 NEW_LINE for j in range ( 1 , int ( pow ( i , 1.0 / 3 ) ) + 1 ) : NEW_LINE INDENT for k in range ( j + 1 , int ( pow ( i , 1.0 / 3 ) ) + 1 ) : NEW_LINE INDENT if ( j * j * j + k * k * k == i ) : NEW_LINE INDENT int_count += 1 NEW_LINE DEDENT DEDENT DEDENT if ( int_count == 2 ) : NEW_LINE INDENT count += 1 NEW_LINE print ( count , " ▁ " , i ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT
def printPattern ( n ) : NEW_LINE INDENT if ( n == 0 or n < 0 ) : NEW_LINE INDENT print ( n , end = " , ▁ " ) NEW_LINE return NEW_LINE DEDENT print ( n , end = " , ▁ " ) NEW_LINE printPattern ( n - 5 ) NEW_LINE print ( n , end = " , ▁ " ) NEW_LINE DEDENT
def findStarNum ( n ) : NEW_LINE INDENT return ( 6 * n * ( n - 1 ) + 1 ) NEW_LINE DEDENT
def getLongestSeq ( a , n ) : NEW_LINE INDENT maxIdx = 0 NEW_LINE maxLen = 0 NEW_LINE currLen = 0 NEW_LINE currIdx = 0 NEW_LINE for k in range ( n ) : NEW_LINE INDENT if a [ k ] > 0 : NEW_LINE INDENT currLen += 1 NEW_LINE if currLen == 1 : NEW_LINE INDENT currIdx = k NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if currLen > maxLen : NEW_LINE INDENT maxLen = currLen NEW_LINE maxIdx = currIdx NEW_LINE DEDENT currLen = 0 NEW_LINE DEDENT DEDENT if maxLen > 0 : NEW_LINE INDENT print ( ' Index ▁ : ▁ ' , maxIdx , ' , Length ▁ : ▁ ' , maxLen , ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ positive ▁ sequence ▁ detected . " ) NEW_LINE DEDENT DEDENT
def countBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT count += 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def findfactors ( n ) : NEW_LINE INDENT vec = [ ] NEW_LINE for i in range ( 1 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT vec . append ( i ) NEW_LINE vec . append ( n // i ) NEW_LINE DEDENT DEDENT vec . sort ( ) NEW_LINE print ( " All ▁ the ▁ factors ▁ are ▁ - > ▁ " , end = " " ) NEW_LINE for i in range ( len ( vec ) ) : NEW_LINE INDENT print ( vec [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE maxProduct = 1 NEW_LINE flag = 1 NEW_LINE for i in range ( 0 , len ( vec ) ) : NEW_LINE INDENT for j in range ( i , len ( vec ) ) : NEW_LINE INDENT for k in range ( j , len ( vec ) ) : NEW_LINE INDENT y = n - vec [ i ] - vec [ j ] - vec [ k ] NEW_LINE if y <= 0 : NEW_LINE INDENT break NEW_LINE DEDENT if n % y == 0 : NEW_LINE INDENT flag = 0 NEW_LINE maxProduct = max ( vec [ i ] * vec [ j ] * vec [ k ] * y , maxProduct ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if flag == 0 : NEW_LINE INDENT print ( " Product ▁ is ▁ - ▁ > " , maxProduct ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ possible " ) NEW_LINE DEDENT DEDENT
def Segment ( x , l , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT ans = 2 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( x [ i ] - l [ i ] > x [ i - 1 ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT elif ( x [ i ] + l [ i ] < x [ i + 1 ] ) : NEW_LINE INDENT x [ i ] = x [ i ] + l [ i ] NEW_LINE ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def isEqualBlock ( n ) : NEW_LINE INDENT first_bit = n % 2 NEW_LINE first_count = 1 NEW_LINE n = n // 2 NEW_LINE while n % 2 == first_bit and n > 0 : NEW_LINE INDENT n = n // 2 NEW_LINE first_count += 1 NEW_LINE DEDENT if n == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT while n > 0 : NEW_LINE INDENT first_bit = n % 2 NEW_LINE curr_count = 1 NEW_LINE n = n // 2 NEW_LINE while n % 2 == first_bit : NEW_LINE INDENT n = n // 2 NEW_LINE curr_count += 1 NEW_LINE DEDENT if curr_count != first_count : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def findLastIndex ( str , x ) : NEW_LINE INDENT index = - 1 NEW_LINE for i in range ( 0 , len ( str ) ) : NEW_LINE INDENT if str [ i ] == x : NEW_LINE INDENT index = i NEW_LINE DEDENT DEDENT return index NEW_LINE DEDENT
def findTerm ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return n NEW_LINE DEDENT else : NEW_LINE INDENT term = 7 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT term = term * 2 + ( i - 1 ) ; NEW_LINE DEDENT DEDENT return term ; NEW_LINE DEDENT
def findSumofEle ( arr1 , m , arr2 , n ) : NEW_LINE INDENT hash = [ 0 for i in range ( MAX ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash [ arr2 [ i ] ] += 1 NEW_LINE DEDENT for i in range ( 1 , MAX , 1 ) : NEW_LINE INDENT hash [ i ] = hash [ i ] + hash [ i - 1 ] NEW_LINE DEDENT maximumFreq = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT maximumFreq = max ( maximumFreq , hash [ arr1 [ i ] ] ) NEW_LINE DEDENT sumOfElements = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT if ( maximumFreq == hash [ arr1 [ i ] ] ) : NEW_LINE INDENT sumOfElements += arr1 [ i ] NEW_LINE DEDENT DEDENT return sumOfElements NEW_LINE DEDENT
def printKDistinct ( arr , n , k ) : NEW_LINE INDENT dist_count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT j = 0 NEW_LINE while j < n : NEW_LINE INDENT if ( i != j and arr [ j ] == arr [ i ] ) : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( j == n ) : NEW_LINE INDENT dist_count += 1 NEW_LINE DEDENT if ( dist_count == k ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def MinimumMail ( n , k , x ) : NEW_LINE INDENT m = ( ( n - 1 ) + int ( math . ceil ( ( n - 1 ) * 1.0 / x ) * ( n - 1 ) + math . ceil ( n * 1.0 / x ) * ( k - n ) ) ) ; NEW_LINE return m ; NEW_LINE DEDENT
def decimalToBinary ( N ) : NEW_LINE INDENT B_Number = 0 NEW_LINE cnt = 0 NEW_LINE while ( N != 0 ) : NEW_LINE INDENT rem = N % 2 NEW_LINE c = pow ( 10 , cnt ) NEW_LINE B_Number += rem * c NEW_LINE N //= 2 NEW_LINE cnt += 1 NEW_LINE DEDENT return B_Number NEW_LINE DEDENT
def getSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT sum = sum + int ( n % 10 ) NEW_LINE n = int ( n / 10 ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def findMaxFrequency ( s ) : NEW_LINE INDENT arr = [ 0 ] * 26 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT arr [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT hash = { } NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ( arr [ i ] != 0 ) : NEW_LINE INDENT if arr [ i ] not in hash : NEW_LINE INDENT hash [ arr [ i ] ] = 0 NEW_LINE DEDENT hash [ arr [ i ] ] += 1 NEW_LINE DEDENT DEDENT max_count = 0 NEW_LINE res = - 1 NEW_LINE for i in hash : NEW_LINE INDENT if ( max_count < hash [ i ] ) : NEW_LINE INDENT res = i NEW_LINE max_count = hash [ i ] NEW_LINE DEDENT DEDENT print ( " Frequency " , res , " is ▁ repeated " , max_count , " times " ) NEW_LINE DEDENT
def countNonIncreasing ( arr , n ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE len = 1 ; NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( arr [ i + 1 ] >= arr [ i ] ) : NEW_LINE INDENT len += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT cnt += ( ( ( len + 1 ) * len ) / 2 ) ; NEW_LINE len = 1 ; NEW_LINE DEDENT DEDENT if ( len > 1 ) : NEW_LINE INDENT cnt += ( ( ( len - 1 ) * len ) / 2 ) ; NEW_LINE DEDENT return int ( cnt ) ; NEW_LINE DEDENT
def ways ( i , arr , n ) : NEW_LINE INDENT if ( i == n - 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT sum = 0 ; NEW_LINE for j in range ( 1 , arr [ i ] + 1 ) : NEW_LINE INDENT if ( i + j < n ) : NEW_LINE INDENT sum += ( ways ( i + j , arr , n ) ) % mod ; NEW_LINE sum %= mod ; NEW_LINE DEDENT DEDENT return int ( sum % mod ) ; NEW_LINE DEDENT
def smallestMultiple ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 5 NEW_LINE DEDENT return pow ( 10 , n - 1 ) NEW_LINE DEDENT
def LeibnizHarmonicTriangle ( n ) : NEW_LINE INDENT C = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ] ; NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT for j in range ( 0 , min ( i , n ) + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) ; NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT print ( "1 / " , end = " " ) ; NEW_LINE print ( i * C [ i - 1 ] [ j - 1 ] , end = " ▁ " ) ; NEW_LINE DEDENT print ( ) ; NEW_LINE DEDENT DEDENT
def maximumXor ( arr : list , n : int ) -> int : NEW_LINE INDENT sForward , sBackward = [ ] , [ ] NEW_LINE ans = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT while len ( sForward ) > 0 and arr [ i ] < arr [ sForward [ - 1 ] ] : NEW_LINE INDENT ans = max ( ans , arr [ i ] ^ arr [ sForward [ - 1 ] ] ) NEW_LINE sForward . pop ( ) NEW_LINE DEDENT sForward . append ( i ) NEW_LINE while len ( sBackward ) > 0 and arr [ n - i - 1 ] < arr [ sBackward [ - 1 ] ] : NEW_LINE INDENT ans = max ( ans , arr [ n - i - 1 ] ^ arr [ sBackward [ - 1 ] ] ) NEW_LINE sBackward . pop ( ) NEW_LINE DEDENT sBackward . append ( n - i - 1 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def minimumNumbers ( n , s ) : NEW_LINE INDENT if ( s % n ) : NEW_LINE INDENT return s / n + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return s / n ; NEW_LINE DEDENT DEDENT
def GetPrefixSuffix ( a , b , l ) : NEW_LINE INDENT prefix = a [ : l ] ; NEW_LINE lb = len ( b ) ; NEW_LINE suffix = b [ lb - l : ] ; NEW_LINE return ( prefix + suffix ) ; NEW_LINE DEDENT
def findRadiusOfcircumcircle ( l , b ) : NEW_LINE INDENT if ( l < 0 or b < 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT radius = ( math . sqrt ( pow ( l , 2 ) + pow ( b , 2 ) ) / 2 ) ; NEW_LINE return radius ; NEW_LINE DEDENT
def findTrailingZeros ( n ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT ans = 0 NEW_LINE n //= 2 NEW_LINE while ( n ) : NEW_LINE INDENT ans += n // 5 NEW_LINE n //= 5 NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
def makePolygon ( a ) : NEW_LINE INDENT n = 360 / ( 180 - a ) NEW_LINE if n == int ( n ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def sortArrays ( arr , length ) : NEW_LINE INDENT j = 0 NEW_LINE while ( j < length - 1 ) : NEW_LINE INDENT d1 = arr [ j ] NEW_LINE d2 = arr [ j + 1 ] NEW_LINE if ( d1 > d2 ) : NEW_LINE INDENT temp = arr [ j ] NEW_LINE arr [ j ] = arr [ j + 1 ] NEW_LINE arr [ j + 1 ] = temp NEW_LINE j = - 1 NEW_LINE DEDENT j += 1 NEW_LINE DEDENT return arr NEW_LINE DEDENT
def productSumDivisible ( n , size ) : NEW_LINE INDENT sum = 0 NEW_LINE product = 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( size % 2 == 0 ) : NEW_LINE INDENT product *= n % 10 NEW_LINE DEDENT else : NEW_LINE INDENT sum += n % 10 NEW_LINE DEDENT n = n // 10 NEW_LINE size -= 1 NEW_LINE DEDENT if ( product % sum == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def XorSum ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 != 0 ) : NEW_LINE INDENT result += arr [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def findSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += i * ( n - i ) NEW_LINE DEDENT return 2 * sum NEW_LINE DEDENT
def countSubseq ( arr , n ) : NEW_LINE INDENT um = { i : 0 for i in range ( 8 ) } NEW_LINE count = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT um [ arr [ i ] ] += 1 NEW_LINE DEDENT for key , values in um . items ( ) : NEW_LINE INDENT if ( values > 0 ) : NEW_LINE INDENT count *= values NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def solve ( A , B ) : NEW_LINE INDENT p = B / 2 NEW_LINE M = int ( 4 * p ) NEW_LINE N = 1 NEW_LINE O = - 2 * A NEW_LINE Q = int ( A * A + 4 * p * p ) NEW_LINE return [ M , N , O , Q ] NEW_LINE DEDENT
def find ( s1 , s2 ) : NEW_LINE INDENT len__ = len ( s1 ) NEW_LINE len_1 = len ( s2 ) NEW_LINE if ( len__ != len_1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT d = [ 0 for i in range ( len__ ) ] NEW_LINE d [ 0 ] = ord ( s2 [ 0 ] ) - ord ( s1 [ 0 ] ) NEW_LINE for i in range ( 1 , len__ , 1 ) : NEW_LINE INDENT if ( s1 [ i ] > s2 [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT d [ i ] = ord ( s2 [ i ] ) - ord ( s1 [ i ] ) NEW_LINE DEDENT DEDENT for i in range ( len__ - 1 ) : NEW_LINE INDENT if ( d [ i ] < d [ i + 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def composite_factors ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE a = [ 0 ] * ( n + 1 ) ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT a [ i ] = i ; NEW_LINE DEDENT DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT j = 2 ; NEW_LINE p = 1 ; NEW_LINE while ( j < a [ i ] ) : NEW_LINE INDENT if ( a [ i ] % j == 0 ) : NEW_LINE INDENT p = 0 ; NEW_LINE break ; NEW_LINE DEDENT j += 1 ; NEW_LINE DEDENT if ( p == 0 and a [ i ] != 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT
def Calculate_area ( ) : NEW_LINE INDENT b = 3 NEW_LINE h = 4 NEW_LINE s1 = 3 NEW_LINE s2 = 6 NEW_LINE s3 = 6 NEW_LINE Ht = 8 NEW_LINE SA = b * h + ( s1 + s2 + s3 ) * Ht NEW_LINE print ( " The ▁ area ▁ of ▁ triangular ▁ prism ▁ is ▁ : " , SA ) NEW_LINE DEDENT
def printSeriessumm ( N ) : NEW_LINE INDENT summ = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT summ += pow ( i , i - 1 ) NEW_LINE DEDENT print ( summ ) NEW_LINE DEDENT
def solve ( X , Y , l , r , k , dp ) : NEW_LINE INDENT if k == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if l < 0 or r < 0 : NEW_LINE INDENT return 1000000000 NEW_LINE DEDENT if dp [ l ] [ r ] [ k ] != - 1 : NEW_LINE INDENT return dp [ l ] [ r ] [ k ] NEW_LINE DEDENT cost = ( ( ord ( X [ l ] ) - ord ( ' a ' ) ) ^ ( ord ( Y [ r ] ) - ord ( ' a ' ) ) ) NEW_LINE dp [ l ] [ r ] [ k ] = min ( [ cost + solve ( X , Y , l - 1 , r - 1 , k - 1 , dp ) , solve ( X , Y , l - 1 , r , k , dp ) , solve ( X , Y , l , r - 1 , k , dp ) ] ) NEW_LINE return dp [ l ] [ r ] [ k ] NEW_LINE DEDENT
def getSingle ( arr , n ) : NEW_LINE INDENT ones = 0 NEW_LINE twos = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT twos = twos | ( ones & arr [ i ] ) NEW_LINE ones = ones ^ arr [ i ] NEW_LINE common_bit_mask = ~ ( ones & twos ) NEW_LINE ones &= common_bit_mask NEW_LINE twos &= common_bit_mask NEW_LINE DEDENT return ones NEW_LINE DEDENT
def PossibleValues ( b , x , n ) : NEW_LINE INDENT leastdivisible = int ( b / x + 1 ) * x NEW_LINE flag = 1 NEW_LINE while ( leastdivisible <= n ) : NEW_LINE INDENT if ( leastdivisible - b >= 1 ) : NEW_LINE INDENT print ( leastdivisible - b , end = " ▁ " ) NEW_LINE leastdivisible += x NEW_LINE flag = 0 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( flag != 0 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT
def evaluateBoolExpr ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( 0 , n - 2 , 2 ) : NEW_LINE INDENT if ( s [ i + 1 ] == " A " ) : NEW_LINE INDENT if ( s [ i + 2 ] == "0" or s [ i ] == "0" ) : NEW_LINE INDENT s [ i + 2 ] = "0" NEW_LINE DEDENT else : NEW_LINE INDENT s [ i + 2 ] = "1" NEW_LINE DEDENT DEDENT elif ( s [ i + 1 ] == " B " ) : NEW_LINE INDENT if ( s [ i + 2 ] == "1" or s [ i ] == "1" ) : NEW_LINE INDENT s [ i + 2 ] = "1" NEW_LINE DEDENT else : NEW_LINE INDENT s [ i + 2 ] = "0" NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( s [ i + 2 ] == s [ i ] ) : NEW_LINE INDENT s [ i + 2 ] = "0" NEW_LINE DEDENT else : NEW_LINE INDENT s [ i + 2 ] = "1" NEW_LINE DEDENT DEDENT DEDENT return ord ( s [ n - 1 ] ) - ord ( "0" ) NEW_LINE DEDENT
def multiply ( array , n ) : NEW_LINE INDENT pro = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT pro = pro * array [ i ] NEW_LINE DEDENT return pro NEW_LINE DEDENT
def find ( n , m ) : NEW_LINE INDENT if ( n <= 2 * m ) : NEW_LINE INDENT print ( " Minimum ▁ " , 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Minimum ▁ " , n - 2 * m ) NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i * ( i - 1 ) // 2 >= m ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( " Maximum ▁ " , n - i ) NEW_LINE DEDENT
def display ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT k = i NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT if k % 2 == 0 : NEW_LINE INDENT print ( j , end = ' ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' * ' , end = ' ' ) NEW_LINE DEDENT k -= 1 NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return gcd ( a - b , b ) NEW_LINE DEDENT return gcd ( a , b - a ) NEW_LINE DEDENT
def maxdiff ( arr , n ) : NEW_LINE INDENT freq = defaultdict ( lambda : 0 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ arr [ i ] ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if freq [ arr [ i ] ] > freq [ arr [ j ] ] and arr [ i ] > arr [ j ] : NEW_LINE INDENT ans = max ( ans , freq [ arr [ i ] ] - freq [ arr [ j ] ] ) NEW_LINE DEDENT elif freq [ arr [ i ] ] < freq [ arr [ j ] ] and arr [ i ] < arr [ j ] : NEW_LINE INDENT ans = max ( ans , freq [ arr [ j ] ] - freq [ arr [ i ] ] ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def isPowerOfK ( n , k ) : NEW_LINE INDENT oneSeen = False NEW_LINE while ( n > 0 ) : NEW_LINE INDENT digit = n % k NEW_LINE if ( digit > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( digit == 1 ) : NEW_LINE INDENT if ( oneSeen ) : NEW_LINE INDENT return False NEW_LINE DEDENT oneSeen = True NEW_LINE DEDENT n //= k NEW_LINE DEDENT return True NEW_LINE DEDENT
def countIntervals ( arr , V , N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT li = arr [ i ] [ 0 ] NEW_LINE ri = arr [ i ] [ 1 ] NEW_LINE if ( V >= li and V <= ri ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT
def fill0X ( m , n ) : NEW_LINE INDENT i , k , l = 0 , 0 , 0 NEW_LINE r = m NEW_LINE c = n NEW_LINE a = [ [ None ] * n for i in range ( m ) ] NEW_LINE x = ' X ' NEW_LINE while k < m and l < n : NEW_LINE INDENT for i in range ( l , n ) : NEW_LINE INDENT a [ k ] [ i ] = x NEW_LINE DEDENT k += 1 NEW_LINE for i in range ( k , m ) : NEW_LINE INDENT a [ i ] [ n - 1 ] = x NEW_LINE DEDENT n -= 1 NEW_LINE if k < m : NEW_LINE INDENT for i in range ( n - 1 , l - 1 , - 1 ) : NEW_LINE INDENT a [ m - 1 ] [ i ] = x NEW_LINE DEDENT m -= 1 NEW_LINE DEDENT if l < n : NEW_LINE INDENT for i in range ( m - 1 , k - 1 , - 1 ) : NEW_LINE INDENT a [ i ] [ l ] = x NEW_LINE DEDENT l += 1 NEW_LINE DEDENT x = ' X ' if x == '0' else '0' NEW_LINE DEDENT for i in range ( r ) : NEW_LINE INDENT for j in range ( c ) : NEW_LINE INDENT print ( a [ i ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT
def weightedMean ( n ) : NEW_LINE INDENT return ( 2 * n + 1 ) / 3 NEW_LINE DEDENT
def minMoves ( n , a , k ) : NEW_LINE INDENT ct1 = [ 0 for i in range ( k ) ] NEW_LINE ct0 = [ 0 for i in range ( k ) ] NEW_LINE moves = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == 1 ) : NEW_LINE INDENT ct1 [ i % k ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ct0 [ i % k ] += 1 NEW_LINE DEDENT DEDENT for i in range ( k ) : NEW_LINE INDENT moves += min ( ct1 [ i ] , ct0 [ i ] ) NEW_LINE DEDENT return moves NEW_LINE DEDENT
def printXYZ ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " x ▁ is ▁ " , n ) NEW_LINE print ( " y ▁ is ▁ " , n + 1 ) NEW_LINE print ( " z ▁ is ▁ " , n * ( n + 1 ) ) NEW_LINE DEDENT DEDENT
def equalize ( arr , n , k ) : NEW_LINE INDENT min_ele = min ( arr ) ; NEW_LINE flag = True ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( not ( ( arr [ i ] + k ) >= ( min_ele + k ) and ( min_ele + k ) >= ( arr [ i ] - k ) ) ) : NEW_LINE INDENT flag = False ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( flag ) : NEW_LINE INDENT return min_ele + k ; NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT DEDENT
def minflip ( arr1 , arr2 , arr3 , p , q , n ) : NEW_LINE INDENT flip = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr1 [ i ] ^ arr2 [ i ] != arr3 [ i ] ) : NEW_LINE INDENT flip += 1 NEW_LINE DEDENT DEDENT return flip if ( flip <= p + q ) else - 1 NEW_LINE DEDENT
def maxLength ( a , n ) : NEW_LINE INDENT maximum = 1 ; NEW_LINE left = [ 0 ] * n ; NEW_LINE right = [ 0 ] * n ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT left [ i ] = 1 ; NEW_LINE right [ i ] = 1 ; NEW_LINE DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( a [ i ] > a [ i + 1 ] ) : NEW_LINE INDENT right [ i ] = right [ i + 1 ] + 1 ; NEW_LINE DEDENT maximum = max ( maximum , right [ i ] ) ; NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( a [ i ] < a [ i - 1 ] ) : NEW_LINE INDENT left [ i ] = left [ i - 1 ] + 1 ; NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( a [ i - 1 ] > a [ i + 1 ] ) : NEW_LINE INDENT maximum = max ( maximum , left [ i - 1 ] + right [ i + 1 ] ) ; NEW_LINE DEDENT DEDENT DEDENT return maximum ; NEW_LINE DEDENT
def count ( S , m , n ) : NEW_LINE INDENT table = [ [ 0 for x in range ( m ) ] for x in range ( n + 1 ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT table [ 0 ] [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT x = table [ i - S [ j ] ] [ j ] if i - S [ j ] >= 0 else 0 NEW_LINE y = table [ i ] [ j - 1 ] if j >= 1 else 0 NEW_LINE table [ i ] [ j ] = x + y NEW_LINE DEDENT DEDENT return table [ n ] [ m - 1 ] NEW_LINE DEDENT
def maxSum ( arr , i , n , k ) : NEW_LINE INDENT if ( i >= n ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( visit [ i ] ) : NEW_LINE INDENT return dp [ i ] ; NEW_LINE DEDENT visit [ i ] = 1 ; NEW_LINE tot = 0 ; NEW_LINE dp [ i ] = maxSum ( arr , i + 1 , n , k ) ; NEW_LINE j = i NEW_LINE while ( j < i + k and j < n ) : NEW_LINE INDENT tot += arr [ j ] ; NEW_LINE dp [ i ] = max ( dp [ i ] , tot + maxSum ( arr , j + 2 , n , k ) ) ; NEW_LINE j += 1 NEW_LINE DEDENT return dp [ i ] ; NEW_LINE DEDENT
def printNonDivisible ( A , B , n , m ) : NEW_LINE INDENT maxB = 0 NEW_LINE for i in range ( 0 , m , 1 ) : NEW_LINE INDENT if ( B [ i ] > maxB ) : NEW_LINE INDENT maxB = B [ i ] NEW_LINE DEDENT DEDENT mark = [ 0 for i in range ( maxB ) ] NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT for x in range ( A [ i ] , maxB , A [ i ] ) : NEW_LINE INDENT mark [ x ] += 1 NEW_LINE DEDENT DEDENT for i in range ( 0 , m - 1 , 1 ) : NEW_LINE INDENT if ( mark [ B [ i ] ] == 0 ) : NEW_LINE INDENT print ( B [ i ] ) NEW_LINE DEDENT DEDENT DEDENT
def nthTerm ( N ) : NEW_LINE INDENT return ( ( 2 * N + 3 ) * ( 2 * N + 3 ) - 2 * N ) ; NEW_LINE DEDENT
def findNumber ( n ) : NEW_LINE INDENT n -= 1 NEW_LINE i = 1 NEW_LINE while n >= 0 : NEW_LINE INDENT n -= i NEW_LINE i += 1 NEW_LINE DEDENT return ( n + i ) NEW_LINE DEDENT
def sumOfSeries ( num ) : NEW_LINE INDENT res = 0 NEW_LINE fact = 1 NEW_LINE for i in range ( 1 , num + 1 ) : NEW_LINE INDENT fact *= i NEW_LINE res = res + ( i / fact ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def solve ( arr , n ) : NEW_LINE INDENT k = len ( arr ) NEW_LINE mp = [ False for i in range ( n + 2 ) ] NEW_LINE for i in range ( k ) : NEW_LINE INDENT mp [ arr [ i ] ] = True NEW_LINE DEDENT leftSegment = arr [ 0 ] - 1 NEW_LINE for i in range ( 1 , k ) : NEW_LINE INDENT leftSegment = max ( leftSegment , arr [ i ] - arr [ i - 1 ] - 1 ) NEW_LINE DEDENT rightSegment = n - arr [ k - 1 ] NEW_LINE maxSegment = max ( leftSegment , rightSegment ) ; NEW_LINE tim = 0 NEW_LINE if ( maxSegment & 1 ) : NEW_LINE INDENT tim = ( maxSegment // 2 ) + 1 NEW_LINE DEDENT else : NEW_LINE INDENT tim = maxSegment // 2 NEW_LINE DEDENT return tim NEW_LINE DEDENT
def validate ( n ) : NEW_LINE INDENT for i in range ( 10 ) : NEW_LINE INDENT temp = n ; NEW_LINE count = 0 ; NEW_LINE while ( temp ) : NEW_LINE INDENT if ( temp % 10 == i ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT if ( count > i ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT temp //= 10 ; NEW_LINE DEDENT DEDENT return 1 ; NEW_LINE DEDENT
def removeChars ( str , k ) : NEW_LINE INDENT hash = [ 0 ] * ( MAX_CHAR ) NEW_LINE n = len ( str ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT res = " " NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( hash [ ord ( str [ i ] ) - ord ( ' a ' ) ] >= k ) : NEW_LINE INDENT res += str [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def subsetGraph ( C ) : NEW_LINE INDENT global N NEW_LINE vertices = set ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT vertices . add ( i ) NEW_LINE DEDENT while ( len ( vertices ) != 0 ) : NEW_LINE INDENT if ( len ( vertices ) == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT someone_removed = False NEW_LINE for x in vertices : NEW_LINE INDENT values = set ( ) NEW_LINE for y in vertices : NEW_LINE INDENT if ( y != x ) : NEW_LINE INDENT values . add ( C [ x ] [ y ] ) NEW_LINE DEDENT DEDENT if ( len ( values ) == 1 ) : NEW_LINE INDENT vertices . remove ( x ) NEW_LINE someone_removed = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( not someone_removed ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return len ( vertices ) NEW_LINE DEDENT
def averageOdd ( n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT print ( " Invalid ▁ Input " ) NEW_LINE return - 1 NEW_LINE DEDENT sm = 0 NEW_LINE count = 0 NEW_LINE while ( n >= 1 ) : NEW_LINE INDENT count = count + 1 NEW_LINE sm = sm + n NEW_LINE n = n - 2 NEW_LINE DEDENT return sm // count NEW_LINE DEDENT
def waysToSplit ( s ) : NEW_LINE INDENT n = len ( s ) ; NEW_LINE answer = 0 ; NEW_LINE prefix = [ 0 ] * n ; NEW_LINE suffix = [ 0 ] * n ; NEW_LINE seen = [ 0 ] * 26 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT prev = prefix [ i - 1 ] if ( i - 1 >= 0 ) else 0 ; NEW_LINE if ( seen [ ord ( s [ i ] ) - ord ( ' a ' ) ] == 0 ) : NEW_LINE INDENT prefix [ i ] += ( prev + 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT prefix [ i ] = prev ; NEW_LINE DEDENT seen [ ord ( s [ i ] ) - ord ( ' a ' ) ] = 1 ; NEW_LINE DEDENT seen = [ 0 ] * len ( seen ) ; NEW_LINE suffix [ n - 1 ] = 0 ; NEW_LINE for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT prev = suffix [ i ] ; NEW_LINE if ( seen [ ord ( s [ i ] ) - ord ( ' a ' ) ] == 0 ) : NEW_LINE INDENT suffix [ i - 1 ] += ( prev + 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT suffix [ i - 1 ] = prev ; NEW_LINE DEDENT seen [ ord ( s [ i ] ) - ord ( ' a ' ) ] = 1 ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( prefix [ i ] == suffix [ i ] ) : NEW_LINE INDENT answer += 1 ; NEW_LINE DEDENT DEDENT return answer ; NEW_LINE DEDENT
def Square ( row , column , moves ) : NEW_LINE INDENT a = 0 ; b = 0 ; c = 0 ; NEW_LINE d = 0 ; total = 0 ; NEW_LINE a = row - moves ; NEW_LINE b = row + moves ; NEW_LINE c = column - moves ; NEW_LINE d = column + moves ; NEW_LINE if ( a < 1 ) : NEW_LINE INDENT a = 1 ; NEW_LINE DEDENT if ( c < 1 ) : NEW_LINE INDENT c = 1 ; NEW_LINE DEDENT if ( b > 8 ) : NEW_LINE INDENT b = 8 ; NEW_LINE DEDENT if ( d > 8 ) : NEW_LINE INDENT d = 8 ; NEW_LINE DEDENT total = ( b - a + 1 ) * ( d - c + 1 ) - 1 ; NEW_LINE return total ; NEW_LINE DEDENT
def countDistictSubarray ( arr , n ) : NEW_LINE INDENT vis = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT vis [ arr [ i ] ] = 1 NEW_LINE DEDENT k = len ( vis ) NEW_LINE vid = dict ( ) NEW_LINE ans = 0 NEW_LINE right = 0 NEW_LINE window = 0 NEW_LINE for left in range ( n ) : NEW_LINE INDENT while ( right < n and window < k ) : NEW_LINE INDENT if arr [ right ] in vid . keys ( ) : NEW_LINE INDENT vid [ arr [ right ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT vid [ arr [ right ] ] = 1 NEW_LINE DEDENT if ( vid [ arr [ right ] ] == 1 ) : NEW_LINE INDENT window += 1 NEW_LINE DEDENT right += 1 NEW_LINE DEDENT if ( window == k ) : NEW_LINE INDENT ans += ( n - right + 1 ) NEW_LINE DEDENT vid [ arr [ left ] ] -= 1 NEW_LINE if ( vid [ arr [ left ] ] == 0 ) : NEW_LINE INDENT window -= 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def checkEVENodd ( arr , n , l , r ) : NEW_LINE INDENT if ( arr [ r ] == 1 ) : NEW_LINE INDENT print ( " odd " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " even " ) NEW_LINE DEDENT DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return 5 * pow ( n , 2 ) - 5 * n NEW_LINE DEDENT
def countStr ( n , bCount , cCount ) : NEW_LINE INDENT if ( bCount < 0 or cCount < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( bCount == 0 and cCount == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT res = countStr ( n - 1 , bCount , cCount ) NEW_LINE res += countStr ( n - 1 , bCount - 1 , cCount ) NEW_LINE res += countStr ( n - 1 , bCount , cCount - 1 ) NEW_LINE return res NEW_LINE DEDENT
def getPairsCount ( arr , n , sum ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if arr [ i ] + arr [ j ] == sum : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return 2 * pow ( n , 2 ) + 4 * n - 2 NEW_LINE DEDENT
def findNumbers ( n ) : NEW_LINE INDENT i = 1 NEW_LINE while ( i <= n ) : NEW_LINE INDENT print ( ( 3 * i * ( i - 1 ) + 1 ) , end = " ▁ " ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT
def findPermutation ( n ) : NEW_LINE INDENT len = ceil ( log10 ( n ) ) NEW_LINE for i in range ( 0 , len , 1 ) : NEW_LINE INDENT if n % 2 != 0 : NEW_LINE INDENT return n NEW_LINE DEDENT else : NEW_LINE INDENT n = ( ( n / 10 ) + ( n % 10 ) * pow ( 10 , len - i - 1 ) ) NEW_LINE continue NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def findMissing ( a , b , n , m ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( a [ i ] == b [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( j == m - 1 ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def maxLenSub ( arr , n ) : NEW_LINE INDENT mls = [ ] NEW_LINE max = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT mls . append ( 1 ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( abs ( arr [ i ] - arr [ j ] ) <= 1 and mls [ i ] < mls [ j ] + 1 ) : NEW_LINE INDENT mls [ i ] = mls [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( max < mls [ i ] ) : NEW_LINE INDENT max = mls [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT
def maxSum ( arr ) : NEW_LINE INDENT dp = np . zeros ( ( n + 1 , 3 ) ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT m1 = 0 ; m2 = 0 ; m3 = 0 ; NEW_LINE for j in range ( m ) : NEW_LINE INDENT if ( ( j // ( m // 3 ) ) == 0 ) : NEW_LINE INDENT m1 = max ( m1 , arr [ i ] [ j ] ) ; NEW_LINE DEDENT elif ( ( j // ( m // 3 ) ) == 1 ) : NEW_LINE INDENT m2 = max ( m2 , arr [ i ] [ j ] ) ; NEW_LINE DEDENT elif ( ( j // ( m // 3 ) ) == 2 ) : NEW_LINE INDENT m3 = max ( m3 , arr [ i ] [ j ] ) ; NEW_LINE DEDENT DEDENT dp [ i + 1 ] [ 0 ] = max ( dp [ i ] [ 1 ] , dp [ i ] [ 2 ] ) + m1 ; NEW_LINE dp [ i + 1 ] [ 1 ] = max ( dp [ i ] [ 0 ] , dp [ i ] [ 2 ] ) + m2 ; NEW_LINE dp [ i + 1 ] [ 2 ] = max ( dp [ i ] [ 1 ] , dp [ i ] [ 0 ] ) + m3 ; NEW_LINE DEDENT print ( max ( max ( dp [ n ] [ 0 ] , dp [ n ] [ 1 ] ) , dp [ n ] [ 2 ] ) ) ; NEW_LINE DEDENT
def run_tasks ( A , B ) : NEW_LINE INDENT total_time = 0 NEW_LINE while ( len ( A ) > 0 ) : NEW_LINE INDENT x = A . popleft ( ) NEW_LINE y = B . popleft ( ) NEW_LINE if ( x == y ) : NEW_LINE INDENT total_time += 1 NEW_LINE DEDENT else : NEW_LINE INDENT B . appendleft ( y ) NEW_LINE A . append ( x ) NEW_LINE total_time += 2 NEW_LINE DEDENT DEDENT return total_time NEW_LINE DEDENT
def findNthTerm ( n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT n = n // 2 NEW_LINE n = 2 * ( n - 1 ) NEW_LINE print ( n // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT n = ( n // 2 ) + 1 NEW_LINE n = 2 * ( n - 1 ) NEW_LINE print ( n ) NEW_LINE DEDENT DEDENT
def lastElement ( a , n ) : NEW_LINE INDENT steps = 1 NEW_LINE v = [ [ ] for i in range ( n ) ] NEW_LINE if n == 1 : return a [ 0 ] NEW_LINE for i in range ( 0 , n , 2 ) : NEW_LINE INDENT v [ steps ] . append ( a [ i ] | a [ i + 1 ] ) NEW_LINE DEDENT while len ( v [ steps ] ) > 1 : NEW_LINE INDENT steps += 1 NEW_LINE for i in range ( 0 , len ( v [ steps - 1 ] ) , 2 ) : NEW_LINE INDENT if steps & 1 : NEW_LINE INDENT v [ steps ] . append ( v [ steps - 1 ] [ i ] | v [ steps - 1 ] [ i + 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT v [ steps ] . append ( v [ steps - 1 ] [ i ] ^ v [ steps - 1 ] [ i + 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return v [ steps ] [ 0 ] NEW_LINE DEDENT
def powerSet ( string , index , curr ) : NEW_LINE INDENT if index == len ( string ) : NEW_LINE INDENT print ( curr ) NEW_LINE return NEW_LINE DEDENT powerSet ( string , index + 1 , curr + string [ index ] ) NEW_LINE powerSet ( string , index + 1 , curr ) NEW_LINE DEDENT
def valueofX ( ar , n ) : NEW_LINE INDENT summ = sum ( ar ) NEW_LINE if ( summ % n == 0 ) : NEW_LINE INDENT return summ // n NEW_LINE DEDENT else : NEW_LINE INDENT A = summ // n NEW_LINE B = summ // n + 1 NEW_LINE ValueA = 0 NEW_LINE ValueB = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ValueA += ( ar [ i ] - A ) * ( ar [ i ] - A ) NEW_LINE ValueB += ( ar [ i ] - B ) * ( ar [ i ] - B ) NEW_LINE DEDENT if ( ValueA < ValueB ) : NEW_LINE INDENT return A NEW_LINE DEDENT else : NEW_LINE INDENT return B NEW_LINE DEDENT DEDENT DEDENT
def isDivisiblePalindrome ( n ) : NEW_LINE INDENT hash = [ 0 ] * 10 NEW_LINE digitSum = 0 NEW_LINE while ( n ) : NEW_LINE INDENT digitSum += n % 10 NEW_LINE hash [ n % 10 ] += 1 NEW_LINE n //= 10 NEW_LINE DEDENT if ( digitSum % 3 != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT oddCount = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT if ( hash [ i ] % 2 != 0 ) : NEW_LINE INDENT oddCount += 1 NEW_LINE DEDENT DEDENT if ( oddCount > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT
def longestPrefixSuffix ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE lps = [ 0 ] * n NEW_LINE l = 0 NEW_LINE i = 1 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( s [ i ] == s [ l ] ) : NEW_LINE INDENT l = l + 1 NEW_LINE lps [ i ] = l NEW_LINE i = i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( l != 0 ) : NEW_LINE INDENT l = lps [ l - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT lps [ i ] = 0 NEW_LINE i = i + 1 NEW_LINE DEDENT DEDENT DEDENT res = lps [ n - 1 ] NEW_LINE if ( res > n / 2 ) : NEW_LINE INDENT return n // 2 NEW_LINE DEDENT else : NEW_LINE INDENT return res NEW_LINE DEDENT DEDENT
def expectedSteps ( x ) : NEW_LINE INDENT if ( x == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( x <= 5 ) : NEW_LINE INDENT return 6 NEW_LINE DEDENT if ( v [ x ] ) : NEW_LINE INDENT return dp [ x ] NEW_LINE DEDENT v [ x ] = 1 NEW_LINE dp [ x ] = 1 + ( expectedSteps ( x - 1 ) + expectedSteps ( x - 2 ) + expectedSteps ( x - 3 ) + expectedSteps ( x - 4 ) + expectedSteps ( x - 5 ) + expectedSteps ( x - 6 ) ) / 6 NEW_LINE return dp [ x ] NEW_LINE DEDENT
def bitwiseAndOdd ( n ) : NEW_LINE INDENT result = 1 ; NEW_LINE for i in range ( 3 , n + 1 , 2 ) : NEW_LINE INDENT result = ( result & i ) ; NEW_LINE DEDENT return result ; NEW_LINE DEDENT
def printMinimumProduct ( arr , n ) : NEW_LINE INDENT first_min = min ( arr [ 0 ] , arr [ 1 ] ) NEW_LINE second_min = max ( arr [ 0 ] , arr [ 1 ] ) NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if ( arr [ i ] < first_min ) : NEW_LINE INDENT second_min = first_min NEW_LINE first_min = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] < second_min ) : NEW_LINE INDENT second_min = arr [ i ] NEW_LINE DEDENT DEDENT return first_min * second_min NEW_LINE DEDENT
def remainderWith7 ( num ) : NEW_LINE INDENT series = [ 1 , 3 , 2 , - 1 , - 3 , - 2 ] ; NEW_LINE series_index = 0 ; NEW_LINE result = 0 ; NEW_LINE for i in range ( ( len ( num ) - 1 ) , - 1 , - 1 ) : NEW_LINE INDENT digit = ord ( num [ i ] ) - 48 ; NEW_LINE result += digit * series [ series_index ] ; NEW_LINE series_index = ( series_index + 1 ) % 6 ; NEW_LINE result %= 7 ; NEW_LINE DEDENT if ( result < 0 ) : NEW_LINE INDENT result = ( result + 7 ) % 7 ; NEW_LINE DEDENT return result ; NEW_LINE DEDENT
def isPower ( x , y ) : NEW_LINE INDENT if ( x == 1 ) : NEW_LINE INDENT return ( y == 1 ) NEW_LINE DEDENT pow = 1 NEW_LINE while ( pow < y ) : NEW_LINE INDENT pow = pow * x NEW_LINE DEDENT return ( pow == y ) NEW_LINE DEDENT
def prefix ( string ) : NEW_LINE INDENT k = 1 ; NEW_LINE n = len ( string ) ; NEW_LINE g = [ ] ; NEW_LINE flag = 0 ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( string [ i ] == string [ 0 ] ) : NEW_LINE INDENT g . append ( i ) ; NEW_LINE flag = 1 ; NEW_LINE DEDENT DEDENT if ( flag == 0 ) : NEW_LINE INDENT print ( string ) ; NEW_LINE DEDENT else : NEW_LINE INDENT length = len ( g ) ; NEW_LINE while ( k < g [ 0 ] ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE for j in range ( length ) : NEW_LINE INDENT if ( string [ g [ j ] + k ] == string [ k ] ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT DEDENT if ( cnt == len ) : NEW_LINE INDENT k += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT for i in range ( k + 1 ) : NEW_LINE INDENT print ( string [ i ] , end = " " ) ; NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT
def Remainder ( str , R ) : NEW_LINE INDENT l = len ( str ) NEW_LINE Rem = 0 NEW_LINE for i in range ( l ) : NEW_LINE INDENT Num = Rem * 10 + ( ord ( str [ i ] ) - ord ( '0' ) ) NEW_LINE Rem = Num % R NEW_LINE DEDENT return Rem NEW_LINE DEDENT
def countConsecutive ( n ) : NEW_LINE INDENT s = str ( n ) NEW_LINE count = 0 NEW_LINE for i in range ( len ( s ) - 1 ) : NEW_LINE INDENT if ( s [ i ] == s [ i + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def FindMinNumber ( arr , n , k ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE min_num = 10 ** 9 NEW_LINE found = False NEW_LINE Sum = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT Sum = Sum + arr [ i ] NEW_LINE if ( Sum == k ) : NEW_LINE INDENT min_num = min ( min_num , ( ( n - ( i + 1 ) ) + j ) ) NEW_LINE found = True NEW_LINE DEDENT elif ( Sum > k ) : NEW_LINE INDENT while ( Sum > k ) : NEW_LINE INDENT Sum = Sum - arr [ j ] NEW_LINE j += 1 NEW_LINE DEDENT if ( Sum == k ) : NEW_LINE INDENT min_num = min ( min_num , ( ( n - ( i + 1 ) ) + j ) ) NEW_LINE found = True NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT if ( found ) : NEW_LINE INDENT return min_num NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def printPairs ( arr , n ) : NEW_LINE INDENT v = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( abs ( arr [ i ] ) == abs ( arr [ j ] ) ) : NEW_LINE INDENT v . append ( abs ( arr [ i ] ) ) NEW_LINE DEDENT DEDENT DEDENT if ( len ( v ) == 0 ) : NEW_LINE INDENT return ; NEW_LINE DEDENT v . sort ( ) NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT print ( - v [ i ] , " " , v [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def cntPairs ( a , n ) : NEW_LINE INDENT odd = 0 ; even = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] % 2 == 1 ) : NEW_LINE INDENT odd += 1 ; NEW_LINE DEDENT elif ( ( a [ i ] / 2 ) % 2 == 1 ) : NEW_LINE INDENT even += 1 ; NEW_LINE DEDENT DEDENT ans = odd * even + ( odd * ( odd - 1 ) ) // 2 ; NEW_LINE return ans ; NEW_LINE DEDENT
def MDAS_Factorial ( N ) : NEW_LINE INDENT if N <= 2 : NEW_LINE INDENT return N NEW_LINE DEDENT if N <= 4 : NEW_LINE INDENT return N + 3 NEW_LINE DEDENT if ( N - 4 ) % 4 == 0 : NEW_LINE INDENT return N + 1 NEW_LINE DEDENT elif ( N - 4 ) % 4 <= 2 : NEW_LINE INDENT return N + 2 NEW_LINE DEDENT else : NEW_LINE INDENT return N - 1 NEW_LINE DEDENT DEDENT
def nthRoot ( A , N ) : NEW_LINE INDENT xPre = random . randint ( 1 , 101 ) % 10 NEW_LINE eps = 0.001 NEW_LINE delX = 2147483647 NEW_LINE xK = 0.0 NEW_LINE while ( delX > eps ) : NEW_LINE INDENT xK = ( ( N - 1.0 ) * xPre + A / pow ( xPre , N - 1 ) ) / N NEW_LINE delX = abs ( xK - xPre ) NEW_LINE xPre = xK ; NEW_LINE DEDENT return xK NEW_LINE DEDENT
def stringmatch ( txt , pat , n , m ) : NEW_LINE INDENT if ( m == 0 ) : NEW_LINE INDENT return ( n == 0 ) NEW_LINE DEDENT i = 0 NEW_LINE j = 0 NEW_LINE index_txt = - 1 NEW_LINE index_pat = - 1 NEW_LINE while ( i < n - 2 ) : NEW_LINE INDENT if ( j < m and txt [ i ] == pat [ j ] ) : NEW_LINE INDENT i += 1 NEW_LINE j += 1 NEW_LINE DEDENT elif ( j < m and pat [ j ] == ' ? ' ) : NEW_LINE INDENT i += 1 NEW_LINE j += 1 NEW_LINE DEDENT elif ( j < m and pat [ j ] == ' * ' ) : NEW_LINE INDENT index_txt = i NEW_LINE index_pat = j NEW_LINE j += 1 NEW_LINE DEDENT elif ( index_pat != - 1 ) : NEW_LINE INDENT j = index_pat + 1 NEW_LINE i = index_txt + 1 NEW_LINE index_txt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT while ( j < m and pat [ j ] == ' * ' ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT if ( j == m ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def sum ( a , b ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , min ( a , b ) ) : NEW_LINE INDENT if ( a % i == 0 and b % i == 0 ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def minCells ( mat , m , n ) : NEW_LINE INDENT dp = [ [ MAX for i in range ( n ) ] for i in range ( m ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( dp [ i ] [ j ] != MAX and ( j + mat [ i ] [ j ] ) < n and ( dp [ i ] [ j ] + 1 ) < dp [ i ] [ j + mat [ i ] [ j ] ] ) : NEW_LINE INDENT dp [ i ] [ j + mat [ i ] [ j ] ] = dp [ i ] [ j ] + 1 NEW_LINE DEDENT if ( dp [ i ] [ j ] != MAX and ( i + mat [ i ] [ j ] ) < m and ( dp [ i ] [ j ] + 1 ) < dp [ i + mat [ i ] [ j ] ] [ j ] ) : NEW_LINE INDENT dp [ i + mat [ i ] [ j ] ] [ j ] = dp [ i ] [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT if ( dp [ m - 1 ] [ n - 1 ] != MAX ) : NEW_LINE INDENT return dp [ m - 1 ] [ n - 1 ] NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def getNumStrictMonotone ( ln ) : NEW_LINE INDENT DP = [ [ 0 ] * DP_s for _ in range ( ln ) ] NEW_LINE for i in range ( DP_s ) : NEW_LINE INDENT DP [ 0 ] [ i ] = i + 1 NEW_LINE DEDENT for i in range ( 1 , ln ) : NEW_LINE INDENT for j in range ( 1 , DP_s ) : NEW_LINE INDENT DP [ i ] [ j ] = DP [ i - 1 ] [ j - 1 ] + DP [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT return DP [ ln - 1 ] [ DP_s - 1 ] NEW_LINE DEDENT
def totalNumber ( n ) : NEW_LINE INDENT return 8 * pow ( 9 , n - 1 ) ; NEW_LINE DEDENT
def OctToBin ( octnum ) : NEW_LINE INDENT binary = " " NEW_LINE while octnum != 0 : NEW_LINE INDENT d = int ( octnum % 10 ) NEW_LINE if d == 0 : NEW_LINE INDENT binary = " " . join ( [ "000" , binary ] ) NEW_LINE DEDENT elif d == 1 : NEW_LINE INDENT binary = " " . join ( [ "001" , binary ] ) NEW_LINE DEDENT elif d == 2 : NEW_LINE INDENT binary = " " . join ( [ "010" , binary ] ) NEW_LINE DEDENT elif d == 3 : NEW_LINE INDENT binary = " " . join ( [ "011" , binary ] ) NEW_LINE DEDENT elif d == 4 : NEW_LINE INDENT binary = " " . join ( [ "100" , binary ] ) NEW_LINE DEDENT elif d == 5 : NEW_LINE INDENT binary = " " . join ( [ "101" , binary ] ) NEW_LINE DEDENT elif d == 6 : NEW_LINE INDENT binary = " " . join ( [ "110" , binary ] ) NEW_LINE DEDENT elif d == 7 : NEW_LINE INDENT binary = " " . join ( [ "111" , binary ] ) NEW_LINE DEDENT else : NEW_LINE INDENT binary = " Invalid ▁ Octal ▁ Digit " NEW_LINE break NEW_LINE DEDENT octnum = int ( octnum / 10 ) NEW_LINE DEDENT return binary NEW_LINE DEDENT
def largestSubSeq ( arr , n ) : NEW_LINE INDENT count = [ 0 ] * MAX NEW_LINE for i in range ( n ) : NEW_LINE INDENT string = arr [ i ] NEW_LINE _hash = [ False ] * MAX NEW_LINE for j in range ( len ( string ) ) : NEW_LINE INDENT _hash [ ord ( string [ j ] ) - ord ( ' a ' ) ] = True NEW_LINE DEDENT for j in range ( MAX ) : NEW_LINE INDENT if _hash [ j ] == True : NEW_LINE INDENT count [ j ] += 1 NEW_LINE DEDENT DEDENT DEDENT return max ( count ) NEW_LINE DEDENT
def towerOfHanoi ( n , from_rod , to_rod , aux_rod1 , aux_rod2 ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT print ( " Move ▁ disk " , n , " from ▁ rod " , from_rod , " c ▁ to ▁ rod " , to_rod ) NEW_LINE return NEW_LINE DEDENT towerOfHanoi ( n - 2 , from_rod , aux_rod1 , aux_rod2 , to_rod ) NEW_LINE print ( " Move ▁ disk " , n - 1 , " from ▁ rod " , from_rod , " c ▁ to ▁ rod " , aux_rod2 ) NEW_LINE print ( " Move ▁ disk " , n , " from ▁ rod " , from_rod , " c ▁ to ▁ rod " , to_rod ) NEW_LINE print ( " Move ▁ disk " , n - 1 , " from ▁ rod " , aux_rod2 , " c ▁ to ▁ rod " , to_rod ) NEW_LINE towerOfHanoi ( n - 2 , aux_rod1 , to_rod , from_rod , aux_rod2 ) NEW_LINE DEDENT
def discountPercentage ( S , M ) : NEW_LINE INDENT discount = M - S NEW_LINE disPercent = ( discount / M ) * 100 NEW_LINE return disPercent NEW_LINE DEDENT
def countTriplets ( arr , n , m ) : NEW_LINE INDENT count = 0 NEW_LINE arr . sort ( ) NEW_LINE for end in range ( n - 1 , 1 , - 1 ) : NEW_LINE INDENT start = 0 NEW_LINE mid = end - 1 NEW_LINE while ( start < mid ) : NEW_LINE INDENT prod = ( arr [ end ] * arr [ start ] * arr [ mid ] ) NEW_LINE if ( prod > m ) : NEW_LINE INDENT mid -= 1 NEW_LINE DEDENT elif ( prod < m ) : NEW_LINE INDENT start += 1 NEW_LINE DEDENT elif ( prod == m ) : NEW_LINE INDENT count += 1 NEW_LINE mid -= 1 NEW_LINE start += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def countSol ( coeff , start , end , rhs ) : NEW_LINE INDENT if ( rhs == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT result = 0 NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT if ( coeff [ i ] <= rhs ) : NEW_LINE INDENT result += countSol ( coeff , i , end , rhs - coeff [ i ] ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def sumEqualProduct ( a , n ) : NEW_LINE INDENT zero = 0 NEW_LINE two = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == 0 : NEW_LINE INDENT zero += 1 NEW_LINE DEDENT if a [ i ] == 2 : NEW_LINE INDENT two += 1 NEW_LINE DEDENT DEDENT cnt = ( zero * ( zero - 1 ) ) // 2 +   \ NEW_LINE INDENT ( two * ( two - 1 ) ) // 2 NEW_LINE DEDENT return cnt NEW_LINE DEDENT
def ReplaceElementsByFrequency ( arr , n ) : NEW_LINE INDENT mp = { i : 0 for i in range ( len ( arr ) ) } NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = mp [ arr [ i ] ] NEW_LINE DEDENT DEDENT
def findSubsequence ( arr , n ) : NEW_LINE INDENT length = 1 ; NEW_LINE dp = [ 0 ] * 10 ; NEW_LINE tmp = arr [ 0 ] ; NEW_LINE while ( tmp > 0 ) : NEW_LINE INDENT dp [ tmp % 10 ] = 1 ; NEW_LINE tmp //= 10 ; NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT tmp = arr [ i ] ; NEW_LINE locMax = 1 ; NEW_LINE cnt = [ 0 ] * 10 NEW_LINE while ( tmp > 0 ) : NEW_LINE INDENT cnt [ tmp % 10 ] = 1 ; NEW_LINE tmp //= 10 ; NEW_LINE DEDENT for d in range ( 10 ) : NEW_LINE INDENT if ( cnt [ d ] ) : NEW_LINE INDENT dp [ d ] += 1 ; NEW_LINE locMax = max ( locMax , dp [ d ] ) ; NEW_LINE DEDENT DEDENT for d in range ( 10 ) : NEW_LINE INDENT if ( cnt [ d ] ) : NEW_LINE INDENT dp [ d ] = locMax ; NEW_LINE DEDENT DEDENT length = max ( length , locMax ) ; NEW_LINE DEDENT return length ; NEW_LINE DEDENT
def CountingEvenOdd ( arr , arr_size ) : NEW_LINE INDENT even_count = 0 NEW_LINE odd_count = 0 NEW_LINE for i in range ( arr_size ) : NEW_LINE INDENT if ( arr [ i ] & 1 == 1 ) : NEW_LINE INDENT odd_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even_count += 1 NEW_LINE DEDENT DEDENT print ( " Number ▁ of ▁ even ▁ elements ▁ = ▁ " , even_count ) NEW_LINE print ( " Number ▁ of ▁ odd ▁ elements ▁ = ▁ " , odd_count ) NEW_LINE DEDENT
def check ( s ) : NEW_LINE INDENT for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == s [ i + 1 ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def isDivisible ( n ) : NEW_LINE INDENT while n // 100 : NEW_LINE INDENT d = n % 10 NEW_LINE n //= 10 NEW_LINE n += d * 7 NEW_LINE DEDENT return ( n % 23 == 0 ) NEW_LINE DEDENT
def kthString ( n , k ) : NEW_LINE INDENT total = 0 NEW_LINE i = 1 NEW_LINE while ( total < k ) : NEW_LINE INDENT total = total + n - i NEW_LINE i += 1 NEW_LINE DEDENT first_y_position = i - 1 NEW_LINE second_y_position = k - ( total - n + first_y_position ) NEW_LINE for j in range ( 1 , first_y_position , 1 ) : NEW_LINE INDENT print ( " x " , end = " " ) NEW_LINE DEDENT print ( " y " , end = " " ) NEW_LINE j = first_y_position + 1 NEW_LINE while ( second_y_position > 1 ) : NEW_LINE INDENT print ( " x " , end = " " ) NEW_LINE second_y_position -= 1 NEW_LINE j += 1 NEW_LINE DEDENT print ( " y " , end = " " ) NEW_LINE while ( j < n ) : NEW_LINE INDENT print ( " x " ) NEW_LINE j += 1 NEW_LINE DEDENT DEDENT
def printUncommon ( arr1 , arr2 , n1 , n2 ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE k = 0 NEW_LINE while ( i < n1 and j < n2 ) : NEW_LINE INDENT if ( arr1 [ i ] < arr2 [ j ] ) : NEW_LINE INDENT print ( arr1 [ i ] , end = " ▁ " ) NEW_LINE i = i + 1 NEW_LINE k = k + 1 NEW_LINE DEDENT elif ( arr2 [ j ] < arr1 [ i ] ) : NEW_LINE INDENT print ( arr2 [ j ] , end = " ▁ " ) NEW_LINE k = k + 1 NEW_LINE j = j + 1 NEW_LINE DEDENT else : NEW_LINE INDENT i = i + 1 NEW_LINE j = j + 1 NEW_LINE DEDENT DEDENT while ( i < n1 ) : NEW_LINE INDENT print ( arr1 [ i ] , end = " ▁ " ) NEW_LINE i = i + 1 NEW_LINE k = k + 1 NEW_LINE DEDENT while ( j < n2 ) : NEW_LINE INDENT print ( arr2 [ j ] , end = " ▁ " ) NEW_LINE j = j + 1 NEW_LINE k = k + 1 NEW_LINE DEDENT DEDENT
def findValueAtX ( n ) : NEW_LINE INDENT return ( n * n * n ) + n NEW_LINE DEDENT
def log_a_to_base_b ( a , b ) : NEW_LINE INDENT rslt = ( 1 + log_a_to_base_b ( a // b , b ) ) if ( a > ( b - 1 ) ) else 0 ; NEW_LINE return rslt ; NEW_LINE DEDENT
def onlyFirstAndLastAreSet ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return ( ( ( n - 1 ) & ( n - 2 ) ) == 0 ) NEW_LINE DEDENT
def lenghtOfLongestAP ( set , n ) : NEW_LINE INDENT if ( n <= 2 ) : NEW_LINE INDENT return n NEW_LINE DEDENT L = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] NEW_LINE llap = 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT L [ i ] [ n - 1 ] = 2 NEW_LINE DEDENT for j in range ( n - 2 , 0 , - 1 ) : NEW_LINE INDENT i = j - 1 NEW_LINE k = j + 1 NEW_LINE while ( i >= 0 and k <= n - 1 ) : NEW_LINE INDENT if ( set [ i ] + set [ k ] < 2 * set [ j ] ) : NEW_LINE INDENT k += 1 NEW_LINE DEDENT elif ( set [ i ] + set [ k ] > 2 * set [ j ] ) : NEW_LINE INDENT L [ i ] [ j ] = 2 NEW_LINE i -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = L [ j ] [ k ] + 1 NEW_LINE llap = max ( llap , L [ i ] [ j ] ) NEW_LINE i -= 1 NEW_LINE k += 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT L [ i ] [ j ] = 2 NEW_LINE i -= 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return llap NEW_LINE DEDENT
def maxAND ( L , R ) : NEW_LINE INDENT if ( L == R ) : NEW_LINE INDENT return L ; NEW_LINE DEDENT elif ( ( R - L ) == 1 ) : NEW_LINE INDENT return ( R & L ) ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( ( ( R - 1 ) & R ) > ( ( R - 2 ) & ( R - 1 ) ) ) : NEW_LINE INDENT return ( ( R - 1 ) & R ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( R - 2 ) & ( R - 1 ) ) ; NEW_LINE DEDENT DEDENT DEDENT
def maxSum ( mat , n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return mat [ 0 ] [ 0 ] NEW_LINE DEDENT dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE maxSum = INT_MIN NEW_LINE for j in range ( n ) : NEW_LINE INDENT dp [ n - 1 ] [ j ] = mat [ n - 1 ] [ j ] NEW_LINE DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT maxi = INT_MIN NEW_LINE if ( ( ( ( j - 1 ) >= 0 ) and ( maxi < dp [ i + 1 ] [ j - 1 ] ) ) ) : NEW_LINE INDENT maxi = dp [ i + 1 ] [ j - 1 ] NEW_LINE DEDENT if ( ( ( ( j + 1 ) < n ) and ( maxi < dp [ i + 1 ] [ j + 1 ] ) ) ) : NEW_LINE INDENT maxi = dp [ i + 1 ] [ j + 1 ] NEW_LINE DEDENT dp [ i ] [ j ] = mat [ i ] [ j ] + maxi NEW_LINE DEDENT DEDENT for j in range ( n ) : NEW_LINE INDENT if ( maxSum < dp [ 0 ] [ j ] ) : NEW_LINE INDENT maxSum = dp [ 0 ] [ j ] NEW_LINE DEDENT DEDENT return maxSum NEW_LINE DEDENT
def surface_area_octahedron ( side ) : NEW_LINE INDENT return ( 2 * ( math . sqrt ( 3 ) ) * ( side * side ) ) NEW_LINE DEDENT
def getHermiteNumber ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return ( - 2 * ( n - 1 ) * getHermiteNumber ( n - 2 ) ) NEW_LINE DEDENT DEDENT
def cubeSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += ( 2 * i ) * ( 2 * i ) * ( 2 * i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def findSum ( str1 , str2 ) : NEW_LINE INDENT if len ( str1 ) > len ( str2 ) : NEW_LINE INDENT temp = str1 NEW_LINE str1 = str2 NEW_LINE str2 = temp NEW_LINE DEDENT str3 = " " NEW_LINE n1 = len ( str1 ) NEW_LINE n2 = len ( str2 ) NEW_LINE diff = n2 - n1 NEW_LINE carry = 0 NEW_LINE for i in range ( n1 - 1 , - 1 , - 1 ) : NEW_LINE INDENT sum = ( ( ord ( str1 [ i ] ) - ord ( '0' ) ) + int ( ( ord ( str2 [ i + diff ] ) - ord ( '0' ) ) ) + carry ) NEW_LINE str3 = str3 + str ( sum % 10 ) NEW_LINE carry = sum // 10 NEW_LINE DEDENT for i in range ( n2 - n1 - 1 , - 1 , - 1 ) : NEW_LINE INDENT sum = ( ( ord ( str2 [ i ] ) - ord ( '0' ) ) + carry ) NEW_LINE str3 = str3 + str ( sum % 10 ) NEW_LINE carry = sum // 10 NEW_LINE DEDENT if ( carry ) : NEW_LINE INDENT str3 + str ( carry + '0' ) NEW_LINE DEDENT str3 = str3 [ : : - 1 ] NEW_LINE return str3 NEW_LINE DEDENT
def print_sequence ( n , k ) : NEW_LINE INDENT b = int ( n / ( k * ( k + 1 ) / 2 ) ) ; NEW_LINE if b == 0 : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT else : NEW_LINE INDENT r = 1 ; NEW_LINE x = 1 NEW_LINE while x ** 2 <= n : NEW_LINE INDENT if n % x != 0 : NEW_LINE INDENT continue ; NEW_LINE DEDENT elif x <= b and x > r : NEW_LINE INDENT r = x NEW_LINE DEDENT elif n / x <= b and n / x > r : NEW_LINE INDENT r = n / x NEW_LINE DEDENT x = x + 1 NEW_LINE DEDENT i = 1 NEW_LINE while i < k : NEW_LINE INDENT print ( r * i , end = " ▁ " ) NEW_LINE i = i + 1 NEW_LINE DEDENT last_term = n - ( r * ( k * ( k - 1 ) / 2 ) ) NEW_LINE print ( last_term ) NEW_LINE DEDENT DEDENT
def isEven ( n ) : NEW_LINE INDENT return ( not ( n & 1 ) ) NEW_LINE DEDENT
def printIndex ( str , s ) : NEW_LINE INDENT flag = False ; NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i : i + len ( s ) ] == s ) : NEW_LINE INDENT print ( i , end = " ▁ " ) ; NEW_LINE flag = True ; NEW_LINE DEDENT DEDENT if ( flag == False ) : NEW_LINE INDENT print ( " NONE " ) ; NEW_LINE DEDENT DEDENT
def checkType ( arr , n ) : NEW_LINE INDENT if ( arr [ 0 ] <= arr [ 1 ] and arr [ n - 2 ] <= arr [ n - 1 ] ) : NEW_LINE INDENT print ( " Increasing " ) ; NEW_LINE DEDENT elif ( arr [ 0 ] >= arr [ 1 ] and arr [ n - 2 ] >= arr [ n - 1 ] ) : NEW_LINE INDENT print ( " Decreasing " ) ; NEW_LINE DEDENT elif ( arr [ 0 ] <= arr [ 1 ] and arr [ n - 2 ] >= arr [ n - 1 ] ) : NEW_LINE INDENT print ( " Increasing ▁ then ▁ decreasing " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Decreasing ▁ then ▁ increasing " ) ; NEW_LINE DEDENT DEDENT
def countDivisibleSubseq ( str , n ) : NEW_LINE INDENT l = len ( str ) NEW_LINE dp = [ [ 0 for x in range ( l ) ] for y in range ( n ) ] NEW_LINE dp [ 0 ] [ ( ord ( str [ 0 ] ) - ord ( '0' ) ) % n ] += 1 NEW_LINE for i in range ( 1 , l ) : NEW_LINE INDENT dp [ i ] [ ( ord ( str [ i ] ) - ord ( '0' ) ) % n ] += 1 NEW_LINE for j in range ( n ) : NEW_LINE INDENT dp [ i ] [ j ] += dp [ i - 1 ] [ j ] NEW_LINE dp [ i ] [ ( j * 10 + ( ord ( str [ i ] ) - ord ( '0' ) ) ) % n ] += dp [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT return dp [ l - 1 ] [ 0 ] NEW_LINE DEDENT
def convert12 ( str ) : NEW_LINE INDENT h1 = ord ( str [ 0 ] ) - ord ( '0' ) ; NEW_LINE h2 = ord ( str [ 1 ] ) - ord ( '0' ) ; NEW_LINE hh = h1 * 10 + h2 ; NEW_LINE Meridien = " " ; NEW_LINE if ( hh < 12 ) : NEW_LINE INDENT Meridien = " AM " ; NEW_LINE DEDENT else : NEW_LINE INDENT Meridien = " PM " ; NEW_LINE DEDENT hh %= 12 ; NEW_LINE if ( hh == 0 ) : NEW_LINE INDENT print ( "12" , end = " " ) ; NEW_LINE for i in range ( 2 , 8 ) : NEW_LINE INDENT print ( str [ i ] , end = " " ) ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( hh , end = " " ) ; NEW_LINE for i in range ( 2 , 8 ) : NEW_LINE INDENT print ( str [ i ] , end = " " ) ; NEW_LINE DEDENT DEDENT print ( " ▁ " + Meridien ) ; NEW_LINE DEDENT
def seriesSum ( n ) : NEW_LINE INDENT return int ( ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ) NEW_LINE DEDENT
def removeDuplicate ( str , n ) : NEW_LINE INDENT index = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , i + 1 ) : NEW_LINE INDENT if ( str [ i ] == str [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( j == i ) : NEW_LINE INDENT str [ index ] = str [ i ] NEW_LINE index += 1 NEW_LINE DEDENT DEDENT return " " . join ( str [ : index ] ) NEW_LINE DEDENT
def solve ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE a = 0 ; b = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i % 2 != 0 ) : NEW_LINE INDENT a = a * 10 + arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT b = b * 10 + arr [ i ] NEW_LINE DEDENT DEDENT return a + b NEW_LINE DEDENT
def dfs ( u , p ) : NEW_LINE INDENT global ans NEW_LINE for i in range ( 0 , len ( g [ u ] ) ) : NEW_LINE INDENT v = g [ u ] [ i ] NEW_LINE if v != p : NEW_LINE INDENT dfs ( v , u ) NEW_LINE for i in range ( 0 , 22 ) : NEW_LINE INDENT a [ u ] [ i ] += a [ v ] [ i ] NEW_LINE DEDENT DEDENT DEDENT pp = 0 NEW_LINE for i in range ( 0 , 22 ) : NEW_LINE INDENT if ( not ( ( a [ u ] [ i ] > 0 and x [ i ] - a [ u ] [ i ] > 0 ) or ( a [ u ] [ i ] == 0 and x [ i ] == 0 ) ) ) : NEW_LINE INDENT pp = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if pp == 0 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT
def minSteps ( i , j , arr ) : NEW_LINE INDENT if ( i == n - 1 and j == n - 1 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( i > n - 1 or j > n - 1 ) : NEW_LINE INDENT return 9999999 ; NEW_LINE DEDENT if ( v [ i ] [ j ] ) : NEW_LINE INDENT return dp [ i ] [ j ] ; NEW_LINE DEDENT v [ i ] [ j ] = 1 ; NEW_LINE dp [ i ] [ j ] = 1 + min ( minSteps ( i + arr [ i ] [ j ] , j , arr ) , minSteps ( i , j + arr [ i ] [ j ] , arr ) ) ; NEW_LINE return dp [ i ] [ j ] ; NEW_LINE DEDENT
def maxDiff ( arr , n ) : NEW_LINE INDENT SubsetSum_1 = 0 NEW_LINE SubsetSum_2 = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT isSingleOccurance = True NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] == arr [ j ] ) : NEW_LINE INDENT isSingleOccurance = False NEW_LINE arr [ i ] = arr [ j ] = 0 NEW_LINE break NEW_LINE DEDENT DEDENT if ( isSingleOccurance == True ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT SubsetSum_1 += arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT SubsetSum_2 += arr [ i ] NEW_LINE DEDENT DEDENT DEDENT return abs ( SubsetSum_1 - SubsetSum_2 ) NEW_LINE DEDENT
def minChanges ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE if ( n > MAX_CHAR [ 0 ] ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT dist_count = 0 NEW_LINE count = [ 0 ] * MAX_CHAR [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( count [ ord ( str [ i ] ) - ord ( ' a ' ) ] == 0 ) : NEW_LINE INDENT dist_count += 1 NEW_LINE DEDENT count [ ( ord ( str [ i ] ) - ord ( ' a ' ) ) ] += 1 NEW_LINE DEDENT return ( n - dist_count ) NEW_LINE DEDENT
def printSquares ( n ) : NEW_LINE INDENT square = 0 ; prev_x = 0 ; NEW_LINE for x in range ( 0 , n ) : NEW_LINE INDENT square = ( square + x + prev_x ) NEW_LINE print ( square , end = " ▁ " ) NEW_LINE prev_x = x NEW_LINE DEDENT DEDENT
def findSum ( arr , N ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in arr : NEW_LINE INDENT if i in mp . keys ( ) : NEW_LINE INDENT mp [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ i ] = 1 NEW_LINE DEDENT DEDENT minFreq = 10 ** 9 NEW_LINE for itr in mp : NEW_LINE INDENT if mp [ itr ] < minFreq : NEW_LINE INDENT minFreq = mp [ itr ] NEW_LINE DEDENT DEDENT Sum = 0 NEW_LINE for itr in mp : NEW_LINE INDENT if mp [ itr ] == minFreq : NEW_LINE INDENT Sum += itr * mp [ itr ] NEW_LINE DEDENT DEDENT return Sum NEW_LINE DEDENT
def countCubes ( a , b ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( a , b + 1 ) : NEW_LINE INDENT for j in range ( i + 1 ) : NEW_LINE INDENT if j * j * j > i : NEW_LINE INDENT break NEW_LINE DEDENT if j * j * j == i : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT
def printSortedLevels ( arr , n ) : NEW_LINE INDENT level = 0 NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT cnt = int ( pow ( 2 , level ) ) NEW_LINE cnt -= 1 NEW_LINE j = min ( i + cnt , n - 1 ) NEW_LINE arr = arr [ : i ] + sorted ( arr [ i : j + 1 ] ) +   \ NEW_LINE INDENT arr [ j + 1 : ] NEW_LINE DEDENT while ( i <= j ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE i += 1 NEW_LINE DEDENT print ( ) NEW_LINE level += 1 NEW_LINE DEDENT DEDENT
def lastNonRepeating ( string , n ) : NEW_LINE INDENT freq = [ 0 ] * MAX ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( string [ i ] ) ] += 1 ; NEW_LINE DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT ch = string [ i ] ; NEW_LINE if ( freq [ ord ( ch ) ] == 1 ) : NEW_LINE INDENT return ( " " + ch ) ; NEW_LINE DEDENT DEDENT return " - 1" ; NEW_LINE DEDENT
def areVowelsInOrder ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE c = chr ( 64 ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] == ' a ' or s [ i ] == ' e ' or s [ i ] == ' i ' or s [ i ] == ' o ' or s [ i ] == ' u ' ) : NEW_LINE INDENT if s [ i ] < c : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT c = s [ i ] NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
def sumDivisorsOfDivisors ( n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for j in range ( 2 , mt . ceil ( mt . sqrt ( n ) ) ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n % j == 0 ) : NEW_LINE INDENT n //= j NEW_LINE count += 1 NEW_LINE DEDENT if ( count ) : NEW_LINE INDENT mp [ j ] = count NEW_LINE DEDENT DEDENT if ( n != 1 ) : NEW_LINE INDENT mp [ n ] = 1 NEW_LINE DEDENT ans = 1 NEW_LINE for it in mp : NEW_LINE INDENT pw = 1 NEW_LINE summ = 0 NEW_LINE for i in range ( mp [ it ] + 1 , 0 , - 1 ) : NEW_LINE INDENT summ += ( i * pw ) NEW_LINE pw *= it NEW_LINE DEDENT ans *= summ NEW_LINE DEDENT return ans NEW_LINE DEDENT
def waysToArrange ( N , K , k ) : NEW_LINE INDENT C = np . zeros ( ( N + 1 , N + 1 ) ) NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT for j in range ( i + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT dp = np . zeros ( ( K + 1 ) ) NEW_LINE count = 0 NEW_LINE dp [ 0 ] = 1 NEW_LINE for i in range ( K ) : NEW_LINE INDENT dp [ i + 1 ] = ( dp [ i ] * C [ count + k [ i ] - 1 ] [ k [ i ] - 1 ] ) NEW_LINE count += k [ i ] NEW_LINE DEDENT return dp [ K ] NEW_LINE DEDENT
def minSum ( arr , n ) : NEW_LINE INDENT sum = arr [ 0 ] ; prev = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if arr [ i ] <= prev : NEW_LINE INDENT prev = prev + 1 NEW_LINE sum = sum + prev NEW_LINE DEDENT else : NEW_LINE INDENT sum = sum + arr [ i ] NEW_LINE prev = arr [ i ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def printTwoOdd ( arr , size ) : NEW_LINE INDENT xor2 = arr [ 0 ] NEW_LINE set_bit_no = 0 NEW_LINE n = size - 2 NEW_LINE x , y = 0 , 0 NEW_LINE for i in range ( 1 , size ) : NEW_LINE INDENT xor2 = xor2 ^ arr [ i ] NEW_LINE DEDENT set_bit_no = xor2 & ~ ( xor2 - 1 ) NEW_LINE for i in range ( size ) : NEW_LINE INDENT if ( arr [ i ] & set_bit_no ) : NEW_LINE INDENT x = x ^ arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT y = y ^ arr [ i ] NEW_LINE DEDENT DEDENT print ( " The ▁ two ▁ ODD ▁ elements ▁ are " , x , " & " , y ) NEW_LINE DEDENT
def areAllBitsSet ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return " No " NEW_LINE DEDENT if ( ( ( n + 1 ) & n ) == 0 ) : NEW_LINE INDENT return " Yes " NEW_LINE DEDENT return " No " NEW_LINE DEDENT
def isPossible ( a , n ) : NEW_LINE INDENT k = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] != i + 1 ) : NEW_LINE INDENT k += 1 ; NEW_LINE DEDENT DEDENT if ( k <= 2 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT
def isPlusPossible ( arr , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] = mp . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT foundModOne = False NEW_LINE for x in mp : NEW_LINE INDENT element = x NEW_LINE frequency = mp [ x ] NEW_LINE if ( frequency % 4 == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( frequency % 4 == 1 ) : NEW_LINE INDENT if ( foundModOne == True ) : NEW_LINE INDENT return False NEW_LINE DEDENT foundModOne = True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def printVertically ( s ) : NEW_LINE INDENT s = s . split ( " ▁ " ) NEW_LINE result = " " NEW_LINE map = dict ( ) NEW_LINE mx = 0 NEW_LINE for i in s : NEW_LINE INDENT mx = max ( mx , len ( i ) ) NEW_LINE DEDENT n = mx NEW_LINE i = 0 NEW_LINE while ( i < mx ) : NEW_LINE INDENT for j in s : NEW_LINE INDENT if i >= len ( j ) : NEW_LINE INDENT map [ i ] = map . get ( i , " " ) + " $ " NEW_LINE DEDENT else : NEW_LINE INDENT map [ i ] = map . get ( i , " " ) + j [ i ] NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT for j in range ( mx ) : NEW_LINE INDENT result += map [ j ] + " ▁ " NEW_LINE DEDENT return result NEW_LINE DEDENT
def calculate_ ( s ) : NEW_LINE INDENT if len ( s ) == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT count_ = 0 NEW_LINE i = len ( s ) - 1 NEW_LINE while i > 0 : NEW_LINE INDENT if s [ i ] == '0' : NEW_LINE INDENT count_ += 1 NEW_LINE i -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_ += 1 NEW_LINE while s [ i ] == '1' and i > 0 : NEW_LINE INDENT count_ += 1 NEW_LINE i -= 1 NEW_LINE DEDENT if i == 0 : NEW_LINE INDENT count_ += 1 NEW_LINE DEDENT s = s [ : i ] + "1" + s [ i + 1 : ] NEW_LINE DEDENT DEDENT return count_ NEW_LINE DEDENT
def evenPowerSum ( n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT j = 2 * i ; NEW_LINE sum = sum + ( j * j * j * j ) ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT
def maxLengthSquare ( row , column , arr , k ) : NEW_LINE INDENT sum = np . zeros ( ( row + 1 , column + 1 ) ) ; NEW_LINE cur_max = 1 ; NEW_LINE max = 0 ; NEW_LINE for i in range ( 1 , row + 1 ) : NEW_LINE INDENT for j in range ( 1 , column + 1 ) : NEW_LINE INDENT sum [ i ] [ j ] = sum [ i - 1 ] [ j ] + sum [ i ] [ j - 1 ] +   \ NEW_LINE INDENT arr [ i - 1 ] [ j - 1 ] -   \ NEW_LINE sum [ i - 1 ] [ j - 1 ] ; NEW_LINE DEDENT if ( i >= cur_max and j >= cur_max and sum [ i ] [ j ] - sum [ i - cur_max ] [ j ] - sum [ i ] [ j - cur_max ] + sum [ i - cur_max ] [ j - cur_max ] <= k ) : NEW_LINE INDENT max = cur_max ; NEW_LINE cur_max += 1 ; NEW_LINE DEDENT DEDENT DEDENT return max ; NEW_LINE DEDENT
def findExtra ( arr1 , arr2 , n ) : NEW_LINE INDENT index = n NEW_LINE left = 0 NEW_LINE right = n - 1 NEW_LINE while ( left <= right ) : NEW_LINE INDENT mid = ( int ) ( ( left + right ) / 2 ) NEW_LINE if ( arr2 [ mid ] == arr1 [ mid ] ) : NEW_LINE INDENT left = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT index = mid NEW_LINE right = mid - 1 NEW_LINE DEDENT DEDENT return index NEW_LINE DEDENT
def findSetBits ( n ) : NEW_LINE INDENT dp = [ 0 ] * ( n + 1 ) ; NEW_LINE print ( dp [ 0 ] , end = " ▁ " ) ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT dp [ i ] = dp [ i // 2 ] ; NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = dp [ i // 2 ] + 1 ; NEW_LINE DEDENT print ( dp [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT
def countIdenticalRows ( mat ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( mat ) ) : NEW_LINE INDENT hs = dict ( ) NEW_LINE for j in range ( len ( mat [ i ] ) ) : NEW_LINE INDENT hs [ mat [ i ] [ j ] ] = 1 NEW_LINE DEDENT if ( len ( hs ) == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def maxDiff ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE arr . sort ( ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( abs ( arr [ i ] ) != abs ( arr [ i + 1 ] ) ) : NEW_LINE INDENT result += abs ( arr [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT if ( arr [ n - 2 ] != arr [ n - 1 ] ) : NEW_LINE INDENT result += abs ( arr [ n - 1 ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def removeOddFrequencyCharacters ( s ) : NEW_LINE INDENT m = dict ( ) NEW_LINE for i in s : NEW_LINE INDENT m [ i ] = m . get ( i , 0 ) + 1 NEW_LINE DEDENT new_s = " " NEW_LINE for i in s : NEW_LINE INDENT if ( m [ i ] & 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT new_s += i NEW_LINE DEDENT return new_s NEW_LINE DEDENT
def maxDiff ( arr , n ) : NEW_LINE INDENT maxDiff = - 1 NEW_LINE maxRight = arr [ n - 1 ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] > maxRight ) : NEW_LINE INDENT maxRight = arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT diff = maxRight - arr [ i ] NEW_LINE if ( diff > maxDiff ) : NEW_LINE INDENT maxDiff = diff NEW_LINE DEDENT DEDENT DEDENT return maxDiff NEW_LINE DEDENT
def findlargestAfterDel ( arr , m , dell , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if dell [ i ] in mp . keys ( ) : NEW_LINE INDENT mp [ dell [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ dell [ i ] ] = 1 NEW_LINE DEDENT DEDENT largestElement = - 10 ** 9 NEW_LINE for i in range ( m ) : NEW_LINE INDENT if ( arr [ i ] in mp . keys ( ) ) : NEW_LINE INDENT mp [ arr [ i ] ] -= 1 NEW_LINE if ( mp [ arr [ i ] ] == 0 ) : NEW_LINE INDENT mp . pop ( arr [ i ] ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT largestElement = max ( largestElement , arr [ i ] ) NEW_LINE DEDENT DEDENT return largestElement NEW_LINE DEDENT
def findMod4 ( s , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT k = ord ( s [ 0 ] ) - ord ( '0' ) NEW_LINE DEDENT else : NEW_LINE INDENT k = ( ( ord ( s [ n - 2 ] ) - ord ( '0' ) ) * 10 + ord ( s [ n - 1 ] ) - ord ( '0' ) ) NEW_LINE DEDENT return ( k % 4 ) NEW_LINE DEDENT
def lenoflongestnonpalindrome ( s ) : NEW_LINE INDENT max1 , length = 1 , 0 NEW_LINE for i in range ( 0 , len ( s ) - 1 ) : NEW_LINE INDENT if s [ i ] == s [ i + 1 ] : NEW_LINE INDENT length = 0 NEW_LINE DEDENT elif s [ i + 1 ] == s [ i - 1 ] and i > 0 : NEW_LINE INDENT length = 1 NEW_LINE DEDENT else : NEW_LINE INDENT length += 1 NEW_LINE DEDENT max1 = max ( max1 , length + 1 ) NEW_LINE DEDENT if max1 == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return max1 NEW_LINE DEDENT DEDENT
def isPentagonal ( N ) : NEW_LINE INDENT i = 1 NEW_LINE while True : NEW_LINE INDENT M = ( 3 * i * i - i ) / 2 NEW_LINE i += 1 NEW_LINE if ( M >= N ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return ( M == N ) NEW_LINE DEDENT
def getNthTerm ( N ) : NEW_LINE INDENT return 4 * pow ( N , 2 ) - 3 * N + 2 NEW_LINE DEDENT
def swapNibbles ( x ) : NEW_LINE INDENT return ( ( x & 0x0F ) << 4 | ( x & 0xF0 ) >> 4 ) NEW_LINE DEDENT
def minSteps ( i , j , arr ) : NEW_LINE INDENT if ( i == n - 1 and j == n - 1 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( i > n - 1 or j > n - 1 ) : NEW_LINE INDENT return 9999999 ; NEW_LINE DEDENT if ( v [ i ] [ j ] ) : NEW_LINE INDENT return dp [ i ] [ j ] ; NEW_LINE DEDENT v [ i ] [ j ] = 1 ; NEW_LINE dp [ i ] [ j ] = 9999999 ; NEW_LINE for k in range ( max ( 0 , arr [ i ] [ j ] + j - n + 1 ) , min ( n - i - 1 , arr [ i ] [ j ] ) + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i ] [ j ] , minSteps ( i + k , j + arr [ i ] [ j ] - k , arr ) ) ; NEW_LINE DEDENT dp [ i ] [ j ] += 1 ; NEW_LINE return dp [ i ] [ j ] ; NEW_LINE DEDENT
def modInverse ( a , m ) : NEW_LINE INDENT a = a % m ; NEW_LINE for x in range ( 1 , m ) : NEW_LINE INDENT if ( ( a * x ) % m == 1 ) : NEW_LINE INDENT return x NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT
def getnumbers ( n ) : NEW_LINE INDENT divisor = [ ] NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT while ( n % i == 0 ) : NEW_LINE INDENT divisor . append ( i ) NEW_LINE n //= i NEW_LINE DEDENT DEDENT if ( n != 1 ) : NEW_LINE INDENT divisor . append ( n ) NEW_LINE DEDENT a , b , c , size = 0 , 0 , 0 , 0 NEW_LINE a = b = c = 1 NEW_LINE size = len ( divisor ) NEW_LINE for i in range ( size ) : NEW_LINE INDENT if ( a == 1 ) : NEW_LINE INDENT a = a * divisor [ i ] NEW_LINE DEDENT elif ( b == 1 or b == a ) : NEW_LINE INDENT b = b * divisor [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT c = c * divisor [ i ] NEW_LINE DEDENT DEDENT if ( a == 1 or b == 1 or c == 1 or a == b or b == c or a == c ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( a , b , c ) NEW_LINE DEDENT DEDENT
def removeSpecialCharacter ( s ) : NEW_LINE INDENT t = " " NEW_LINE for i in s : NEW_LINE INDENT if ( i >= ' A ' and i <= ' Z ' ) or ( i >= ' a ' and i <= ' z ' ) : NEW_LINE INDENT t += i NEW_LINE DEDENT DEDENT print ( t ) NEW_LINE DEDENT
def calculateSum ( n ) : NEW_LINE INDENT r1 , r2 = 2 , 3 NEW_LINE a1 , a2 = 1 , 1 NEW_LINE return ( a1 * ( pow ( r1 , n ) - 1 ) // ( r1 - 1 ) + a2 * ( pow ( r2 , n ) - 1 ) // ( r2 - 1 ) ) NEW_LINE DEDENT
def fib ( n ) : NEW_LINE INDENT a = 0 NEW_LINE b = 1 NEW_LINE if ( n >= 0 ) : NEW_LINE INDENT print ( a , end = ' ▁ ' ) NEW_LINE DEDENT if ( n >= 1 ) : NEW_LINE INDENT print ( b , end = ' ▁ ' ) NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT print ( a + b , end = ' ▁ ' ) NEW_LINE b = a + b NEW_LINE a = b - a NEW_LINE DEDENT DEDENT
def checkAllOnes ( arr , n , k ) : NEW_LINE INDENT brr = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT h = k + 1 NEW_LINE j = i NEW_LINE while ( j >= 0 and ( h ) ) : NEW_LINE INDENT brr [ j ] = 1 NEW_LINE h -= 1 NEW_LINE j -= 1 NEW_LINE DEDENT h = k + 1 NEW_LINE j = i NEW_LINE while ( j < n and ( h ) ) : NEW_LINE INDENT brr [ j ] = 1 NEW_LINE j += 1 NEW_LINE h -= 1 NEW_LINE DEDENT DEDENT DEDENT flag = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( brr [ i ] == 0 ) : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag == 1 ) : NEW_LINE INDENT print ( "0" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "1" ) NEW_LINE DEDENT DEDENT
def makeOdd ( n ) : NEW_LINE INDENT if n % 2 != 0 : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if ( n % i == 0 and ( int ) ( n / i ) % 2 == 1 ) : NEW_LINE INDENT return i ; NEW_LINE DEDENT DEDENT DEDENT
def Right_most_setbit ( num ) : NEW_LINE INDENT pos = 1 NEW_LINE for i in range ( INT_SIZE ) : NEW_LINE INDENT if not ( num & ( 1 << i ) ) : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return pos NEW_LINE DEDENT
def MinStep ( a , n ) : NEW_LINE INDENT positive = 0 ; NEW_LINE negative = 0 ; NEW_LINE zero = 0 ; NEW_LINE step = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == 0 ) : NEW_LINE INDENT zero += 1 ; NEW_LINE DEDENT elif ( a [ i ] < 0 ) : NEW_LINE INDENT negative += 1 ; NEW_LINE step = step + ( - 1 - a [ i ] ) ; NEW_LINE DEDENT else : NEW_LINE INDENT positive += 1 ; NEW_LINE step = step + ( a [ i ] - 1 ) ; NEW_LINE DEDENT DEDENT if ( negative % 2 == 0 ) : NEW_LINE INDENT step = step + zero ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( zero > 0 ) : NEW_LINE INDENT step = step + zero ; NEW_LINE DEDENT else : NEW_LINE INDENT step = step + 2 ; NEW_LINE DEDENT DEDENT return step ; NEW_LINE DEDENT
def findCount ( m , n ) : NEW_LINE INDENT num1 = 0 NEW_LINE for i in range ( 0 , m ) : NEW_LINE INDENT num1 = ( num1 * 10 ) + 9 NEW_LINE DEDENT num2 = 0 NEW_LINE for i in range ( 0 , ( m - 1 ) ) : NEW_LINE INDENT num2 = ( num2 * 10 ) + 9 NEW_LINE DEDENT return int ( ( num1 / n ) - ( num2 / n ) ) NEW_LINE DEDENT
def sortArray ( a , n ) : NEW_LINE INDENT ans = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] >= 0 ) : NEW_LINE INDENT ans . append ( a [ i ] ) NEW_LINE DEDENT DEDENT ans = sorted ( ans ) NEW_LINE j = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] >= 0 ) : NEW_LINE INDENT a [ i ] = ans [ j ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def breakSum ( n ) : NEW_LINE INDENT dp = [ 0 ] * ( n + 1 ) NEW_LINE dp [ 0 ] = 0 NEW_LINE dp [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT dp [ i ] = max ( dp [ int ( i / 2 ) ] + dp [ int ( i / 3 ) ] + dp [ int ( i / 4 ) ] , i ) ; NEW_LINE DEDENT return dp [ n ] NEW_LINE DEDENT
def findNumbers ( n , w ) : NEW_LINE INDENT x = 0 ; NEW_LINE sum = 0 ; NEW_LINE if ( w >= 0 and w <= 8 ) : NEW_LINE INDENT x = 9 - w ; NEW_LINE DEDENT elif ( w >= - 9 and w <= - 1 ) : NEW_LINE INDENT x = 10 + w ; NEW_LINE DEDENT sum = pow ( 10 , n - 2 ) ; NEW_LINE sum = ( x * sum ) ; NEW_LINE return sum ; NEW_LINE DEDENT
def arraySortedOrNot ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE if n == 1 or n == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT return arr [ 0 ] <= arr [ 1 ] and arraySortedOrNot ( arr [ 1 : ] ) NEW_LINE DEDENT
def isPowerOfFour ( n ) : NEW_LINE INDENT count = 0 NEW_LINE if ( n and ( not ( n & ( n - 1 ) ) ) ) : NEW_LINE INDENT while ( n > 1 ) : NEW_LINE INDENT n >>= 1 NEW_LINE count += 1 NEW_LINE DEDENT if ( count % 2 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT
def numLen ( K ) : NEW_LINE INDENT if ( K % 2 == 0 or K % 5 == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT number = 0 NEW_LINE len = 1 NEW_LINE for len in range ( 1 , K + 1 ) : NEW_LINE INDENT number = ( number * 10 + 1 ) % K NEW_LINE if number == 0 : NEW_LINE INDENT return len NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def minOperations ( n , a , b , c ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = a [ i ] NEW_LINE y = b [ i ] NEW_LINE z = c [ i ] NEW_LINE if ( x == y and y == z ) : NEW_LINE INDENT continue NEW_LINE DEDENT elif ( x == y or y == z or x == z ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += 2 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def binarySearch ( arr , low , high , key ) : NEW_LINE INDENT if ( high < low ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = ( low + high ) / 2 NEW_LINE if ( key == arr [ int ( mid ) ] ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( key > arr [ int ( mid ) ] ) : NEW_LINE INDENT return binarySearch ( arr , ( mid + 1 ) , high , key ) NEW_LINE DEDENT return ( binarySearch ( arr , low , ( mid - 1 ) , key ) ) NEW_LINE DEDENT
def getPeriod ( n ) : NEW_LINE INDENT rem = 1 NEW_LINE for i in range ( 1 , n + 2 ) : NEW_LINE INDENT rem = ( 10 * rem ) % n NEW_LINE DEDENT d = rem NEW_LINE count = 0 NEW_LINE rem = ( 10 * rem ) % n NEW_LINE count += 1 NEW_LINE while rem != d : NEW_LINE INDENT rem = ( 10 * rem ) % n NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def findMaxProduct ( arr , n ) : NEW_LINE INDENT ans = - float ( ' inf ' ) NEW_LINE maxval = 1 NEW_LINE minval = 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if arr [ i ] > 0 : NEW_LINE INDENT maxval = maxval * arr [ i ] NEW_LINE minval = min ( 1 , minval * arr [ i ] ) NEW_LINE DEDENT elif arr [ i ] == 0 : NEW_LINE INDENT minval = 1 NEW_LINE maxval = 0 NEW_LINE DEDENT elif arr [ i ] < 0 : NEW_LINE INDENT prevMax = maxval NEW_LINE maxval = minval * arr [ i ] NEW_LINE minval = prevMax * arr [ i ] NEW_LINE DEDENT ans = max ( ans , maxval ) NEW_LINE if maxval <= 0 : NEW_LINE INDENT maxval = 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def countStr ( n ) : NEW_LINE INDENT return ( 1 + ( n * 2 ) + ( n * ( ( n * n ) - 1 ) // 2 ) ) NEW_LINE DEDENT
def getMinimumSum ( arr , n ) : NEW_LINE INDENT fMin = sys . maxsize ; NEW_LINE sMin = sys . maxsize ; NEW_LINE tMin = sys . maxsize ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] < fMin ) : NEW_LINE INDENT tMin = sMin ; NEW_LINE sMin = fMin ; NEW_LINE fMin = arr [ i ] ; NEW_LINE DEDENT elif ( arr [ i ] < sMin ) : NEW_LINE INDENT tMin = sMin ; NEW_LINE sMin = arr [ i ] ; NEW_LINE DEDENT elif ( arr [ i ] < tMin ) : NEW_LINE INDENT tMin = arr [ i ] ; NEW_LINE DEDENT DEDENT return ( fMin + sMin + tMin ) ; NEW_LINE DEDENT
def primeProduct ( arr , n ) : NEW_LINE INDENT max_val = max ( arr ) NEW_LINE prime = [ True for i in range ( max_val + 1 ) ] NEW_LINE prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( mt . ceil ( mt . sqrt ( max_val ) ) ) : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT for i in range ( p * 2 , max_val + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT prod = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if prime [ arr [ i ] ] : NEW_LINE INDENT prod *= arr [ i ] NEW_LINE DEDENT DEDENT return prod NEW_LINE DEDENT
def maxDistance ( array ) : NEW_LINE INDENT max1 = - 2147483648 NEW_LINE min1 = + 2147483647 NEW_LINE max2 = - 2147483648 NEW_LINE min2 = + 2147483647 NEW_LINE for i in range ( len ( array ) ) : NEW_LINE INDENT max1 = max ( max1 , array [ i ] + i ) NEW_LINE min1 = min ( min1 , array [ i ] + i ) NEW_LINE max2 = max ( max2 , array [ i ] - i ) NEW_LINE min2 = min ( min2 , array [ i ] - i ) NEW_LINE DEDENT return max ( max1 - min1 , max2 - min2 ) NEW_LINE DEDENT
def maximum_middle_value ( n , k , arr ) : NEW_LINE INDENT ans = - 1 NEW_LINE low = ( n + 1 - k ) // 2 NEW_LINE high = ( n + 1 - k ) // 2 + k NEW_LINE for i in range ( low , high + 1 ) : NEW_LINE INDENT ans = max ( ans , arr [ i - 1 ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def reverse ( q ) : NEW_LINE INDENT s = len ( q ) NEW_LINE ans = deque ( ) NEW_LINE for i in range ( s ) : NEW_LINE INDENT for j in range ( s - 1 ) : NEW_LINE INDENT x = q . popleft ( ) NEW_LINE q . appendleft ( x ) NEW_LINE DEDENT ans . appendleft ( q . popleft ( ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def countSteps ( x , y ) : NEW_LINE INDENT if ( x % y == 0 ) : NEW_LINE INDENT return math . floor ( x / y ) ; NEW_LINE DEDENT return math . floor ( ( x / y ) + countSteps ( y , x % y ) ) ; NEW_LINE DEDENT
def fifthPowerSum ( n ) : NEW_LINE INDENT sm = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sm = sm + ( i * i * i * i * i ) NEW_LINE DEDENT return sm NEW_LINE DEDENT
def divSum ( n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 2 , ( int ) ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( i == ( n / i ) ) : NEW_LINE INDENT result = result + i NEW_LINE DEDENT else : NEW_LINE INDENT result = result + ( i + n // i ) NEW_LINE DEDENT DEDENT DEDENT return ( result + n + 1 ) NEW_LINE DEDENT
def findNextWord ( s , m ) : NEW_LINE INDENT m += 97 NEW_LINE n = len ( s ) NEW_LINE i = len ( s ) - 1 NEW_LINE s [ i ] = chr ( ord ( s [ i ] ) + 1 ) NEW_LINE while i >= 0 and i <= n - 1 : NEW_LINE INDENT if ord ( s [ i ] ) >= m : NEW_LINE INDENT s [ i ] = ' a ' NEW_LINE i -= 1 NEW_LINE s [ i ] = chr ( ord ( s [ i ] ) + 1 ) NEW_LINE DEDENT elif s [ i ] == s [ i - 1 ] or s [ i ] == s [ i - 2 ] : NEW_LINE INDENT s [ i ] = chr ( ord ( s [ i ] ) + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT if i <= - 1 : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' ' . join ( s ) ) NEW_LINE DEDENT DEDENT
def items ( n , a ) : NEW_LINE INDENT a . sort ( ) NEW_LINE z = a [ n - 1 ] NEW_LINE x = 1 NEW_LINE s = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT s += a [ i ] NEW_LINE if ( s <= z ) : NEW_LINE INDENT x += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return x NEW_LINE DEDENT
def isHeterogram ( s , n ) : NEW_LINE INDENT hash = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] != ' ▁ ' : NEW_LINE INDENT if hash [ ord ( s [ i ] ) - ord ( ' a ' ) ] == 0 : NEW_LINE INDENT hash [ ord ( s [ i ] ) - ord ( ' a ' ) ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
def findCount ( str ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( ( i == ord ( str [ i ] ) - ord ( ' a ' ) ) or ( i == ord ( str [ i ] ) - ord ( ' A ' ) ) ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def countWords ( string ) : NEW_LINE INDENT state = OUT NEW_LINE wc = 0 NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if ( string [ i ] == ' ▁ ' or string [ i ] == ' \n ' or string [ i ] == ' \t ' ) : NEW_LINE INDENT state = OUT NEW_LINE DEDENT elif state == OUT : NEW_LINE INDENT state = IN NEW_LINE wc += 1 NEW_LINE DEDENT DEDENT return wc NEW_LINE DEDENT
def CountPair ( arr , n ) : NEW_LINE INDENT result = 0 ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT j = i + 1 NEW_LINE while ( j < n ) : NEW_LINE INDENT if ( i * arr [ i ] > j * arr [ j ] ) : NEW_LINE INDENT result = result + 1 NEW_LINE DEDENT j = j + 1 NEW_LINE DEDENT DEDENT return result ; NEW_LINE DEDENT
def minimumSwaps ( arr ) : NEW_LINE INDENT count = 0 ; NEW_LINE i = 0 ; NEW_LINE while ( i < len ( arr ) ) : NEW_LINE INDENT if ( arr [ i ] != i + 1 ) : NEW_LINE INDENT while ( arr [ i ] != i + 1 ) : NEW_LINE INDENT temp = 0 ; NEW_LINE temp = arr [ arr [ i ] - 1 ] ; NEW_LINE arr [ arr [ i ] - 1 ] = arr [ i ] ; NEW_LINE arr [ i ] = temp ; NEW_LINE count += 1 ; NEW_LINE DEDENT DEDENT i += 1 ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT
def pairs ( n ) : NEW_LINE INDENT c = [ [ 0 for i in range ( 10 ) ] for i in range ( 10 ) ] NEW_LINE tmp = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i >= tmp * 10 ) : NEW_LINE INDENT tmp *= 10 NEW_LINE DEDENT c [ i // tmp ] [ i % 10 ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT for j in range ( 1 , 10 ) : NEW_LINE INDENT ans += c [ i ] [ j ] * c [ j ] [ i ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def longestRepeatedSubSeq ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( str [ i - 1 ] == str [ j - 1 ] and i != j ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT res = ' ' NEW_LINE i = n NEW_LINE j = n NEW_LINE while ( i > 0 and j > 0 ) : NEW_LINE INDENT if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j - 1 ] + 1 ) : NEW_LINE INDENT res += str [ i - 1 ] NEW_LINE i -= 1 NEW_LINE j -= 1 NEW_LINE DEDENT elif ( dp [ i ] [ j ] == dp [ i - 1 ] [ j ] ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT DEDENT res = ' ' . join ( reversed ( res ) ) NEW_LINE return res NEW_LINE DEDENT
def factorial ( n ) : NEW_LINE INDENT i = n NEW_LINE fact = 1 NEW_LINE while ( n / i != n ) : NEW_LINE INDENT fact = fact * i NEW_LINE i -= 1 NEW_LINE DEDENT return fact NEW_LINE DEDENT
def minDiff ( n , x , A ) : NEW_LINE INDENT mn = A [ 0 ] NEW_LINE mx = A [ 0 ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT mn = min ( mn , A [ i ] ) NEW_LINE mx = max ( mx , A [ i ] ) NEW_LINE DEDENT return max ( 0 , mx - mn - 2 * x ) NEW_LINE DEDENT
def calcFunction ( n , r ) : NEW_LINE INDENT finalDenominator = 1 NEW_LINE mx = max ( r , n - r ) NEW_LINE for i in range ( mx + 1 , n + 1 ) : NEW_LINE INDENT denominator = pow ( i , i ) NEW_LINE numerator = pow ( i - mx , i - mx ) NEW_LINE finalDenominator = ( finalDenominator * denominator ) // numerator NEW_LINE DEDENT return finalDenominator NEW_LINE DEDENT
def sumOfSeries ( a , num ) : NEW_LINE INDENT res = 0 NEW_LINE prev = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT prev *= ( a / i ) NEW_LINE res = res + prev NEW_LINE DEDENT return res NEW_LINE DEDENT
def count_numbers ( k , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( 2 ) ] for i in range ( n + 1 ) ] NEW_LINE dp [ 1 ] [ 0 ] = 0 NEW_LINE dp [ 1 ] [ 1 ] = k - 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 1 ] NEW_LINE dp [ i ] [ 1 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] ) * ( k - 1 ) NEW_LINE DEDENT return dp [ n ] [ 0 ] + dp [ n ] [ 1 ] NEW_LINE DEDENT
def majority ( a , p , q , size ) : NEW_LINE INDENT start = 0 NEW_LINE ends = q NEW_LINE arr = [ None ] * p NEW_LINE k = 0 NEW_LINE while ( k < p ) : NEW_LINE INDENT one = 0 NEW_LINE for j in range ( start , ends ) : NEW_LINE INDENT if ( a [ j ] == 1 ) : NEW_LINE INDENT one = one + 1 NEW_LINE DEDENT DEDENT start = ends NEW_LINE ends = ends + q NEW_LINE arr [ k ] = one NEW_LINE k = k + 1 NEW_LINE DEDENT start = 0 NEW_LINE ends = q NEW_LINE found = 0 NEW_LINE while ( ends > 0 ) : NEW_LINE INDENT dist_one = 0 NEW_LINE for i in range ( 0 , p ) : NEW_LINE INDENT if ( arr [ i ] > q / 2 ) : NEW_LINE INDENT dist_one = dist_one + 1 NEW_LINE DEDENT DEDENT if ( dist_one > p / 2 ) : NEW_LINE INDENT found = 1 NEW_LINE print ( " Yes " ) NEW_LINE return NEW_LINE DEDENT start = start - 1 NEW_LINE ends = ends - 1 NEW_LINE if ( start < 0 ) : NEW_LINE INDENT start = size + start NEW_LINE DEDENT st = start NEW_LINE en = ends NEW_LINE l = 0 NEW_LINE while ( en < size ) : NEW_LINE INDENT if ( a [ st % size ] != a [ en % size ] ) : NEW_LINE INDENT if ( a [ st % size ] == 1 ) : NEW_LINE INDENT arr [ l ] = arr [ l ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ l ] = arr [ l ] - 1 NEW_LINE DEDENT DEDENT l = l + 1 NEW_LINE st = ( st + q ) NEW_LINE en = en + q NEW_LINE DEDENT DEDENT if ( found == 0 ) : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def ellipsearea ( r ) : NEW_LINE INDENT if ( r < 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT a = ( 3.14 * r * r ) / 4 ; NEW_LINE return a ; NEW_LINE DEDENT
def findMaximumBefore ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT currAns = - 1 NEW_LINE for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ j ] > currAns and arr [ j ] < arr [ i ] ) : NEW_LINE INDENT currAns = arr [ j ] NEW_LINE DEDENT DEDENT print ( currAns , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def perfectSquares ( l , r ) : NEW_LINE INDENT number = ceil ( sqrt ( l ) ) ; NEW_LINE n2 = number * number ; NEW_LINE number = ( number * 2 ) + 1 ; NEW_LINE while ( ( n2 >= l and n2 <= r ) ) : NEW_LINE INDENT print ( n2 , end = " ▁ " ) ; NEW_LINE n2 = n2 + number ; NEW_LINE number += 2 ; NEW_LINE DEDENT DEDENT
def countWays ( num ) : NEW_LINE INDENT dp = [ 0 ] * ( num + 1 ) ; NEW_LINE MOD = 100000000 + 7 ; NEW_LINE dp [ 1 ] = 2 ; NEW_LINE for i in range ( 2 , num + 1 ) : NEW_LINE INDENT dp [ i ] = 0 ; NEW_LINE for j in range ( 1 , 4 ) : NEW_LINE INDENT if ( i - j == 0 ) : NEW_LINE INDENT dp [ i ] += 1 ; NEW_LINE DEDENT elif ( j == 1 ) : NEW_LINE INDENT dp [ i ] += dp [ i - j ] * 2 ; NEW_LINE DEDENT elif ( i - j > 0 ) : NEW_LINE INDENT dp [ i ] += dp [ i - j ] ; NEW_LINE DEDENT DEDENT if ( dp [ i ] >= MOD ) : NEW_LINE INDENT dp [ i ] %= MOD ; NEW_LINE DEDENT DEDENT return dp [ num ] ; NEW_LINE DEDENT
def sumOfTermsInNthRow ( n ) : NEW_LINE INDENT sum = n * ( 2 * pow ( n , 2 ) + 1 ) NEW_LINE return sum NEW_LINE DEDENT
def minToggle ( arr , n ) : NEW_LINE INDENT zero = [ 0 for i in range ( n + 1 + 1 ) ] NEW_LINE zero [ 0 ] = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( arr [ i - 1 ] == 0 ) : NEW_LINE INDENT zero [ i ] = zero [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT zero [ i ] = zero [ i - 1 ] NEW_LINE DEDENT DEDENT ans = n NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans = min ( ans , i - zero [ i ] + zero [ n ] - zero [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def checksum ( n ) : NEW_LINE INDENT n = int ( n ) NEW_LINE if n % 3 == 0 : NEW_LINE INDENT print ( int ( n / 3 - 1 ) , " ▁ " , int ( n / 3 ) , " ▁ " , int ( n / 3 + 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT DEDENT
def FirstAndLast ( string ) : NEW_LINE INDENT arrOfStr = string . split ( ) ; NEW_LINE res = " " ; NEW_LINE for a in arrOfStr : NEW_LINE INDENT res += a [ 1 : len ( a ) - 1 ] + " ▁ " ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT
def countWays ( a , n ) : NEW_LINE INDENT suff = [ 0 ] * n NEW_LINE if ( a [ n - 1 ] == 2 ) : NEW_LINE INDENT suff [ n - 1 ] = 1 NEW_LINE DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( a [ i ] == 2 ) : NEW_LINE INDENT suff [ i ] = suff [ i + 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT suff [ i ] = suff [ i + 1 ] NEW_LINE DEDENT DEDENT ss = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == 1 ) : NEW_LINE INDENT ss += suff [ i ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( a [ i ] == 1 and a [ j ] == 1 and suff [ j ] >= 2 ) : NEW_LINE INDENT ss += ( suff [ j ] ) * ( suff [ j ] - 1 ) // 2 NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( a [ i ] == 1 and a [ j ] == 1 and ( suff [ i ] - suff [ j ] ) >= 1 and suff [ j ] >= 1 ) : NEW_LINE INDENT ss += ( suff [ i ] - suff [ j ] ) * suff [ j ] NEW_LINE DEDENT DEDENT DEDENT print ( ss ) NEW_LINE DEDENT
def find_number ( N , K ) : NEW_LINE INDENT r = " " NEW_LINE if ( N % 100 == 0 ) : NEW_LINE INDENT N += 1 ; NEW_LINE r = str ( N ) NEW_LINE DEDENT else : NEW_LINE INDENT r = str ( N ) NEW_LINE DEDENT for i in range ( 1 , K + 1 ) : NEW_LINE INDENT r += "00" NEW_LINE DEDENT return r NEW_LINE DEDENT
def distinct_years ( str ) : NEW_LINE INDENT str2 = " " NEW_LINE uniqueDates = set ( ) NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if str [ i ] . isdigit ( ) : NEW_LINE INDENT str2 += str [ i ] NEW_LINE DEDENT if str [ i ] == ' - ' : NEW_LINE INDENT str2 = " " NEW_LINE DEDENT if len ( str2 ) == 4 : NEW_LINE INDENT uniqueDates . add ( str2 ) NEW_LINE str2 = " " NEW_LINE DEDENT DEDENT return len ( uniqueDates ) NEW_LINE DEDENT
def isSubsetAndZero ( array , length , N ) : NEW_LINE INDENT arrAnd = array [ 0 ] NEW_LINE for i in range ( 1 , length ) : NEW_LINE INDENT arrAnd = arrAnd & array [ i ] NEW_LINE DEDENT if ( ( arrAnd & N ) == 0 ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def ReplaceElements ( arr , n ) : NEW_LINE INDENT prod = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT prod *= arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = prod // arr [ i ] NEW_LINE DEDENT DEDENT
def countSubarrays ( a , n , x ) : NEW_LINE INDENT count = 0 NEW_LINE number = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] > x ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT number += ( count ) * ( count + 1 ) / 2 NEW_LINE count = 0 NEW_LINE DEDENT DEDENT if ( count ) : NEW_LINE INDENT number += ( count ) * ( count + 1 ) / 2 NEW_LINE DEDENT return int ( number ) NEW_LINE DEDENT
def cntSquares ( n ) : NEW_LINE INDENT return int ( n * ( n + 1 ) * ( 2 * n + 1 ) / 6 ) NEW_LINE DEDENT
def countDistinct ( arr , k , n ) : NEW_LINE INDENT mp = defaultdict ( lambda : 0 ) NEW_LINE dist_count = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT if mp [ arr [ i ] ] == 0 : NEW_LINE INDENT dist_count += 1 NEW_LINE DEDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT print ( dist_count ) NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT if mp [ arr [ i - k ] ] == 1 : NEW_LINE INDENT dist_count -= 1 NEW_LINE DEDENT mp [ arr [ i - k ] ] -= 1 NEW_LINE if mp [ arr [ i ] ] == 0 : NEW_LINE INDENT dist_count += 1 NEW_LINE DEDENT mp [ arr [ i ] ] += 1 NEW_LINE print ( dist_count ) NEW_LINE DEDENT DEDENT
def maxSubStr ( str1 , len1 , str2 , len2 ) : NEW_LINE INDENT if ( len1 > len2 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT freq1 = [ 0 ] * MAX ; NEW_LINE for i in range ( len1 ) : NEW_LINE INDENT freq1 [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 ; NEW_LINE DEDENT freq2 = [ 0 ] * MAX ; NEW_LINE for i in range ( len2 ) : NEW_LINE INDENT freq2 [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] += 1 ; NEW_LINE DEDENT minPoss = sys . maxsize ; NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT if ( freq1 [ i ] == 0 ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT if ( freq1 [ i ] > freq2 [ i ] ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT minPoss = min ( minPoss , freq2 [ i ] / freq1 [ i ] ) ; NEW_LINE DEDENT return int ( minPoss ) ; NEW_LINE DEDENT
def findMinValue ( arr , n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += math . log10 ( arr [ i ] ) + EPS ; NEW_LINE DEDENT xl = ( sum / n + EPS ) ; NEW_LINE res = math . pow ( 10.0 , xl ) + EPS ; NEW_LINE return math . ceil ( res + EPS ) ; NEW_LINE DEDENT
def totalSumDivisibleByNum ( n , number ) : NEW_LINE INDENT firstnum = pow ( 10 , n - 1 ) NEW_LINE lastnum = pow ( 10 , n ) NEW_LINE sum = 0 NEW_LINE for i in range ( firstnum , lastnum ) : NEW_LINE INDENT if ( i % number == 0 ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def MinDeletion ( a , n ) : NEW_LINE INDENT map = dict . fromkeys ( a , 0 ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT map [ a [ i ] ] += 1 ; NEW_LINE DEDENT ans = 0 ; NEW_LINE for key , value in map . items ( ) : NEW_LINE INDENT x = key ; NEW_LINE frequency = value ; NEW_LINE if ( x <= frequency ) : NEW_LINE INDENT ans += ( frequency - x ) ; NEW_LINE DEDENT else : NEW_LINE INDENT ans += frequency ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT
def sortedAdjacentDifferences ( arr , n ) : NEW_LINE INDENT ans = [ 0 ] * n NEW_LINE arr = sorted ( arr ) NEW_LINE l = 0 NEW_LINE r = n - 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( i % 2 ) : NEW_LINE INDENT ans [ i ] = arr [ l ] NEW_LINE l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans [ i ] = arr [ r ] NEW_LINE r -= 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( ans [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def check ( a , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def findRemainder ( n ) : NEW_LINE INDENT l = n % 10 NEW_LINE while ( n >= 10 ) : NEW_LINE INDENT n //= 10 NEW_LINE DEDENT f = n NEW_LINE remainder = f % l NEW_LINE print ( remainder ) NEW_LINE DEDENT
def findNth ( n ) : NEW_LINE INDENT nthElement = 19 + ( n - 1 ) * 9 NEW_LINE outliersCount = int ( math . log10 ( nthElement ) ) - 1 NEW_LINE nthElement += 9 * outliersCount NEW_LINE return nthElement NEW_LINE DEDENT
def find ( n ) : NEW_LINE INDENT b = n NEW_LINE a = b * ( n - 1 ) NEW_LINE if a * b > n and a // b < n : NEW_LINE INDENT print ( " a ▁ = ▁ { } , ▁ b ▁ = ▁ { } " . format ( a , b ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT
def maxAbsDiff ( arr , n ) : NEW_LINE INDENT minEle = arr [ 0 ] NEW_LINE maxEle = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT minEle = min ( minEle , arr [ i ] ) NEW_LINE maxEle = max ( maxEle , arr [ i ] ) NEW_LINE DEDENT return ( maxEle - minEle ) NEW_LINE DEDENT
def canBecomeEmpty ( string , sub_str ) : NEW_LINE INDENT while len ( string ) > 0 : NEW_LINE INDENT idx = string . find ( sub_str ) NEW_LINE if idx == - 1 : NEW_LINE INDENT break NEW_LINE DEDENT string = string . replace ( sub_str , " " , 1 ) NEW_LINE DEDENT return ( len ( string ) == 0 ) NEW_LINE DEDENT
def printNumberWithDR ( k , d ) : NEW_LINE INDENT if d == 0 and k != 1 : NEW_LINE INDENT print ( - 1 , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( d , end = " " ) NEW_LINE k -= 1 NEW_LINE while k : NEW_LINE INDENT print ( 0 , end = " " ) NEW_LINE k -= 1 NEW_LINE DEDENT DEDENT DEDENT
def areSetBitsIncreasing ( n ) : NEW_LINE INDENT prev_count = sys . maxsize NEW_LINE while ( n > 0 ) : NEW_LINE INDENT while ( n > 0 and n % 2 == 0 ) : NEW_LINE INDENT n = int ( n / 2 ) NEW_LINE DEDENT curr_count = 1 NEW_LINE while ( n > 0 and n % 2 == 1 ) : NEW_LINE INDENT n = n / 2 NEW_LINE curr_count += 1 NEW_LINE DEDENT if ( curr_count >= prev_count ) : NEW_LINE INDENT return False NEW_LINE DEDENT prev_count = curr_count NEW_LINE DEDENT return True NEW_LINE DEDENT
def maximumSumSubarray ( arr , n ) : NEW_LINE INDENT min_prefix_sum = 0 NEW_LINE res = - math . inf NEW_LINE prefix_sum = [ ] NEW_LINE prefix_sum . append ( arr [ 0 ] ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT prefix_sum . append ( prefix_sum [ i - 1 ] + arr [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT res = max ( res , prefix_sum [ i ] - min_prefix_sum ) NEW_LINE min_prefix_sum = min ( min_prefix_sum , prefix_sum [ i ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def ifPossible ( arr , n ) : NEW_LINE INDENT cp = [ 0 ] * n NEW_LINE cp = arr NEW_LINE cp . sort ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( not ( arr [ i ] == cp [ i ] ) and not ( arr [ n - 1 - i ] == cp [ i ] ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def inversegrayCode ( n ) : NEW_LINE INDENT inv = 0 ; NEW_LINE while ( n ) : NEW_LINE INDENT inv = inv ^ n ; NEW_LINE n = n >> 1 ; NEW_LINE DEDENT return inv ; NEW_LINE DEDENT
def squareRoot ( number , precision ) : NEW_LINE INDENT start = 0 NEW_LINE end , ans = number , 1 NEW_LINE while ( start <= end ) : NEW_LINE INDENT mid = int ( ( start + end ) / 2 ) NEW_LINE if ( mid * mid == number ) : NEW_LINE INDENT ans = mid NEW_LINE break NEW_LINE DEDENT if ( mid * mid < number ) : NEW_LINE INDENT start = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT end = mid - 1 NEW_LINE DEDENT DEDENT increment = 0.1 NEW_LINE for i in range ( 0 , precision ) : NEW_LINE INDENT while ( ans * ans <= number ) : NEW_LINE INDENT ans += increment NEW_LINE DEDENT ans = ans - increment NEW_LINE increment = increment / 10 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def dayofweek ( d , m , y ) : NEW_LINE INDENT t = [ 0 , 3 , 2 , 5 , 0 , 3 , 5 , 1 , 4 , 6 , 2 , 4 ] NEW_LINE y -= m < 3 NEW_LINE return ( ( y + int ( y / 4 ) - int ( y / 100 ) + int ( y / 400 ) + t [ m - 1 ] + d ) % 7 ) NEW_LINE DEDENT
def countZeros ( a , n ) : NEW_LINE INDENT count2 = 0 NEW_LINE count5 = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT while ( a [ i ] % 2 == 0 ) : NEW_LINE INDENT a [ i ] = a [ i ] // 2 NEW_LINE count2 = count2 + 1 NEW_LINE DEDENT while ( a [ i ] % 5 == 0 ) : NEW_LINE INDENT a [ i ] = a [ i ] // 5 NEW_LINE count5 = count5 + 1 NEW_LINE DEDENT DEDENT if ( count2 < count5 ) : NEW_LINE INDENT return count2 NEW_LINE DEDENT else : NEW_LINE INDENT return count5 NEW_LINE DEDENT DEDENT
def minimizeDiff ( arr , n , k ) : NEW_LINE INDENT max_element = max ( arr ) NEW_LINE min_element = min ( arr ) NEW_LINE if ( ( max_element - min_element ) <= k ) : NEW_LINE INDENT return ( max_element - min_element ) NEW_LINE DEDENT avg = ( max_element + min_element ) // 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > avg ) : NEW_LINE INDENT arr [ i ] -= k NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] += k NEW_LINE DEDENT DEDENT max_element = max ( arr ) NEW_LINE min_element = min ( arr ) NEW_LINE return ( max_element - min_element ) ; NEW_LINE DEDENT
def findWater ( i , j , X ) : NEW_LINE INDENT if ( j > i ) : NEW_LINE INDENT print ( " Incorrect ▁ Input " ) ; NEW_LINE return ; NEW_LINE DEDENT glass = [ 0 ] * int ( i * ( i + 1 ) / 2 ) ; NEW_LINE index = 0 ; NEW_LINE glass [ index ] = X ; NEW_LINE for row in range ( 1 , i ) : NEW_LINE INDENT for col in range ( 1 , row + 1 ) : NEW_LINE INDENT X = glass [ index ] ; NEW_LINE glass [ index ] = 1.0 if ( X >= 1.0 ) else X ; NEW_LINE X = ( X - 1 ) if ( X >= 1.0 ) else 0.0 ; NEW_LINE glass [ index + row ] += ( X / 2 ) ; NEW_LINE glass [ index + row + 1 ] += ( X / 2 ) ; NEW_LINE index += 1 ; NEW_LINE DEDENT DEDENT return glass [ int ( i * ( i - 1 ) / 2 + j - 1 ) ] ; NEW_LINE DEDENT
def findLen ( arr , i , curr , n , m ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT if ( curr == m ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT DEDENT if ( v [ i ] [ curr ] ) : NEW_LINE INDENT return dp [ i ] [ curr ] ; NEW_LINE DEDENT v [ i ] [ curr ] = 1 ; NEW_LINE l = findLen ( arr , i + 1 , curr , n , m ) ; NEW_LINE r = findLen ( arr , i + 1 , curr | arr [ i ] , n , m ) ; NEW_LINE dp [ i ] [ curr ] = l ; NEW_LINE if ( r != - 1 ) : NEW_LINE INDENT dp [ i ] [ curr ] = max ( dp [ i ] [ curr ] , r + 1 ) ; NEW_LINE DEDENT return dp [ i ] [ curr ] ; NEW_LINE DEDENT
def count_pairs ( s1 , s2 , n1 , n2 ) : NEW_LINE INDENT mp = { s1 [ i ] : 0 for i in range ( len ( s1 ) ) } NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT mp [ s1 [ i ] ] += 1 NEW_LINE DEDENT cnt = 0 NEW_LINE for i in range ( n2 ) : NEW_LINE INDENT if ( mp [ s2 [ i ] ] > 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE mp [ s2 [ i ] ] -= 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
def maxPrimefactorNum ( N ) : NEW_LINE INDENT if ( N < 2 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT arr = [ True ] * ( N + 1 ) ; NEW_LINE prod = 1 ; NEW_LINE res = 0 ; NEW_LINE p = 2 ; NEW_LINE while ( p * p <= N ) : NEW_LINE INDENT if ( arr [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , N + 1 , p ) : NEW_LINE INDENT arr [ i ] = False ; NEW_LINE DEDENT prod *= p ; NEW_LINE if ( prod > N ) : NEW_LINE INDENT return res ; NEW_LINE DEDENT res += 1 ; NEW_LINE DEDENT p += 1 ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT
def findAndPrintUncommonChars ( str1 , str2 ) : NEW_LINE INDENT present = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( 0 , MAX_CHAR ) : NEW_LINE INDENT present [ i ] = 0 NEW_LINE DEDENT l1 = len ( str1 ) NEW_LINE l2 = len ( str2 ) NEW_LINE for i in range ( 0 , l1 ) : NEW_LINE INDENT present [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] = 1 NEW_LINE DEDENT for i in range ( 0 , l2 ) : NEW_LINE INDENT if ( present [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] == 1 or present [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] == - 1 ) : NEW_LINE INDENT present [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] = - 1 NEW_LINE DEDENT else : NEW_LINE INDENT present [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] = 2 NEW_LINE DEDENT DEDENT for i in range ( 0 , MAX_CHAR ) : NEW_LINE INDENT if ( present [ i ] == 1 or present [ i ] == 2 ) : NEW_LINE INDENT print ( chr ( i + ord ( ' a ' ) ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def xorEqualsOrCount ( N ) : NEW_LINE INDENT count = 0 NEW_LINE while ( N > 0 ) : NEW_LINE INDENT bit = N % 2 NEW_LINE if bit == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT N //= 2 NEW_LINE DEDENT return int ( pow ( 2 , count ) ) NEW_LINE DEDENT
def minRange ( arr , n , k ) : NEW_LINE INDENT l = 0 NEW_LINE r = n NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = [ ] NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT s . append ( arr [ j ] ) NEW_LINE if ( len ( s ) == k ) : NEW_LINE INDENT if ( ( j - i ) < ( r - l ) ) : NEW_LINE INDENT r = j NEW_LINE l = i NEW_LINE DEDENT break NEW_LINE DEDENT DEDENT if ( j == n ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( l == 0 and r == n ) : NEW_LINE INDENT print ( " Invalid ▁ k " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( l , r ) NEW_LINE DEDENT DEDENT
def pattern ( nos , i , space ) : NEW_LINE INDENT prt = ' $ ' NEW_LINE for s in range ( nos , 0 , - 1 ) : NEW_LINE INDENT print ( end = " ▁ ▁ " ) NEW_LINE DEDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT if ( space != 0 ) : NEW_LINE INDENT if ( i == 9 and j == 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT if ( i == 1 or i == 9 ) : NEW_LINE INDENT print ( prt , end = " " ) NEW_LINE DEDENT elif ( j == 1 or j == i ) : NEW_LINE INDENT print ( prt , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( end = " ▁ ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def solve ( A , B ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , 32 ) : NEW_LINE INDENT if ( ( ( A >> i ) & 1 ) != ( ( B >> i ) & 1 ) ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT print ( " Number ▁ of ▁ different ▁ bits ▁ : " , count ) NEW_LINE DEDENT
def findSubArr ( arr , n ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT if ( abs ( arr [ i ] - arr [ i + 1 ] ) >= 2 ) : NEW_LINE INDENT print ( arr [ i ] , arr [ i + 1 ] , end = " " ) ; NEW_LINE return ; NEW_LINE DEDENT DEDENT print ( - 1 ) ; NEW_LINE DEDENT
def pattern ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , 2 * n ) : NEW_LINE INDENT if i > ( n - j + 1 ) : NEW_LINE INDENT print ( " " , end = ' ▁ ' ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " * " , end = ' ' ) ; NEW_LINE DEDENT if i + n - 1 > j : NEW_LINE INDENT print ( " " , end = ' ▁ ' ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " * " , end = ' ' ) ; NEW_LINE DEDENT DEDENT print ( " " ) ; NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , 2 * n ) : NEW_LINE INDENT if i < j : NEW_LINE INDENT print ( " " , end = ' ▁ ' ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " * " , end = ' ' ) ; NEW_LINE DEDENT if i < 2 * n - j : NEW_LINE INDENT print ( " " , end = ' ▁ ' ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " * " , end = ' ' ) ; NEW_LINE DEDENT DEDENT print ( " " ) ; NEW_LINE DEDENT DEDENT
def encode ( s , k ) : NEW_LINE INDENT newS = " " NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT val = ord ( s [ i ] ) NEW_LINE dup = k NEW_LINE if val + k > 122 : NEW_LINE INDENT k -= ( 122 - val ) NEW_LINE k = k % 26 NEW_LINE newS += chr ( 96 + k ) NEW_LINE DEDENT else : NEW_LINE INDENT newS += chr ( val + k ) NEW_LINE DEDENT k = dup NEW_LINE DEDENT print ( newS ) NEW_LINE DEDENT
def pushZerosToEnd ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] != 0 : NEW_LINE INDENT arr [ count ] = arr [ i ] NEW_LINE count += 1 NEW_LINE DEDENT DEDENT while count < n : NEW_LINE INDENT arr [ count ] = 0 NEW_LINE count += 1 NEW_LINE DEDENT DEDENT
def properDivisorSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += ( n // i ) * i NEW_LINE DEDENT return sum - n * ( n + 1 ) // 2 NEW_LINE DEDENT
def FindAllElements ( n , k ) : NEW_LINE INDENT sum = k NEW_LINE A = [ 1 for i in range ( k ) ] NEW_LINE i = k - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT while ( sum + A [ i ] <= n ) : NEW_LINE INDENT sum += A [ i ] NEW_LINE A [ i ] *= 2 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT if ( sum != n ) : NEW_LINE INDENT print ( " Impossible " ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 0 , k , 1 ) : NEW_LINE INDENT print ( A [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT DEDENT
def pairCount ( arr , n ) : NEW_LINE INDENT max_val = arr [ 0 ] NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT if ( arr [ i ] > max_val ) : NEW_LINE INDENT max_val = arr [ i ] NEW_LINE DEDENT DEDENT prime = [ True for i in range ( max_val + 1 ) ] NEW_LINE prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE k = int ( sqrt ( max_val ) ) + 1 NEW_LINE for p in range ( 2 , k , 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , max_val + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT count = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return ( count * ( count - 1 ) ) / 2 NEW_LINE DEDENT
def pattern ( n ) : NEW_LINE INDENT for i in range ( 1 , n * 2 + 1 ) : NEW_LINE INDENT print ( end = " ▁ " ) NEW_LINE DEDENT print ( "0" ) NEW_LINE for i in range ( 1 , n * 2 ) : NEW_LINE INDENT if ( i < n ) : NEW_LINE INDENT for j in range ( 1 , ( n - i ) * 2 + 1 ) : NEW_LINE INDENT print ( end = " ▁ " ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for j in range ( 1 , ( i % n ) * 2 + 1 ) : NEW_LINE INDENT print ( end = " ▁ " ) NEW_LINE DEDENT DEDENT if ( i < n ) : NEW_LINE INDENT for j in range ( i % n + 1 ) : NEW_LINE INDENT print ( j , end = " ▁ " ) NEW_LINE DEDENT for j in range ( i % n - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( j , end = " ▁ " ) NEW_LINE DEDENT DEDENT elif ( i > n ) : NEW_LINE INDENT for j in range ( n - ( i - n ) + 1 ) : NEW_LINE INDENT print ( j , end = " ▁ " ) NEW_LINE DEDENT for j in range ( ( n - ( i - n ) ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( j , end = " ▁ " ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT print ( j , end = " ▁ " ) NEW_LINE DEDENT for j in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( j , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT for i in range ( 1 , n * 2 + 1 ) : NEW_LINE INDENT print ( end = " ▁ " ) NEW_LINE DEDENT print ( "0" , end = " " ) NEW_LINE DEDENT
def countManipulations ( s1 , s2 ) : NEW_LINE INDENT count = 0 NEW_LINE char_count = [ 0 ] * 26 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT char_count [ i ] = 0 NEW_LINE DEDENT for i in range ( len ( s1 ) ) : NEW_LINE INDENT char_count [ ord ( s1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( len ( s2 ) ) : NEW_LINE INDENT char_count [ ord ( s2 [ i ] ) - ord ( ' a ' ) ] -= 1 NEW_LINE if ( char_count [ ord ( s2 [ i ] ) - ord ( ' a ' ) ] < 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def lineExists ( x , y , v , n ) : NEW_LINE INDENT size = ( 2 * MAX ) + 1 ; NEW_LINE arr = [ 0 ] * size ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ x [ i ] + MAX ] += v [ i ] ; NEW_LINE DEDENT for i in range ( 1 , size ) : NEW_LINE INDENT arr [ i ] += arr [ i - 1 ] ; NEW_LINE DEDENT if ( arr [ size - 1 ] == 0 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT if ( arr [ size - 1 ] - arr [ 0 ] == 0 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT for i in range ( 1 , size - 1 ) : NEW_LINE INDENT if ( arr [ i - 1 ] == arr [ size - 1 ] - arr [ i - 1 ] ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT if ( arr [ i - 1 ] == arr [ size - 1 ] - arr [ i ] ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT if ( arr [ i ] == arr [ size - 1 ] - arr [ i ] ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT if ( arr [ size - 2 ] == 0 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT
def countZeros ( x ) : NEW_LINE INDENT total_bits = 32 NEW_LINE res = 0 NEW_LINE while ( ( x & ( 1 << ( total_bits - 1 ) ) ) == 0 ) : NEW_LINE INDENT x = ( x << 1 ) NEW_LINE res += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
def isPresent ( s , q ) : NEW_LINE INDENT freq = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) ] += 1 NEW_LINE DEDENT for i in range ( 0 , len ( q ) ) : NEW_LINE INDENT freq [ ord ( q [ i ] ) ] -= 1 NEW_LINE if ( freq [ ord ( q [ i ] ) ] < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def prints ( a , n , ind ) : NEW_LINE INDENT b = [ None ] * 2 * n NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT b [ i ] = b [ n + i ] = a [ i ] NEW_LINE i = i + 1 NEW_LINE DEDENT i = ind NEW_LINE while i < n + ind : NEW_LINE INDENT print ( b [ i ] , end = " ▁ " ) ; NEW_LINE i = i + 1 NEW_LINE DEDENT DEDENT
def countNonEmptySubstr ( str ) : NEW_LINE INDENT n = len ( str ) ; NEW_LINE return int ( n * ( n + 1 ) / 2 ) ; NEW_LINE DEDENT
def countIndices ( arr , n ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE max = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( max < arr [ i ] ) : NEW_LINE INDENT max = arr [ i ] ; NEW_LINE cnt += 1 ; NEW_LINE DEDENT DEDENT return cnt ; NEW_LINE DEDENT
def findTriplets ( x ) : NEW_LINE INDENT fact = [ ] ; NEW_LINE factors = set ( ) ; NEW_LINE for i in range ( 2 , int ( sqrt ( x ) ) ) : NEW_LINE INDENT if ( x % i == 0 ) : NEW_LINE INDENT fact . append ( i ) ; NEW_LINE if ( x / i != i ) : NEW_LINE INDENT fact . append ( x // i ) ; NEW_LINE DEDENT factors . add ( i ) ; NEW_LINE factors . add ( x // i ) ; NEW_LINE DEDENT DEDENT found = False ; NEW_LINE k = len ( fact ) ; NEW_LINE for i in range ( k ) : NEW_LINE INDENT a = fact [ i ] ; NEW_LINE for j in range ( k ) : NEW_LINE INDENT b = fact [ j ] ; NEW_LINE if ( ( a != b ) and ( x % ( a * b ) == 0 ) and ( x / ( a * b ) != a ) and ( x / ( a * b ) != b ) and ( x / ( a * b ) != 1 ) ) : NEW_LINE INDENT print ( a , b , x // ( a * b ) ) ; NEW_LINE found = True ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( found ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT if ( not found ) : NEW_LINE INDENT print ( " - 1" ) ; NEW_LINE DEDENT DEDENT
def processQueries ( Q , m , n ) : NEW_LINE INDENT a = [ 0 ] * ( m + 1 ) ; pos = [ 0 ] * ( m + 1 ) ; NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT a [ i - 1 ] = i ; NEW_LINE pos [ i ] = i - 1 ; NEW_LINE DEDENT ans = [ ] ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT q = Q [ i ] ; NEW_LINE p = pos [ q ] ; NEW_LINE ans . append ( p ) ; NEW_LINE for i in range ( p , 0 , - 1 ) : NEW_LINE INDENT a [ i ] , a [ i - 1 ] = a [ i - 1 ] , a [ i ] ; NEW_LINE pos [ a [ i ] ] = i ; NEW_LINE DEDENT pos [ a [ 0 ] ] = 0 ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT
def solve ( a , b ) : NEW_LINE INDENT l = len ( a ) NEW_LINE min = 0 NEW_LINE max = 0 NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( a [ i ] == ' + ' or b [ i ] == ' + ' or a [ i ] != b [ i ] ) : NEW_LINE INDENT max += 1 NEW_LINE DEDENT if ( a [ i ] != ' + ' and b [ i ] != ' + ' and a [ i ] != b [ i ] ) : NEW_LINE INDENT min += 1 NEW_LINE DEDENT DEDENT print ( min + max ) NEW_LINE DEDENT
def checksum ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT print ( " - 1 ▁ 0 ▁ 1" ) NEW_LINE return 0 NEW_LINE DEDENT inc = 0 NEW_LINE if n > 0 : NEW_LINE INDENT inc = 1 NEW_LINE DEDENT else : NEW_LINE INDENT inc = - 1 NEW_LINE DEDENT for i in range ( 0 , n - 1 , inc ) : NEW_LINE INDENT if i + i + 1 + i + 2 == n : NEW_LINE INDENT print ( i , " ▁ " , i + 1 , " ▁ " , i + 2 ) NEW_LINE return 0 NEW_LINE DEDENT DEDENT print ( " - 1" ) NEW_LINE DEDENT
def calculateLeaps ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT return ( 1 << ( n - 1 ) ) ; NEW_LINE DEDENT
def isdivisible7 ( num ) : NEW_LINE INDENT n = len ( num ) NEW_LINE if ( n == 0 and num [ 0 ] == ' \n ' ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n % 3 == 1 ) : NEW_LINE INDENT num = str ( num ) + "00" NEW_LINE n += 2 NEW_LINE DEDENT elif ( n % 3 == 2 ) : NEW_LINE INDENT num = str ( num ) + "0" NEW_LINE n += 1 NEW_LINE DEDENT GSum = 0 NEW_LINE p = 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT group = 0 NEW_LINE group += ord ( num [ i ] ) - ord ( '0' ) NEW_LINE i -= 1 NEW_LINE group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 10 NEW_LINE i -= 1 NEW_LINE group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 100 NEW_LINE GSum = GSum + group * p NEW_LINE p *= ( - 1 ) NEW_LINE DEDENT return ( GSum % 7 == 0 ) NEW_LINE DEDENT
def getXandYintercept ( P , Q ) : NEW_LINE INDENT a = P [ 1 ] - Q [ 1 ] NEW_LINE b = P [ 0 ] - Q [ 0 ] NEW_LINE if b == 0 : NEW_LINE INDENT print ( P [ 0 ] ) NEW_LINE print ( " infinity " ) NEW_LINE return NEW_LINE DEDENT if a == 0 : NEW_LINE INDENT print ( " infinity " ) NEW_LINE print ( P [ 1 ] ) NEW_LINE return NEW_LINE DEDENT m = a / b NEW_LINE x = P [ 0 ] NEW_LINE y = P [ 1 ] NEW_LINE c = y - m * x NEW_LINE y = 0 NEW_LINE x = ( y - c ) / m NEW_LINE print ( x ) NEW_LINE x = 0 NEW_LINE y = m * x + c NEW_LINE print ( y ) NEW_LINE DEDENT
def getMaxLength ( arr , n ) : NEW_LINE INDENT l = n ; NEW_LINE i = 0 ; maxlen = 0 ; NEW_LINE while ( i < l ) : NEW_LINE INDENT j = i ; NEW_LINE while ( i + 1 < l and ( abs ( arr [ i ] - arr [ i + 1 ] ) == 1 or abs ( arr [ i ] - arr [ i + 1 ] ) == 0 ) ) : NEW_LINE INDENT i += 1 ; NEW_LINE DEDENT currLen = i - j + 1 ; NEW_LINE if ( maxlen < currLen ) : NEW_LINE INDENT maxlen = currLen ; NEW_LINE DEDENT if ( j == i ) : NEW_LINE INDENT i += 1 ; NEW_LINE DEDENT DEDENT return maxlen ; NEW_LINE DEDENT
def countPairs ( str1 ) : NEW_LINE INDENT result = 0 ; NEW_LINE n = len ( str1 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 1 , MAX_CHAR + 1 ) : NEW_LINE INDENT if ( ( i + j ) < n ) : NEW_LINE INDENT if ( ( abs ( ord ( str1 [ i + j ] ) - ord ( str1 [ i ] ) ) == j ) ) : NEW_LINE INDENT result += 1 ; NEW_LINE DEDENT DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def area ( a ) : NEW_LINE INDENT if a < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT area = sqrt ( a ) / 6 NEW_LINE return area NEW_LINE DEDENT
def minOperations ( n , m ) : NEW_LINE INDENT a = 0 ; k = 1 ; NEW_LINE p = max ( n , m ) ; NEW_LINE while ( n != m ) : NEW_LINE INDENT s = float ( p - n + p - m ) ; NEW_LINE q = ( - 1 + sqrt ( 8 * s + 1 ) ) / 2 ; NEW_LINE if ( q - floor ( q ) == 0 ) : NEW_LINE INDENT a = q ; NEW_LINE n = m ; NEW_LINE DEDENT p = p + 1 ; NEW_LINE DEDENT return a ; NEW_LINE DEDENT
def surfaceArea ( b , s ) : NEW_LINE INDENT return 2 * b * s + pow ( b , 2 ) NEW_LINE DEDENT
def solve ( d1 , d2 , d3 ) : NEW_LINE INDENT maxx = max ( d1 , max ( d2 , d3 ) ) NEW_LINE sum = ( d1 + d2 + d3 ) NEW_LINE if ( 2 * maxx > sum or sum % 2 == 1 ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE return NEW_LINE DEDENT x1 = 0 NEW_LINE y1 = 0 NEW_LINE x2 = d1 NEW_LINE y2 = 0 NEW_LINE x3 = ( d1 + d2 - d3 ) // 2 NEW_LINE y3 = ( d2 + d3 - d1 ) // 2 NEW_LINE print ( " ( " , x1 , " , " , y1 , " ) , ▁ ( " , x2 , " , " , y2 , " ) ▁ and ▁ ( " , x3 , " , " , y3 , " ) " ) NEW_LINE DEDENT
def maxSumArrangement ( A , R , N , M ) : NEW_LINE INDENT count = [ 0 for i in range ( N ) ] NEW_LINE for i in range ( M ) : NEW_LINE INDENT l = R [ i ] [ 0 ] NEW_LINE r = R [ i ] [ 1 ] + 1 NEW_LINE l = l - 1 NEW_LINE r = r - 1 NEW_LINE count [ l ] = count [ l ] + 1 NEW_LINE if ( r < N ) : NEW_LINE INDENT count [ r ] = count [ r ] - 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT count [ i ] = count [ i ] + count [ i - 1 ] NEW_LINE DEDENT ans = 0 NEW_LINE count . sort ( ) NEW_LINE A . sort ( ) NEW_LINE for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT ans = ans + A [ i ] * count [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT
def getMinNumberForPattern ( seq ) : NEW_LINE INDENT n = len ( seq ) NEW_LINE if ( n >= 9 ) : NEW_LINE INDENT return " - 1" NEW_LINE DEDENT result = [ None ] * ( n + 1 ) NEW_LINE count = 1 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT if ( i == n or seq [ i ] == ' I ' ) : NEW_LINE INDENT for j in range ( i - 1 , - 2 , - 1 ) : NEW_LINE INDENT result [ j + 1 ] = int ( '0' + str ( count ) ) NEW_LINE count += 1 NEW_LINE if ( j >= 0 and seq [ j ] == ' I ' ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def checkConcurrent ( a1 , b1 , c1 , a2 , b2 , c2 , a3 , b3 , c3 ) : NEW_LINE INDENT return ( a3 * ( b1 * c2 - b2 * c1 ) + b3 * ( c1 * a2 - c2 * a1 ) + c3 * ( a1 * b2 - a2 * b1 ) == 0 ) NEW_LINE DEDENT
def compressString ( s , n ) : NEW_LINE INDENT freq = [ 0 ] * MAX ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 ; NEW_LINE DEDENT for i in range ( MAX ) : NEW_LINE INDENT if ( freq [ i ] == 0 ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT print ( ( chr ) ( i + ord ( ' a ' ) ) + str ( freq [ i ] ) , end = " " ) ; NEW_LINE DEDENT DEDENT
def cntWays ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT tot_sum = 0 ; sum = 0 ; ans = 0 ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT tot_sum += arr [ i ] ; NEW_LINE DEDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT sum += arr [ i ] ; NEW_LINE if ( sum == tot_sum / 2 ) : NEW_LINE INDENT ans += 1 ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT
def isPower ( x , y ) : NEW_LINE INDENT res1 = math . log ( y ) // math . log ( x ) ; NEW_LINE res2 = math . log ( y ) / math . log ( x ) ; NEW_LINE return 1 if ( res1 == res2 ) else 0 ; NEW_LINE DEDENT
def sum ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in arr : NEW_LINE INDENT sum += i NEW_LINE DEDENT sum = sum * pow ( 2 , n - 1 ) NEW_LINE return sum NEW_LINE DEDENT
def traverseMatrix ( arr , current_row , current_col ) : NEW_LINE INDENT if ( current_col >= M ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( current_row >= N ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT print ( arr [ current_row ] [ current_col ] , end = " , ▁ " ) ; NEW_LINE if ( traverseMatrix ( arr , current_row , current_col + 1 ) == 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT return traverseMatrix ( arr , current_row + 1 , 0 ) ; NEW_LINE DEDENT
def counLastDigitK ( low , high , k ) : NEW_LINE INDENT count = ( high - low ) / 10 NEW_LINE if ( high % 10 >= k ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( low % 10 > k ) : NEW_LINE INDENT count -= 1 NEW_LINE DEDENT return int ( count ) NEW_LINE DEDENT
