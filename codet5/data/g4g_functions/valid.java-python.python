def multiply ( x , y ) : NEW_LINE INDENT if ( y == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( y > 0 ) : NEW_LINE INDENT return ( x + multiply ( x , y - 1 ) ) NEW_LINE DEDENT if ( y < 0 ) : NEW_LINE INDENT return - multiply ( x , - y ) NEW_LINE DEDENT DEDENT
def largestPalinSub ( s ) : NEW_LINE INDENT res = " " NEW_LINE mx = s [ 0 ] NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT mx = max ( mx , s [ i ] ) NEW_LINE DEDENT for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT if s [ i ] == mx : NEW_LINE INDENT res += s [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def minChanges ( A , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT if ( ( i - 1 >= 0 ) and A [ i - 1 ] == 1 and A [ i + 1 ] == 1 and A [ i ] == 0 ) : NEW_LINE INDENT A [ i + 1 ] = 0 NEW_LINE cnt = cnt + 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
def printRepeating ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT index = arr [ i ] % n NEW_LINE arr [ index ] += n NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] / n ) > 1 : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def summation ( n ) : NEW_LINE INDENT return n << ( n - 1 ) ; NEW_LINE DEDENT
def nondecdigits ( n ) : NEW_LINE INDENT x = 0 NEW_LINE for x in range ( n , 0 , - 1 ) : NEW_LINE INDENT no = x NEW_LINE prev_dig = 11 NEW_LINE flag = True NEW_LINE while ( no != 0 ) : NEW_LINE INDENT if ( prev_dig < no % 10 ) : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT prev_dig = no % 10 NEW_LINE no //= 10 NEW_LINE DEDENT if ( flag == True ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return x NEW_LINE DEDENT
def findNum ( x ) : NEW_LINE INDENT for i in range ( NumUnsignBits - 1 ) : NEW_LINE INDENT if ( ( ( x >> i ) & 1 ) != ( ( x >> ( i + 1 ) ) & 1 ) ) : NEW_LINE INDENT x ^= ( 1 << i ) | ( 1 << ( i + 1 ) ) ; NEW_LINE return x ; NEW_LINE DEDENT DEDENT DEDENT
def summation ( n ) : NEW_LINE INDENT abs_sum = n * ( n + 1 ) // 2 ; NEW_LINE sign = 1 if ( ( n + 1 ) % 2 == 0 ) else - 1 ; NEW_LINE result_sum = sign * abs_sum ; NEW_LINE return result_sum ; NEW_LINE DEDENT
def cntSubSeq ( arr , n ) : NEW_LINE INDENT pos_count = 0 ; NEW_LINE neg_count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT pos_count += 1 NEW_LINE DEDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT neg_count += 1 NEW_LINE DEDENT DEDENT result = int ( math . pow ( 2 , pos_count ) ) NEW_LINE if ( neg_count > 0 ) : NEW_LINE INDENT result *= int ( math . pow ( 2 , neg_count - 1 ) ) NEW_LINE DEDENT result -= 1 NEW_LINE return result NEW_LINE DEDENT
def prCharWithFreq ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE freq = np . zeros ( 26 , dtype = np . int ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] != 0 ) : NEW_LINE INDENT print ( str [ i ] , freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] , end = " ▁ " ) NEW_LINE freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] = 0 NEW_LINE DEDENT DEDENT DEDENT
def findMinValue ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE val = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT val += ( math . log ( arr [ i ] ) ) NEW_LINE DEDENT left = arr [ 0 ] NEW_LINE right = arr [ n - 1 ] + 1 NEW_LINE while ( left <= right ) : NEW_LINE INDENT mid = ( left + right ) // 2 NEW_LINE temp = n * ( math . log ( mid ) ) NEW_LINE if ( val < temp ) : NEW_LINE INDENT ans = mid NEW_LINE right = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT left = mid + 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def findMinimumK ( a , n , s ) : NEW_LINE INDENT maximum = a [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT maximum = max ( maximum , a [ i ] ) NEW_LINE DEDENT low = 1 NEW_LINE high = maximum + 1 NEW_LINE ans = high NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += ( a [ i ] // mid ) NEW_LINE DEDENT if ( sum > s ) : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = min ( ans , mid ) NEW_LINE high = mid - 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def count ( N ) : NEW_LINE INDENT a = 0 ; NEW_LINE a = ( N * ( N + 1 ) ) / 2 ; NEW_LINE return int ( a ) ; NEW_LINE DEDENT
def countFreq ( arr , n ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] not in mp : NEW_LINE INDENT mp [ arr [ i ] ] = 0 NEW_LINE DEDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( mp [ arr [ i ] ] != - 1 ) : NEW_LINE INDENT print ( arr [ i ] , mp [ arr [ i ] ] ) NEW_LINE DEDENT mp [ arr [ i ] ] = - 1 NEW_LINE DEDENT DEDENT
def even_or_odd ( N ) : NEW_LINE INDENT l = len ( N ) ; NEW_LINE if ( N [ l - 1 ] == '0' or N [ l - 1 ] == '2' or N [ l - 1 ] == '4' or N [ l - 1 ] == '6' ) : NEW_LINE INDENT return ( " Even " ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( " Odd " ) NEW_LINE DEDENT DEDENT
def findQuadruples ( a , b , c , d , x , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT for k in range ( n ) : NEW_LINE INDENT for l in range ( n ) : NEW_LINE INDENT if ( ( a [ i ] ^ b [ j ] ^ c [ k ] ^ d [ l ] ) == x ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def find_value ( a , n , k ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT return sum % k NEW_LINE DEDENT
def section ( x1 , x2 , y1 , y2 , z1 , z2 , m , n ) : NEW_LINE INDENT x = ( ( m * x2 ) + ( n * x1 ) ) / ( m + n ) NEW_LINE y = ( ( m * y2 ) + ( n * y1 ) ) / ( m + n ) NEW_LINE z = ( ( m * z2 ) + ( n * z1 ) ) / ( m + n ) NEW_LINE print ( " ( " , x , " , " , y , " , " , z , " ) " ) NEW_LINE DEDENT
def countSub ( arr , n ) : NEW_LINE INDENT count = [ 0 for i in range ( 10 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( arr [ i ] - 1 , - 1 , - 1 ) : NEW_LINE INDENT count [ arr [ i ] ] += count [ j ] NEW_LINE DEDENT count [ arr [ i ] ] += 1 NEW_LINE DEDENT result = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT result += count [ i ] NEW_LINE DEDENT return result NEW_LINE DEDENT
def findMinRec ( A , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return A [ 0 ] NEW_LINE DEDENT return min ( A [ n - 1 ] , findMinRec ( A , n - 1 ) ) NEW_LINE DEDENT
def reverseFibonacci ( n ) : NEW_LINE INDENT a = [ 0 ] * n NEW_LINE a [ 0 ] = 0 NEW_LINE a [ 1 ] = 1 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT a [ i ] = a [ i - 2 ] + a [ i - 1 ] NEW_LINE DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def getValueOfF ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT cnt = 0 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE n /= 2 NEW_LINE DEDENT return 2 * cnt NEW_LINE DEDENT
def isSumDivides ( N ) : NEW_LINE INDENT temp = N NEW_LINE sum = 0 NEW_LINE while ( temp ) : NEW_LINE INDENT sum += temp % 10 NEW_LINE temp = int ( temp / 10 ) NEW_LINE DEDENT if ( N % sum == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT
def sumOfDigit ( n , b ) : NEW_LINE INDENT unitDigit = 0 NEW_LINE sum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT unitDigit = n % b NEW_LINE sum += unitDigit NEW_LINE n = n // b NEW_LINE DEDENT return sum NEW_LINE DEDENT
def LCIS ( arr1 , n , arr2 , m ) : NEW_LINE INDENT table = [ 0 ] * m NEW_LINE for j in range ( m ) : NEW_LINE INDENT table [ j ] = 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT current = 0 NEW_LINE for j in range ( m ) : NEW_LINE INDENT if ( arr1 [ i ] == arr2 [ j ] ) : NEW_LINE INDENT if ( current + 1 > table [ j ] ) : NEW_LINE INDENT table [ j ] = current + 1 NEW_LINE DEDENT DEDENT if ( arr1 [ i ] > arr2 [ j ] ) : NEW_LINE INDENT if ( table [ j ] > current ) : NEW_LINE INDENT current = table [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT result = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT if ( table [ i ] > result ) : NEW_LINE INDENT result = table [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def findFirstAndLast ( arr , n , x ) : NEW_LINE INDENT first = - 1 NEW_LINE last = - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( x != arr [ i ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( first == - 1 ) : NEW_LINE INDENT first = i NEW_LINE DEDENT last = i NEW_LINE DEDENT if ( first != - 1 ) : NEW_LINE INDENT print ( " First ▁ Occurrence ▁ = ▁ " , first , " ▁ \n Last ▁ Occurrence ▁ = ▁ " , last ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Found " ) NEW_LINE DEDENT DEDENT
def modularSum ( arr , n , m ) : NEW_LINE INDENT if ( n > m ) : NEW_LINE INDENT return True NEW_LINE DEDENT DP = [ False for i in range ( m ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( DP [ 0 ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT temp = [ False for i in range ( m ) ] NEW_LINE for j in range ( m ) : NEW_LINE INDENT if ( DP [ j ] == True ) : NEW_LINE INDENT if ( DP [ ( j + arr [ i ] ) % m ] == False ) : NEW_LINE INDENT temp [ ( j + arr [ i ] ) % m ] = True NEW_LINE DEDENT DEDENT DEDENT for j in range ( m ) : NEW_LINE INDENT if ( temp [ j ] ) : NEW_LINE INDENT DP [ j ] = True NEW_LINE DEDENT DEDENT DP [ arr [ i ] % m ] = True NEW_LINE DEDENT return DP [ 0 ] NEW_LINE DEDENT
def maxFreq ( s , a , b ) : NEW_LINE INDENT fre = [ 0 for i in range ( 10 ) ] NEW_LINE n = len ( s ) NEW_LINE if ( a > b ) : NEW_LINE INDENT swap ( a , b ) NEW_LINE DEDENT for i in range ( 0 , n , 1 ) : NEW_LINE INDENT a = ord ( s [ i ] ) - ord ( '0' ) NEW_LINE fre [ a ] += 1 NEW_LINE DEDENT if ( fre [ a ] == 0 and fre [ b ] == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT elif ( fre [ a ] >= fre [ b ] ) : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return b NEW_LINE DEDENT DEDENT
def vowelOrConsonant ( x ) : NEW_LINE INDENT if ( x == ' a ' or x == ' e ' or x == ' i ' or x == ' o ' or x == ' u ' or x == ' A ' or x == ' E ' or x == ' I ' or x == ' O ' or x == ' U ' ) : NEW_LINE INDENT print ( " Vowel " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Consonant " ) NEW_LINE DEDENT DEDENT
def count ( arr , N , K ) : NEW_LINE INDENT count = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] == K ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += ( count * ( count + 1 ) ) // 2 NEW_LINE count = 0 NEW_LINE DEDENT DEDENT ans = ans + ( count * ( count + 1 ) ) // 2 NEW_LINE return ans NEW_LINE DEDENT
def polyarea ( n , r ) : NEW_LINE INDENT if ( r < 0 and n < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT A = ( ( ( r * r * n ) * sin ( ( 360 / n ) * 3.14159 / 180 ) ) / 2 ) ; NEW_LINE return round ( A , 3 ) NEW_LINE DEDENT
def minCost ( str1 , K ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE res = 999999999 NEW_LINE count = 0 NEW_LINE cnt = [ 0 for i in range ( 27 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT cnt [ ord ( str1 [ i ] ) - ord ( ' a ' ) + 1 ] += 1 NEW_LINE DEDENT for i in range ( 1 , 26 - K + 1 , 1 ) : NEW_LINE INDENT a = i NEW_LINE b = i + K NEW_LINE count = 0 NEW_LINE for j in range ( 1 , 27 , 1 ) : NEW_LINE INDENT if ( cnt [ j ] > 0 ) : NEW_LINE INDENT if ( j >= a and j >= b ) : NEW_LINE INDENT count = count + ( min ( j - b , 25 - j + a + 1 ) ) * cnt [ j ] NEW_LINE DEDENT elif ( j <= a and j <= b ) : NEW_LINE INDENT count = count + ( min ( a - j , 25 + j - b + 1 ) ) * cnt [ j ] NEW_LINE DEDENT DEDENT DEDENT res = min ( res , count ) NEW_LINE DEDENT for i in range ( 26 - K + 1 , 27 , 1 ) : NEW_LINE INDENT a = i NEW_LINE b = ( i + K ) % 26 NEW_LINE count = 0 NEW_LINE for j in range ( 1 , 27 , 1 ) : NEW_LINE INDENT if ( cnt [ j ] > 0 ) : NEW_LINE INDENT if ( j >= b and j <= a ) : NEW_LINE INDENT count = count + ( min ( j - b , a - j ) ) * cnt [ j ] NEW_LINE DEDENT DEDENT DEDENT res = min ( res , count ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def Sum ( N ) : NEW_LINE INDENT SumOfPrimeDivisors = [ 0 ] * ( N + 1 ) NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT if ( SumOfPrimeDivisors [ i ] == 0 ) : NEW_LINE INDENT for j in range ( i , N + 1 , i ) : NEW_LINE INDENT SumOfPrimeDivisors [ j ] += i NEW_LINE DEDENT DEDENT DEDENT return SumOfPrimeDivisors [ N ] NEW_LINE DEDENT
def angle_triangle ( x1 , x2 , x3 , y1 , y2 , y3 , z1 , z2 , z3 ) : NEW_LINE INDENT num = ( x2 - x1 ) * ( x3 - x1 ) + ( y2 - y1 ) * ( y3 - y1 ) + ( z2 - z1 ) * ( z3 - z1 ) NEW_LINE den = math . sqrt ( ( x2 - x1 ) ** 2 + ( y2 - y1 ) ** 2 + ( z2 - z1 ) ** 2 ) * \ NEW_LINE INDENT math . sqrt ( ( x3 - x1 ) ** 2 + ( y3 - y1 ) ** 2 + ( z3 - z1 ) ** 2 ) NEW_LINE DEDENT angle = math . degrees ( math . acos ( num / den ) ) NEW_LINE return round ( angle , 3 ) NEW_LINE DEDENT
def moveSpaceInFront ( s ) : NEW_LINE INDENT i = len ( s ) - 1 ; NEW_LINE for j in range ( i , - 1 , - 1 ) : NEW_LINE INDENT if ( s [ j ] != ' ▁ ' ) : NEW_LINE INDENT s = s [ : i ] + s [ j ] + s [ i + 1 : ] NEW_LINE i -= 1 ; NEW_LINE DEDENT DEDENT while ( i >= 0 ) : NEW_LINE INDENT s = s [ : i ] + ' ▁ ' + s [ i + 1 : ] NEW_LINE i -= 1 NEW_LINE DEDENT return s ; NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return n ** 2 + 4 * n ; NEW_LINE DEDENT
def minSum ( arr , n , x ) : NEW_LINE INDENT Sum = 0 NEW_LINE largestDivisible , minimum = - 1 , arr [ 0 ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT Sum += arr [ i ] NEW_LINE if ( arr [ i ] % x == 0 and largestDivisible < arr [ i ] ) : NEW_LINE INDENT largestDivisible = arr [ i ] NEW_LINE DEDENT if arr [ i ] < minimum : NEW_LINE INDENT minimum = arr [ i ] NEW_LINE DEDENT DEDENT if largestDivisible == - 1 : NEW_LINE INDENT return Sum NEW_LINE DEDENT sumAfterOperation = ( Sum - minimum - largestDivisible + ( x * minimum ) + ( largestDivisible // x ) ) NEW_LINE return min ( Sum , sumAfterOperation ) NEW_LINE DEDENT
def result ( s , n ) : NEW_LINE INDENT st = set ( ) ; NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT ans = " " ; NEW_LINE for j in range ( i , len ( s ) ) : NEW_LINE INDENT ans += s [ j ] ; NEW_LINE if ( len ( ans ) == n ) : NEW_LINE INDENT st . add ( ans ) ; NEW_LINE break ; NEW_LINE DEDENT DEDENT DEDENT for it in st : NEW_LINE INDENT print ( it , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT
def difference ( M , N ) : NEW_LINE INDENT return M + N NEW_LINE DEDENT
def checkPair ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT if sum % 2 != 0 : NEW_LINE INDENT return False NEW_LINE DEDENT sum = sum / 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT val = sum - arr [ i ] NEW_LINE if arr [ i ] not in s : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE DEDENT if val in s : NEW_LINE INDENT print ( " Pair ▁ elements ▁ are " , arr [ i ] , " and " , int ( val ) ) NEW_LINE DEDENT DEDENT DEDENT
def check ( st ) : NEW_LINE INDENT n = len ( st ) NEW_LINE if ( ( ( int ) ( st [ n - 1 ] ) % 2 ) != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT digitSum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT digitSum = digitSum + ( int ) ( st [ i ] ) NEW_LINE DEDENT return ( digitSum % 3 == 0 ) NEW_LINE DEDENT
def maxProduct ( arr , n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT print ( " No ▁ pairs ▁ exists " ) NEW_LINE return NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT print ( arr [ 0 ] , " ▁ " , arr [ 1 ] ) NEW_LINE return NEW_LINE DEDENT posa = 0 NEW_LINE posb = 0 NEW_LINE nega = 0 NEW_LINE negb = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > posa ) : NEW_LINE INDENT posb = posa NEW_LINE posa = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > posb ) : NEW_LINE INDENT posb = arr [ i ] NEW_LINE DEDENT if ( arr [ i ] < 0 and abs ( arr [ i ] ) > abs ( nega ) ) : NEW_LINE INDENT negb = nega NEW_LINE nega = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] < 0 and abs ( arr [ i ] ) > abs ( negb ) ) : NEW_LINE INDENT negb = arr [ i ] NEW_LINE DEDENT DEDENT if ( nega * negb > posa * posb ) : NEW_LINE INDENT print ( " Max ▁ product ▁ pair ▁ is ▁ { " , nega , " , ▁ " , negb , " } " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Max ▁ product ▁ pair ▁ is ▁ { " , posa , " , ▁ " , posb , " } " ) NEW_LINE DEDENT DEDENT
def FindPoints ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) : NEW_LINE INDENT x5 = max ( x1 , x3 ) NEW_LINE y5 = max ( y1 , y3 ) NEW_LINE x6 = min ( x2 , x4 ) NEW_LINE y6 = min ( y2 , y4 ) NEW_LINE if ( x5 > x6 or y5 > y6 ) : NEW_LINE INDENT print ( " No ▁ intersection " ) NEW_LINE return NEW_LINE DEDENT print ( " ( " , x5 , " , ▁ " , y5 , " ) ▁ " , end = " ▁ " ) NEW_LINE print ( " ( " , x6 , " , ▁ " , y6 , " ) ▁ " , end = " ▁ " ) NEW_LINE x7 = x5 NEW_LINE y7 = y6 NEW_LINE print ( " ( " , x7 , " , ▁ " , y7 , " ) ▁ " , end = " ▁ " ) NEW_LINE x8 = x6 NEW_LINE y8 = y5 NEW_LINE print ( " ( " , x8 , " , ▁ " , y8 , " ) ▁ " ) NEW_LINE DEDENT
def maxSubArraySum ( a , size ) : NEW_LINE INDENT max_so_far = - maxint - 1 NEW_LINE max_ending_here = 0 NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT max_ending_here = max_ending_here + a [ i ] NEW_LINE if ( max_so_far < max_ending_here ) : NEW_LINE INDENT max_so_far = max_ending_here NEW_LINE DEDENT if max_ending_here < 0 : NEW_LINE INDENT max_ending_here = 0 NEW_LINE DEDENT DEDENT return max_so_far NEW_LINE DEDENT
def moduloMultiplication ( a , b , mod ) : NEW_LINE INDENT res = 0 ; NEW_LINE a = a % mod ; NEW_LINE while ( b ) : NEW_LINE INDENT if ( b & 1 ) : NEW_LINE INDENT res = ( res + a ) % mod ; NEW_LINE DEDENT a = ( 2 * a ) % mod ; NEW_LINE b >>= 1 ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT
def shortestSeq ( S : list , T : list ) : NEW_LINE INDENT m = len ( S ) NEW_LINE n = len ( T ) NEW_LINE dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( m + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT dp [ 0 ] [ i ] = MAX NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT ch = S [ i - 1 ] NEW_LINE k = j - 1 NEW_LINE while k >= 0 : NEW_LINE INDENT if T [ k ] == ch : NEW_LINE INDENT break NEW_LINE DEDENT k -= 1 NEW_LINE DEDENT if k == - 1 : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ k ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT ans = dp [ m ] [ n ] NEW_LINE if ans >= MAX : NEW_LINE INDENT ans = - 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def isPerfectSquare ( x ) : NEW_LINE INDENT sr = int ( sqrt ( x ) ) ; NEW_LINE if ( sr * sr == x ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT DEDENT
def smallestPoss ( s , n ) : NEW_LINE INDENT ans = " " ; NEW_LINE arr = [ 0 ] * 10 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ ord ( s [ i ] ) - 48 ] += 1 ; NEW_LINE DEDENT for i in range ( 10 ) : NEW_LINE INDENT for j in range ( arr [ i ] ) : NEW_LINE INDENT ans = ans + str ( i ) ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT
def encodedChar ( string , k ) : NEW_LINE INDENT n = len ( string ) NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT j = i NEW_LINE length = 0 NEW_LINE freq = 0 NEW_LINE while j < n and string [ j ] . isalpha ( ) : NEW_LINE INDENT j += 1 NEW_LINE length += 1 NEW_LINE DEDENT while j < n and string [ j ] . isdigit ( ) : NEW_LINE INDENT freq = freq * 10 + int ( string [ j ] ) NEW_LINE j += 1 NEW_LINE DEDENT num = freq * length NEW_LINE if k > num : NEW_LINE INDENT k -= num NEW_LINE i = j NEW_LINE DEDENT else : NEW_LINE INDENT k -= 1 NEW_LINE k %= length NEW_LINE return string [ i + k ] NEW_LINE DEDENT DEDENT return string [ k - 1 ] NEW_LINE DEDENT
def printAsMaximalPrimeSum ( n ) : NEW_LINE INDENT if ( n % 2 == 1 ) : NEW_LINE INDENT print ( "3 ▁ " , end = " " ) NEW_LINE n -= 3 NEW_LINE DEDENT while ( n > 0 ) : NEW_LINE INDENT print ( "2 ▁ " , end = " " ) NEW_LINE n -= 2 NEW_LINE DEDENT DEDENT
def longestSubarray ( a , n , x ) : NEW_LINE INDENT count = 0 NEW_LINE length = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] > x ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT length = max ( length , count ) NEW_LINE count = 0 NEW_LINE DEDENT DEDENT if ( count > 0 ) : NEW_LINE INDENT length = max ( length , count ) NEW_LINE DEDENT return length NEW_LINE DEDENT
def K_multiple ( a , n , k ) : NEW_LINE INDENT a . sort ( ) ; NEW_LINE s = set ( ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( a [ i ] % k == 0 and a [ i ] // k not in s ) or a [ i ] % k != 0 ) : NEW_LINE INDENT s . add ( a [ i ] ) ; NEW_LINE DEDENT DEDENT for i in s : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def bin ( n ) : NEW_LINE INDENT if ( n > 1 ) : NEW_LINE INDENT bin ( n >> 1 ) NEW_LINE DEDENT print ( n & 1 , end = " " ) NEW_LINE DEDENT
def maxOfSegmentMins ( a , n , k ) : NEW_LINE INDENT if k == 1 : NEW_LINE INDENT return min ( a ) NEW_LINE DEDENT if k == 2 : NEW_LINE INDENT return max ( a [ 0 ] , a [ n - 1 ] ) NEW_LINE DEDENT return max ( a ) NEW_LINE DEDENT
def Max_Xor ( arr , i , j , mask , n ) : NEW_LINE INDENT if ( i >= n ) : NEW_LINE INDENT if ( j == 0 ) : NEW_LINE INDENT return mask NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if ( dp [ i ] [ j ] [ mask ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] [ mask ] NEW_LINE DEDENT ans = 0 NEW_LINE if ( j > 0 ) : NEW_LINE INDENT ans = Max_Xor ( arr , i + 1 , j - 1 , mask ^ arr [ i ] , n ) NEW_LINE DEDENT ans = max ( ans , Max_Xor ( arr , i + 1 , j , mask , n ) ) NEW_LINE dp [ i ] [ j ] [ mask ] = ans NEW_LINE return ans NEW_LINE DEDENT
def generateArr ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT print ( arr [ 0 ] ) ; NEW_LINE return ; NEW_LINE DEDENT barr = [ 0 ] * n ; NEW_LINE barr [ 0 ] = arr [ 0 ] & arr [ 1 ] ; NEW_LINE barr [ n - 1 ] = arr [ n - 1 ] & arr [ n - 2 ] ; NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT barr [ i ] = arr [ i - 1 ] & arr [ i + 1 ] ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( barr [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT
def anagram_pairs ( s , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp_str = " " . join ( sorted ( s [ i ] ) ) NEW_LINE if temp_str in mp : NEW_LINE INDENT mp [ temp_str ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ temp_str ] = 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for k in mp . values ( ) : NEW_LINE INDENT ans += ( k * ( k - 1 ) ) // 2 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def evenDecimalValue ( str , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT decimalValue = 0 ; NEW_LINE powerOf2 = 1 ; NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT decimalValue += ( ( int ( str [ k ] ) - 0 ) * powerOf2 ) NEW_LINE powerOf2 *= 2 NEW_LINE DEDENT if ( decimalValue % 2 == 0 ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def findDigits ( n , b ) : NEW_LINE INDENT if ( n < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT M_PI = 3.141592 NEW_LINE M_E = 2.7182 NEW_LINE if ( n <= 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT x = ( ( n * log10 ( n / M_E ) + log10 ( 2 * M_PI * n ) / 2.0 ) ) / ( log10 ( b ) ) NEW_LINE return floor ( x ) + 1 NEW_LINE DEDENT
def areacircumscribed ( a ) : NEW_LINE INDENT return ( a * a * ( PI / 2 ) ) NEW_LINE DEDENT
def mostCommon ( lower , higher ) : NEW_LINE INDENT if ( lower == higher ) : NEW_LINE INDENT return lower NEW_LINE DEDENT else : NEW_LINE INDENT return 2 NEW_LINE DEDENT DEDENT
def check_elements ( arr , n , A , B ) : NEW_LINE INDENT rangeV = B - A NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( abs ( arr [ i ] ) >= A and abs ( arr [ i ] ) <= B ) : NEW_LINE INDENT z = abs ( arr [ i ] ) - A NEW_LINE if ( arr [ z ] > 0 ) : NEW_LINE INDENT arr [ z ] = arr [ z ] * - 1 NEW_LINE DEDENT DEDENT DEDENT count = 0 NEW_LINE for i in range ( 0 , rangeV + 1 ) : NEW_LINE INDENT if i >= n : NEW_LINE INDENT break NEW_LINE DEDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT if ( count != ( rangeV + 1 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT
def decToOctal ( n ) : NEW_LINE INDENT octalNum = [ 0 ] * 100 ; NEW_LINE i = 0 ; NEW_LINE while ( n != 0 ) : NEW_LINE INDENT octalNum [ i ] = n % 8 ; NEW_LINE n = int ( n / 8 ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( octalNum [ j ] , end = " " ) ; NEW_LINE DEDENT DEDENT
def numOfIncSubseqOfSizeK ( arr , n , k ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n ) ] for i in range ( k ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp [ 0 ] [ i ] = 1 NEW_LINE DEDENT for l in range ( 1 , k ) : NEW_LINE INDENT for i in range ( l , n ) : NEW_LINE INDENT dp [ l ] [ i ] = 0 NEW_LINE for j in range ( l - 1 , i ) : NEW_LINE INDENT if ( arr [ j ] < arr [ i ] ) : NEW_LINE INDENT dp [ l ] [ i ] += dp [ l - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT Sum = 0 NEW_LINE for i in range ( k - 1 , n ) : NEW_LINE INDENT Sum += dp [ k - 1 ] [ i ] NEW_LINE DEDENT return Sum NEW_LINE DEDENT
def calculateSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE sum = 1 << n ; NEW_LINE return ( sum - 1 ) NEW_LINE DEDENT
def Min_Replace ( arr , n , k ) : NEW_LINE INDENT arr . sort ( reverse = False ) NEW_LINE freq = [ 0 for i in range ( MAX ) ] NEW_LINE p = 0 NEW_LINE freq [ p ] = 1 NEW_LINE for i in range ( 1 , n , 1 ) : NEW_LINE INDENT if ( arr [ i ] == arr [ i - 1 ] ) : NEW_LINE INDENT freq [ p ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT p += 1 NEW_LINE freq [ p ] += 1 NEW_LINE DEDENT DEDENT freq . sort ( reverse = True ) NEW_LINE ans = 0 NEW_LINE for i in range ( k , p + 1 , 1 ) : NEW_LINE INDENT ans += freq [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT
def isPermutedMatrix ( mat , n ) : NEW_LINE INDENT str_cat = " " NEW_LINE for i in range ( n ) : NEW_LINE INDENT str_cat = str_cat + " - " + str ( mat [ 0 ] [ i ] ) NEW_LINE DEDENT str_cat = str_cat + str_cat NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT curr_str = " " NEW_LINE for j in range ( n ) : NEW_LINE INDENT curr_str = curr_str + " - " + str ( mat [ i ] [ j ] ) NEW_LINE DEDENT if ( str_cat . find ( curr_str ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def slopeOfNum ( num , n ) : NEW_LINE INDENT slope = 0 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( num [ i ] > num [ i - 1 ] and num [ i ] > num [ i + 1 ] ) : NEW_LINE INDENT slope += 1 NEW_LINE DEDENT elif ( num [ i ] < num [ i - 1 ] and num [ i ] < num [ i + 1 ] ) : NEW_LINE INDENT slope += 1 NEW_LINE DEDENT DEDENT return slope NEW_LINE DEDENT
def maxSubArraySumRepeated ( a , n , k ) : NEW_LINE INDENT max_so_far = - 2147483648 NEW_LINE max_ending_here = 0 NEW_LINE for i in range ( n * k ) : NEW_LINE INDENT max_ending_here = max_ending_here + a [ i % n ] NEW_LINE if ( max_so_far < max_ending_here ) : NEW_LINE INDENT max_so_far = max_ending_here NEW_LINE DEDENT if ( max_ending_here < 0 ) : NEW_LINE INDENT max_ending_here = 0 NEW_LINE DEDENT DEDENT return max_so_far NEW_LINE DEDENT
def isDvisibleBy12 ( num ) : NEW_LINE INDENT if ( len ( num ) >= 3 ) : NEW_LINE INDENT d1 = int ( num [ len ( num ) - 1 ] ) ; NEW_LINE if ( d1 % 2 != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT d2 = int ( num [ len ( num ) - 2 ] ) NEW_LINE sum = 0 NEW_LINE for i in range ( 0 , len ( num ) ) : NEW_LINE INDENT sum += int ( num [ i ] ) NEW_LINE DEDENT return ( sum % 3 == 0 and ( d2 * 10 + d1 ) % 4 == 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT number = int ( num ) NEW_LINE return ( number % 12 == 0 ) NEW_LINE DEDENT DEDENT
def countMaxSetBits ( left , right ) : NEW_LINE INDENT max_count = - 1 NEW_LINE for i in range ( left , right + 1 ) : NEW_LINE INDENT temp = i NEW_LINE cnt = 0 NEW_LINE while temp : NEW_LINE INDENT if temp & 1 : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT temp = temp >> 1 NEW_LINE DEDENT if cnt > max_count : NEW_LINE INDENT max_count = cnt NEW_LINE num = i NEW_LINE DEDENT DEDENT return num NEW_LINE DEDENT
def findEncryptedArray ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( sum - arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def givesum ( A , n ) : NEW_LINE INDENT max_element = max ( A ) NEW_LINE maxBit = int ( log2 ( max_element ) ) + 1 NEW_LINE totalSubarrays = n * ( n + 1 ) // 2 NEW_LINE s = 0 NEW_LINE for i in range ( maxBit ) : NEW_LINE INDENT c1 = 0 NEW_LINE vec = [ ] NEW_LINE sum = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT a = A [ j ] >> i NEW_LINE if ( not ( a & 1 ) ) : NEW_LINE INDENT vec . append ( j ) NEW_LINE DEDENT DEDENT cntSubarrNotSet = 0 NEW_LINE cnt = 1 NEW_LINE for j in range ( 1 , len ( vec ) ) : NEW_LINE INDENT if ( vec [ j ] - vec [ j - 1 ] == 1 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cntSubarrNotSet += cnt * ( cnt + 1 ) // 2 NEW_LINE cnt = 1 NEW_LINE DEDENT DEDENT cntSubarrNotSet += cnt * ( cnt + 1 ) // 2 NEW_LINE if len ( vec ) == 0 : NEW_LINE INDENT cntSubarrNotSet = 0 NEW_LINE DEDENT cntSubarrIthSet = totalSubarrays - cntSubarrNotSet NEW_LINE s += cntSubarrIthSet * pow ( 2 , i ) NEW_LINE DEDENT return s NEW_LINE DEDENT
def sub_arrays ( a , n , k ) : NEW_LINE INDENT sum = [ 0 for i in range ( n + 2 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ i ] -= 1 NEW_LINE a [ i ] %= k NEW_LINE sum [ i + 1 ] += sum [ i ] + a [ i ] NEW_LINE sum [ i + 1 ] %= k NEW_LINE DEDENT ans = 0 NEW_LINE l = 0 NEW_LINE r = 0 NEW_LINE mp = dict ( ) NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT if sum [ i ] in mp : NEW_LINE INDENT ans += mp [ sum [ i ] ] NEW_LINE DEDENT mp [ sum [ i ] ] = mp . get ( sum [ i ] , 0 ) + 1 NEW_LINE r += 1 NEW_LINE if ( r - l >= k ) : NEW_LINE INDENT mp [ sum [ l ] ] -= 1 NEW_LINE l += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def nthTerm ( N ) : NEW_LINE INDENT nth = 0 ; first_term = 12 ; NEW_LINE nth = ( first_term * ( pow ( 2 , N - 1 ) ) ) +   \ NEW_LINE INDENT 11 * ( ( pow ( 2 , N - 1 ) ) - 1 ) ; NEW_LINE DEDENT return nth ; NEW_LINE DEDENT
def countSubArrays ( arr , n , x ) : NEW_LINE INDENT len = 0 NEW_LINE count = 0 NEW_LINE binaryArr = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( arr [ i ] <= x ) : NEW_LINE INDENT binaryArr [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT binaryArr [ i ] = 0 NEW_LINE DEDENT DEDENT for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( binaryArr [ i ] == 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n , 1 ) : NEW_LINE INDENT if ( binaryArr [ j ] != 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT len = j - i NEW_LINE count += ( len ) * ( int ) ( ( len + 1 ) / 2 ) NEW_LINE i = j NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def countPairs ( arr , n ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] * arr [ j ] == arr [ i ] + arr [ j ] ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT DEDENT return count ; NEW_LINE DEDENT
def numberOfMen ( D , m , d ) : NEW_LINE INDENT Men = ( m * ( D - d ) ) / d ; NEW_LINE return int ( Men ) ; NEW_LINE DEDENT
def longestAlternatingSubarray ( a , n ) : NEW_LINE INDENT longest = 1 NEW_LINE cnt = 1 NEW_LINE i = 1 NEW_LINE while i < n : NEW_LINE INDENT if ( a [ i ] * a [ i - 1 ] < 0 ) : NEW_LINE INDENT cnt = cnt + 1 NEW_LINE longest = max ( longest , cnt ) NEW_LINE DEDENT else : NEW_LINE INDENT cnt = 1 NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT return longest NEW_LINE DEDENT
def countMountains ( a , n ) : NEW_LINE INDENT A = [ [ 0 for i in range ( n + 2 ) ] for i in range ( n + 2 ) ] NEW_LINE count = 0 NEW_LINE for i in range ( n + 2 ) : NEW_LINE INDENT for j in range ( n + 2 ) : NEW_LINE INDENT if ( ( i == 0 ) or ( j == 0 ) or ( i == n + 1 ) or ( j == n + 1 ) ) : NEW_LINE INDENT A [ i ] [ j ] = float ( ' - inf ' ) NEW_LINE DEDENT else : NEW_LINE INDENT A [ i ] [ j ] = a [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if ( ( A [ i ] [ j ] > A [ i - 1 ] [ j ] ) and ( A [ i ] [ j ] > A [ i + 1 ] [ j ] ) and ( A [ i ] [ j ] > A [ i ] [ j - 1 ] ) and ( A [ i ] [ j ] > A [ i ] [ j + 1 ] ) and ( A [ i ] [ j ] > A [ i - 1 ] [ j - 1 ] ) and ( A [ i ] [ j ] > A [ i + 1 ] [ j + 1 ] ) and ( A [ i ] [ j ] > A [ i - 1 ] [ j + 1 ] ) and ( A [ i ] [ j ] > A [ i + 1 ] [ j - 1 ] ) ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def distance ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT return math . sqrt ( math . pow ( x2 - x1 , 2 ) + math . pow ( y2 - y1 , 2 ) * 1.0 ) NEW_LINE DEDENT
def partitions ( n ) : NEW_LINE INDENT p = [ 0 ] * ( n + 1 ) NEW_LINE p [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT k = 1 NEW_LINE while ( ( k * ( 3 * k - 1 ) ) / 2 <= i ) : NEW_LINE INDENT p [ i ] += ( ( 1 if k % 2 else - 1 ) * p [ i - ( k * ( 3 * k - 1 ) ) // 2 ] ) NEW_LINE if ( k > 0 ) : NEW_LINE INDENT k *= - 1 NEW_LINE DEDENT else : NEW_LINE INDENT k = 1 - k NEW_LINE DEDENT DEDENT DEDENT return p [ n ] NEW_LINE DEDENT
def pattern ( n ) : NEW_LINE INDENT k = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( n - 1 , k , - 1 ) : NEW_LINE INDENT print ( ' ▁ ' , end = ' ' ) NEW_LINE DEDENT print ( chr ( i + 65 ) , end = ' ' ) NEW_LINE for j in range ( 1 , k * 2 ) : NEW_LINE INDENT print ( ' ▁ ' , end = ' ' ) NEW_LINE DEDENT if i < n - 1 : NEW_LINE INDENT print ( chr ( i + 65 ) , end = ' ' ) NEW_LINE DEDENT print ( ) NEW_LINE k += 1 NEW_LINE DEDENT DEDENT
def printPattern ( n ) : NEW_LINE INDENT line_no = 1 NEW_LINE curr_star = 0 NEW_LINE line_no = 1 NEW_LINE while ( line_no <= n ) : NEW_LINE INDENT if ( curr_star < line_no ) : NEW_LINE INDENT print ( " * ▁ " , end = " " ) NEW_LINE curr_star += 1 NEW_LINE continue NEW_LINE DEDENT if ( curr_star == line_no ) : NEW_LINE INDENT print ( " " ) NEW_LINE line_no += 1 NEW_LINE curr_star = 0 NEW_LINE DEDENT DEDENT DEDENT
def increaseInVol ( l , b , h ) : NEW_LINE INDENT percentInc = ( ( 1 + ( l / 100 ) ) * ( 1 + ( b / 100 ) ) * ( 1 + ( h / 100 ) ) ) NEW_LINE percentInc -= 1 NEW_LINE percentInc *= 100 NEW_LINE return percentInc NEW_LINE DEDENT
def count_numbers ( k , n , flag ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT if ( flag ) : NEW_LINE INDENT return ( k - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT if ( flag ) : NEW_LINE INDENT return ( k - 1 ) * ( count_numbers ( k , n - 1 , 0 ) + count_numbers ( k , n - 1 , 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return count_numbers ( k , n - 1 , 1 ) NEW_LINE DEDENT DEDENT
def findSubarray ( array , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE mp [ 0 ] = 1 NEW_LINE answer = 0 NEW_LINE preXor = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT value = 1 NEW_LINE preXor ^= array [ i ] NEW_LINE for j in range ( 1 , MAX + 1 ) : NEW_LINE INDENT Y = value ^ preXor NEW_LINE if ( Y in mp . keys ( ) ) : NEW_LINE INDENT answer += mp [ Y ] NEW_LINE DEDENT value *= 2 NEW_LINE DEDENT if ( preXor in mp . keys ( ) ) : NEW_LINE INDENT mp [ preXor ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ preXor ] = 1 NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT
def stepRequired ( n ) : NEW_LINE INDENT return bin ( 94 ) . count ( '1' ) NEW_LINE DEDENT
def magicIndex ( arr , start , end ) : NEW_LINE INDENT if ( start > end ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT midIndex = int ( ( start + end ) / 2 ) NEW_LINE midValue = arr [ midIndex ] NEW_LINE if ( midIndex == midValue ) : NEW_LINE INDENT return midIndex NEW_LINE DEDENT left = magicIndex ( arr , start , min ( midValue , midIndex - 1 ) ) NEW_LINE if ( left >= 0 ) : NEW_LINE INDENT return left NEW_LINE DEDENT return magicIndex ( arr , max ( midValue , midIndex + 1 ) , end ) NEW_LINE DEDENT
def Circumference ( l , w ) : NEW_LINE INDENT return ( 2 * ( l + w ) ) NEW_LINE DEDENT
def findFoot ( a , b , c , x1 , y1 ) : NEW_LINE INDENT temp = ( - 1 * ( a * x1 + b * y1 + c ) // ( a * a + b * b ) ) NEW_LINE x = temp * a + x1 NEW_LINE y = temp * b + y1 NEW_LINE return ( x , y ) NEW_LINE DEDENT
def maxPartition ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE P = 0 NEW_LINE current = " " NEW_LINE previous = " " NEW_LINE for i in range ( n ) : NEW_LINE INDENT current += s [ i ] NEW_LINE if ( current != previous ) : NEW_LINE INDENT previous = current NEW_LINE current = " " NEW_LINE P += 1 NEW_LINE DEDENT DEDENT return P NEW_LINE DEDENT
def findCnt ( arr , n , k ) : NEW_LINE INDENT ret = 0 ; NEW_LINE i = 0 ; NEW_LINE while ( i < n ) : NEW_LINE INDENT j = i + 1 ; NEW_LINE while ( j < n and arr [ j ] >= arr [ j - 1 ] ) : NEW_LINE INDENT j += 1 ; NEW_LINE DEDENT x = max ( 0 , j - i - k ) ; NEW_LINE ret += ( ( j - i ) * ( j - i + 1 ) ) // 2 -   \ NEW_LINE INDENT ( x * ( x + 1 ) ) / 2 ; NEW_LINE DEDENT i = j ; NEW_LINE DEDENT return ret ; NEW_LINE DEDENT
def isDivBy9 ( n ) : NEW_LINE INDENT if ( n == 0 or n == 9 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n < 9 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return isDivBy9 ( ( int ) ( n >> 3 ) - ( int ) ( n & 7 ) ) NEW_LINE DEDENT
def print_first_N_primes ( N ) : NEW_LINE INDENT i , j , flag = 0 , 0 , 0 ; NEW_LINE print ( " Prime ▁ numbers ▁ between ▁ 1 ▁ and ▁ " , N , " ▁ are : " ) ; NEW_LINE for i in range ( 1 , N + 1 , 1 ) : NEW_LINE INDENT if ( i == 1 or i == 0 ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT flag = 1 ; NEW_LINE for j in range ( 2 , ( ( i // 2 ) + 1 ) , 1 ) : NEW_LINE INDENT if ( i % j == 0 ) : NEW_LINE INDENT flag = 0 ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( flag == 1 ) : NEW_LINE INDENT print ( i , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT DEDENT
def solve ( s , k ) : NEW_LINE INDENT count , length , pos = 0 , 0 , 0 NEW_LINE m = dict . fromkeys ( s , 0 ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT m [ s [ i ] ] += 1 NEW_LINE length += 1 NEW_LINE if length > k : NEW_LINE INDENT m [ s [ pos ] ] -= 1 NEW_LINE pos += 1 NEW_LINE length -= 1 NEW_LINE DEDENT if length == k and m [ s [ i ] ] == length : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT
def NumberofTimes ( s ) : NEW_LINE INDENT temporary_sum = 0 NEW_LINE count = 0 NEW_LINE while ( len ( s ) > 1 ) : NEW_LINE INDENT temporary_sum = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT temporary_sum += ( ord ( s [ i ] ) - ord ( '0' ) ) NEW_LINE DEDENT s = str ( temporary_sum ) NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def distinctSubstring ( P , Q , K , N ) : NEW_LINE INDENT S = set ( ) NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT sum = 0 ; NEW_LINE s = ' ' NEW_LINE for j in range ( i , N ) : NEW_LINE INDENT pos = ord ( P [ j ] ) - 97 NEW_LINE sum = sum + ord ( Q [ pos ] ) - 48 NEW_LINE s += P [ j ] NEW_LINE if ( sum <= K ) : NEW_LINE INDENT S . add ( s ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return len ( S ) NEW_LINE DEDENT
def minCost ( arr , cost , n ) : NEW_LINE INDENT costThree = 10 ** 9 NEW_LINE for j in range ( n ) : NEW_LINE INDENT costI = 10 ** 9 NEW_LINE costK = 10 ** 9 NEW_LINE for i in range ( j ) : NEW_LINE INDENT if ( arr [ i ] < arr [ j ] ) : NEW_LINE INDENT costI = min ( costI , cost [ i ] ) NEW_LINE DEDENT DEDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if ( arr [ k ] > arr [ j ] ) : NEW_LINE INDENT costK = min ( costK , cost [ k ] ) NEW_LINE DEDENT DEDENT if ( costI != 10 ** 9 and costK != 10 ** 9 ) : NEW_LINE INDENT costThree = min ( costThree , cost [ j ] + costI + costK ) NEW_LINE DEDENT DEDENT if ( costThree == 10 ** 9 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return costThree NEW_LINE DEDENT
def submatrixXor ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT top_left = ( i + 1 ) * ( j + 1 ) NEW_LINE bottom_right = ( n - i ) * ( n - j ) NEW_LINE if ( top_left % 2 == 1 and bottom_right % 2 == 1 ) : NEW_LINE INDENT ans = ( ans ^ arr [ i ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def term ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans = ans + i NEW_LINE DEDENT return ans NEW_LINE DEDENT
def manipulated_seive ( N ) : NEW_LINE INDENT isprime [ 0 ] = isprime [ 1 ] = False NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT if isprime [ i ] == True : NEW_LINE INDENT prime . append ( i ) NEW_LINE SPF [ i ] = i NEW_LINE DEDENT j = 0 NEW_LINE while ( j < len ( prime ) and i * prime [ j ] < N and prime [ j ] <= SPF [ i ] ) : NEW_LINE INDENT isprime [ i * prime [ j ] ] = False NEW_LINE SPF [ i * prime [ j ] ] = prime [ j ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT DEDENT
def countWays ( index , cnt , dp , n , m , k ) : NEW_LINE INDENT if ( index == n ) : NEW_LINE INDENT if ( cnt == k ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if ( dp [ index ] [ cnt ] != - 1 ) : NEW_LINE INDENT return dp [ index ] [ cnt ] NEW_LINE DEDENT ans = 0 NEW_LINE ans += countWays ( index + 1 , cnt , dp , n , m , k ) NEW_LINE ans += ( m - 1 ) * countWays ( index + 1 , cnt + 1 , dp , n , m , k ) NEW_LINE dp [ index ] [ cnt ] = ans NEW_LINE return dp [ index ] [ cnt ] NEW_LINE DEDENT
def getCount ( a , b , c ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , 82 ) : NEW_LINE INDENT cr = b * pow ( i , a ) + c NEW_LINE tmp = cr NEW_LINE sm = 0 NEW_LINE while ( tmp ) : NEW_LINE INDENT sm += tmp % 10 NEW_LINE tmp //= 10 NEW_LINE DEDENT if ( sm == i and cr < 10 ** 9 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def thirdLargest ( arr , arr_size ) : NEW_LINE INDENT if ( arr_size < 3 ) : NEW_LINE INDENT print ( " ▁ Invalid ▁ Input ▁ " ) NEW_LINE return NEW_LINE DEDENT first = arr [ 0 ] NEW_LINE second = - sys . maxsize NEW_LINE third = - sys . maxsize NEW_LINE for i in range ( 1 , arr_size ) : NEW_LINE INDENT if ( arr [ i ] > first ) : NEW_LINE INDENT third = second NEW_LINE second = first NEW_LINE first = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > second ) : NEW_LINE INDENT third = second NEW_LINE second = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > third ) : NEW_LINE INDENT third = arr [ i ] NEW_LINE DEDENT DEDENT print ( " The ▁ third ▁ Largest " , " element ▁ is " , third ) NEW_LINE DEDENT
def rotateRec ( n , L , B ) : NEW_LINE INDENT m = sys . maxsize ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( max ( L [ i ] , B [ i ] ) <= m ) : NEW_LINE INDENT m = max ( L [ i ] , B [ i ] ) ; NEW_LINE DEDENT elif ( min ( L [ i ] , B [ i ] ) <= m ) : NEW_LINE INDENT m = min ( L [ i ] , B [ i ] ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT return 1 ; NEW_LINE DEDENT
def count ( arr , low , high , x ) : NEW_LINE INDENT if ( ( low > high ) or ( low == high and arr [ low ] != x ) ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( low == high and arr [ low ] == x ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT return count ( arr , low , ( low + high ) // 2 , x ) + \ NEW_LINE count ( arr , 1 + ( low + high ) // 2 , high , x ) ; NEW_LINE DEDENT
def getTotalXorOfSubarrayXors ( arr , N ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( i , N ) : NEW_LINE INDENT for k in range ( i , j + 1 ) : NEW_LINE INDENT res = res ^ arr [ k ] NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
def removeSpecialCharacter ( s ) : NEW_LINE INDENT i = 0 NEW_LINE while i < len ( s ) : NEW_LINE INDENT if ( ord ( s [ i ] ) < ord ( ' A ' ) or ord ( s [ i ] ) > ord ( ' Z ' ) and ord ( s [ i ] ) < ord ( ' a ' ) or ord ( s [ i ] ) > ord ( ' z ' ) ) : NEW_LINE INDENT del s [ i ] NEW_LINE i -= 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print ( " " . join ( s ) ) NEW_LINE DEDENT
def countPairs ( arr , n ) : NEW_LINE INDENT size = ( 2 * N ) + 1 NEW_LINE freq = [ 0 for i in range ( size ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = arr [ i ] NEW_LINE freq [ x + N ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( size ) : NEW_LINE INDENT if ( freq [ i ] > 0 ) : NEW_LINE INDENT ans += int ( ( ( freq [ i ] ) * ( freq [ i ] - 1 ) ) / 2 ) NEW_LINE for j in range ( i + 2 , 2001 , 2 ) : NEW_LINE INDENT if ( freq [ j ] > 0 and ( freq [ int ( ( i + j ) / 2 ) ] > 0 ) ) : NEW_LINE INDENT ans += ( freq [ i ] * freq [ j ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def getHCF ( x , y ) : NEW_LINE INDENT minimum = min ( x , y ) NEW_LINE if ( x % minimum == 0 and y % minimum == 0 ) : NEW_LINE INDENT return minimum NEW_LINE DEDENT for i in range ( minimum // 2 , 1 , - 1 ) : NEW_LINE INDENT if ( x % i == 0 and y % i == 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT
def Cholesky_Decomposition ( matrix , n ) : NEW_LINE INDENT lower = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ] ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 ) : NEW_LINE INDENT sum1 = 0 ; NEW_LINE if ( j == i ) : NEW_LINE INDENT for k in range ( j ) : NEW_LINE INDENT sum1 += pow ( lower [ j ] [ k ] , 2 ) ; NEW_LINE DEDENT lower [ j ] [ j ] = int ( math . sqrt ( matrix [ j ] [ j ] - sum1 ) ) ; NEW_LINE DEDENT else : NEW_LINE INDENT for k in range ( j ) : NEW_LINE INDENT sum1 += ( lower [ i ] [ k ] * lower [ j ] [ k ] ) ; NEW_LINE DEDENT if ( lower [ j ] [ j ] > 0 ) : NEW_LINE INDENT lower [ i ] [ j ] = int ( ( matrix [ i ] [ j ] - sum1 ) / lower [ j ] [ j ] ) ; NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( " Lower ▁ Triangular\t\tTranspose " ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( lower [ i ] [ j ] , end = " \t " ) ; NEW_LINE DEDENT print ( " " , end = " \t " ) ; NEW_LINE for j in range ( n ) : NEW_LINE INDENT print ( lower [ j ] [ i ] , end = " \t " ) ; NEW_LINE DEDENT print ( " " ) ; NEW_LINE DEDENT DEDENT
def max_xor ( arr , n ) : NEW_LINE INDENT maxXor = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT maxXor = max ( maxXor , \ arr [ i ] ^ arr [ j ] ) ; NEW_LINE DEDENT DEDENT return maxXor ; NEW_LINE DEDENT
def kth ( arr1 , arr2 , m , n , k ) : NEW_LINE INDENT sorted1 = [ 0 ] * ( m + n ) NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE d = 0 NEW_LINE while ( i < m and j < n ) : NEW_LINE INDENT if ( arr1 [ i ] < arr2 [ j ] ) : NEW_LINE INDENT sorted1 [ d ] = arr1 [ i ] NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT sorted1 [ d ] = arr2 [ j ] NEW_LINE j += 1 NEW_LINE DEDENT d += 1 NEW_LINE DEDENT while ( i < m ) : NEW_LINE INDENT sorted1 [ d ] = arr1 [ i ] NEW_LINE d += 1 NEW_LINE i += 1 NEW_LINE DEDENT while ( j < n ) : NEW_LINE INDENT sorted1 [ d ] = arr2 [ j ] NEW_LINE d += 1 NEW_LINE j += 1 NEW_LINE DEDENT return sorted1 [ k - 1 ] NEW_LINE DEDENT
def floorSqrt ( x ) : NEW_LINE INDENT if ( x == 0 or x == 1 ) : NEW_LINE INDENT return x NEW_LINE DEDENT i = 1 ; result = 1 NEW_LINE while ( result <= x ) : NEW_LINE INDENT i += 1 NEW_LINE result = i * i NEW_LINE DEDENT return i - 1 NEW_LINE DEDENT
def findOddPair ( A , N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT if ( A [ i ] % 2 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count * ( N - count ) NEW_LINE DEDENT
def reversingString ( str , start , end ) : NEW_LINE INDENT while ( start < end ) : NEW_LINE INDENT str = ( str [ : start ] + chr ( ord ( str [ start ] ) ^ ord ( str [ end ] ) ) + str [ start + 1 : ] ) ; NEW_LINE str = ( str [ : end ] + chr ( ord ( str [ start ] ) ^ ord ( str [ end ] ) ) + str [ end + 1 : ] ) ; NEW_LINE str = ( str [ : start ] + chr ( ord ( str [ start ] ) ^ ord ( str [ end ] ) ) + str [ start + 1 : ] ) ; NEW_LINE start += 1 ; NEW_LINE end -= 1 ; NEW_LINE DEDENT return str ; NEW_LINE DEDENT
def summation ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE j = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum = sum + j NEW_LINE j = ( j * 10 ) + 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def subsetSum ( arr , n , i , sum , count ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT if ( sum == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT count = subsetSum ( arr , n , i + 1 , sum - arr [ i ] , count ) NEW_LINE count = subsetSum ( arr , n , i + 1 , sum , count ) NEW_LINE return count NEW_LINE DEDENT
def strrmatch ( strr , pattern , n , m ) : NEW_LINE INDENT if ( m == 0 ) : NEW_LINE INDENT return ( n == 0 ) NEW_LINE DEDENT lookup = [ [ False for i in range ( m + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE lookup [ 0 ] [ 0 ] = True NEW_LINE for j in range ( 1 , m + 1 ) : NEW_LINE INDENT if ( pattern [ j - 1 ] == ' * ' ) : NEW_LINE INDENT lookup [ 0 ] [ j ] = lookup [ 0 ] [ j - 1 ] NEW_LINE DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , m + 1 ) : NEW_LINE INDENT if ( pattern [ j - 1 ] == ' * ' ) : NEW_LINE INDENT lookup [ i ] [ j ] = lookup [ i ] [ j - 1 ] or lookup [ i - 1 ] [ j ] NEW_LINE DEDENT elif ( pattern [ j - 1 ] == ' ? ' or strr [ i - 1 ] == pattern [ j - 1 ] ) : NEW_LINE INDENT lookup [ i ] [ j ] = lookup [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT lookup [ i ] [ j ] = False NEW_LINE DEDENT DEDENT DEDENT return lookup [ n ] [ m ] NEW_LINE DEDENT
def sortWithRemainderP ( arr , n , k , p ) : NEW_LINE INDENT v1 = [ ] NEW_LINE v2 = [ ] NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( arr [ i ] % k == p ) : NEW_LINE INDENT v1 . append ( i ) NEW_LINE v2 . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT v2 . sort ( reverse = False ) NEW_LINE for i in range ( 0 , len ( v1 ) , 1 ) : NEW_LINE INDENT arr [ v1 [ i ] ] = v2 [ i ] NEW_LINE DEDENT for i in range ( 0 , n , 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def minimumCost ( cost , n ) : NEW_LINE INDENT dp1 = 0 NEW_LINE dp2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp0 = cost [ i ] + min ( dp1 , dp2 ) NEW_LINE dp2 = dp1 NEW_LINE dp1 = dp0 NEW_LINE DEDENT return min ( dp1 , dp2 ) NEW_LINE DEDENT
def countPair ( arr , n , k ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ i ] = ( arr [ i ] + k ) % k ; NEW_LINE DEDENT hash = [ 0 ] * k ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash [ arr [ i ] ] += 1 ; NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT cnt += ( hash [ i ] * ( hash [ i ] - 1 ) ) / 2 ; NEW_LINE DEDENT print ( int ( cnt ) ) ; NEW_LINE DEDENT
def printAllAPTriplets ( arr , n ) : NEW_LINE INDENT s = [ ] ; NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT diff = arr [ j ] - arr [ i ] ; NEW_LINE if ( ( arr [ i ] - diff ) in arr ) : NEW_LINE INDENT print ( " { } ▁ { } ▁ { } " . format ( ( arr [ i ] - diff ) , arr [ i ] , arr [ j ] ) , end = " \n " ) ; NEW_LINE DEDENT DEDENT DEDENT s . append ( arr [ i ] ) ; NEW_LINE DEDENT
def check ( arr , n ) : NEW_LINE INDENT k = - 10 ** 9 NEW_LINE r = 10 ** 9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT k = max ( k , arr [ i ] ) NEW_LINE r = min ( r , arr [ i ] ) NEW_LINE DEDENT k += 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ i ] = k - arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( abs ( arr [ i ] ) - 1 < n and arr [ abs ( arr [ i ] ) - 1 ] > 0 ) : NEW_LINE INDENT arr [ abs ( arr [ i ] ) - 1 ] = - arr [ abs ( arr [ i ] ) - 1 ] NEW_LINE DEDENT DEDENT flag = 0 NEW_LINE for i in range ( k - r ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT return flag == 0 NEW_LINE DEDENT
def lenOfLongSubarr ( arr , n ) : NEW_LINE INDENT um = { i : 0 for i in range ( 10 ) } NEW_LINE sum = 0 NEW_LINE maxLen = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] == 0 : NEW_LINE INDENT sum += - 1 NEW_LINE DEDENT else : NEW_LINE INDENT sum += 1 NEW_LINE DEDENT if ( sum == 1 ) : NEW_LINE INDENT maxLen = i + 1 NEW_LINE DEDENT elif ( sum not in um ) : NEW_LINE INDENT um [ sum ] = i NEW_LINE DEDENT if ( ( sum - 1 ) in um ) : NEW_LINE INDENT if ( maxLen < ( i - um [ sum - 1 ] ) ) : NEW_LINE INDENT maxLen = i - um [ sum - 1 ] NEW_LINE DEDENT DEDENT DEDENT return maxLen NEW_LINE DEDENT
def countX ( a , b ) : NEW_LINE INDENT if ( b > a ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( a == b ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT x = a - b NEW_LINE ans = 0 NEW_LINE i = 1 NEW_LINE while i * i <= x : NEW_LINE INDENT if ( x % i == 0 ) : NEW_LINE INDENT d1 = i NEW_LINE d2 = b - 1 NEW_LINE if ( i * i != x ) : NEW_LINE INDENT d2 = x // i NEW_LINE DEDENT if ( d1 > b ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT if ( d2 > b ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
def countOfSubarrays ( arr , n ) : NEW_LINE INDENT count = 0 ; NEW_LINE v = [ 0 ] * ( n + 1 ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT v [ arr [ i ] ] = i ; NEW_LINE DEDENT maximum = INT_MIN ; NEW_LINE minimum = INT_MAX ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT maximum = max ( maximum , v [ i ] ) ; NEW_LINE minimum = min ( minimum , v [ i ] ) ; NEW_LINE if ( maximum - minimum < i ) : NEW_LINE INDENT count = count + 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT
def matrix_multiplication ( M , N ) : NEW_LINE INDENT R = [ [ 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 ] ] NEW_LINE for i in range ( 0 , 4 ) : NEW_LINE INDENT for j in range ( 0 , 4 ) : NEW_LINE INDENT for k in range ( 0 , 4 ) : NEW_LINE INDENT R [ i ] [ j ] += M [ i ] [ k ] * N [ k ] [ j ] NEW_LINE DEDENT DEDENT DEDENT for i in range ( 0 , 4 ) : NEW_LINE INDENT for j in range ( 0 , 4 ) : NEW_LINE INDENT print ( R [ i ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT print ( " \n " , end = " " ) NEW_LINE DEDENT DEDENT
def countOfBinaryNumberLessThanN ( N ) : NEW_LINE INDENT q = deque ( ) NEW_LINE q . append ( 1 ) NEW_LINE cnt = 0 NEW_LINE while ( q ) : NEW_LINE INDENT t = q . popleft ( ) NEW_LINE if ( t <= N ) : NEW_LINE INDENT cnt = cnt + 1 NEW_LINE q . append ( t * 10 ) NEW_LINE q . append ( t * 10 + 1 ) NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
def countUnique ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT s . add ( ( arr [ i ] , arr [ j ] ) ) NEW_LINE DEDENT DEDENT return len ( s ) NEW_LINE DEDENT
def countCommon ( mat , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if mat [ i ] [ i ] == mat [ i ] [ n - i - 1 ] : NEW_LINE INDENT res = res + 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def Centered_Trigunal_num ( n ) : NEW_LINE INDENT return ( 3 * n * n + 3 * n + 2 ) // 2 NEW_LINE DEDENT
def maxCountAB ( s , n ) : NEW_LINE INDENT A = 0 NEW_LINE B = 0 NEW_LINE BA = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT S = s [ i ] NEW_LINE L = len ( S ) NEW_LINE for j in range ( L - 1 ) : NEW_LINE INDENT if ( S [ j ] == ' A ' and S [ j + 1 ] == ' B ' ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT if ( S [ 0 ] == ' B ' and S [ L - 1 ] == ' A ' ) : NEW_LINE INDENT BA += 1 NEW_LINE DEDENT elif ( S [ 0 ] == ' B ' ) : NEW_LINE INDENT B += 1 NEW_LINE DEDENT elif ( S [ L - 1 ] == ' A ' ) : NEW_LINE INDENT A += 1 NEW_LINE DEDENT DEDENT if ( BA == 0 ) : NEW_LINE INDENT ans += min ( B , A ) NEW_LINE DEDENT elif ( A + B == 0 ) : NEW_LINE INDENT ans += BA - 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += BA + min ( B , A ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def findWeights ( X ) : NEW_LINE INDENT sum = 0 NEW_LINE power = 0 NEW_LINE while ( sum < X ) : NEW_LINE INDENT sum = pow ( 3 , power + 1 ) - 1 NEW_LINE sum //= 2 NEW_LINE power += 1 NEW_LINE DEDENT ans = 1 NEW_LINE for i in range ( 1 , power + 1 ) : NEW_LINE INDENT print ( ans , end = " ▁ " ) NEW_LINE ans = ans * 3 NEW_LINE DEDENT DEDENT
def tidyNum ( str , len ) : NEW_LINE INDENT for i in range ( len - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( str [ i ] > str [ i + 1 ] ) : NEW_LINE INDENT str [ i ] -= 1 NEW_LINE for j in range ( i + 1 , len ) : NEW_LINE INDENT str [ j ] = 9 NEW_LINE DEDENT DEDENT DEDENT return str NEW_LINE DEDENT
def count_of_ways ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT for j in range ( 0 , n + 1 ) : NEW_LINE INDENT for k in range ( 0 , n + 1 ) : NEW_LINE INDENT if ( i + j + k == n ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def countDistinct ( arr , n ) : NEW_LINE INDENT arr . sort ( ) ; NEW_LINE res = 0 ; NEW_LINE i = 0 ; NEW_LINE while ( i < n ) : NEW_LINE INDENT while ( i < n - 1 and arr [ i ] == arr [ i + 1 ] ) : NEW_LINE INDENT i += 1 ; NEW_LINE DEDENT res += 1 ; NEW_LINE i += 1 ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT
def countSubString ( s , c , k ) : NEW_LINE INDENT leftCount = 0 NEW_LINE rightCount = 0 NEW_LINE left = 0 NEW_LINE right = 0 NEW_LINE freq = 0 NEW_LINE result = 0 NEW_LINE Len = len ( s ) NEW_LINE while ( s [ left ] != c and left < Len ) : NEW_LINE INDENT left += 1 NEW_LINE leftCount += 1 NEW_LINE DEDENT right = left + 1 NEW_LINE while ( freq != ( k - 1 ) and ( right - 1 ) < Len ) : NEW_LINE INDENT if ( s [ right ] == c ) : NEW_LINE INDENT freq += 1 NEW_LINE DEDENT right += 1 NEW_LINE DEDENT while ( left < Len and ( right - 1 ) < Len ) : NEW_LINE INDENT while ( s [ left ] != c and left < Len ) : NEW_LINE INDENT left += 1 NEW_LINE leftCount += 1 NEW_LINE DEDENT while ( right < Len and s [ right ] != c ) : NEW_LINE INDENT if ( s [ right ] == c ) : NEW_LINE INDENT freq += 1 NEW_LINE DEDENT right += 1 NEW_LINE rightCount += 1 NEW_LINE DEDENT result = ( result + ( leftCount + 1 ) * ( rightCount + 1 ) ) NEW_LINE freq = k - 1 NEW_LINE leftCount = 0 NEW_LINE rightCount = 0 NEW_LINE left += 1 NEW_LINE right += 1 NEW_LINE DEDENT return result NEW_LINE DEDENT
def min_sum ( n , k , a ) : NEW_LINE INDENT a . sort ( reverse = False ) NEW_LINE if ( a [ 0 ] < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( k == 0 ) : NEW_LINE INDENT if ( a [ 0 ] == a [ n - 1 ] ) : NEW_LINE INDENT return ( n * a [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT f = 0 NEW_LINE for i in range ( 1 , n , 1 ) : NEW_LINE INDENT p = a [ i ] - a [ 0 ] NEW_LINE if ( p % k == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT f = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( f ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( k == 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT else : NEW_LINE INDENT return ( n * ( a [ 0 ] % k ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def maxTeams ( N1 , N2 ) : NEW_LINE INDENT count = 0 NEW_LINE while ( N1 > 0 and N2 > 0 and N1 + N2 >= 3 ) : NEW_LINE INDENT if ( N1 > N2 ) : NEW_LINE INDENT N1 -= 2 NEW_LINE N2 -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT N1 -= 1 NEW_LINE N2 -= 2 NEW_LINE DEDENT count = count + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def getValue ( n ) : NEW_LINE INDENT result = int ( math . floor ( math . log ( n + 1 ) / math . log ( 2 ) ) ) NEW_LINE return int ( math . pow ( 2 , result ) ) NEW_LINE DEDENT
def half ( arr , n ) : NEW_LINE INDENT flag = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] % 2 == 0 : NEW_LINE INDENT print ( arr [ i ] // 2 , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT if flag == 0 : NEW_LINE INDENT print ( arr [ i ] // 2 , end = " ▁ " ) NEW_LINE flag = 1 NEW_LINE DEDENT else : NEW_LINE INDENT q = arr [ i ] // 2 NEW_LINE q += 1 NEW_LINE print ( q , end = " ▁ " ) NEW_LINE flag = 0 NEW_LINE DEDENT DEDENT DEDENT DEDENT
def findPair ( arr , n ) : NEW_LINE INDENT found = False NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT for k in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] == arr [ k ] ) : NEW_LINE INDENT print ( arr [ i ] , arr [ j ] ) NEW_LINE found = True NEW_LINE DEDENT DEDENT DEDENT DEDENT if ( found == False ) : NEW_LINE INDENT print ( " Not ▁ exist " ) NEW_LINE DEDENT DEDENT
def countPairsWithDiffK ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if arr [ i ] - arr [ j ] == k or arr [ j ] - arr [ i ] == k : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def longestSubsequenceCommonSegment ( k , s1 , s2 ) : NEW_LINE INDENT n = len ( s1 ) NEW_LINE m = len ( s2 ) NEW_LINE lcs = [ [ 0 for x in range ( m + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE cnt = [ [ 0 for x in range ( m + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , m + 1 ) : NEW_LINE INDENT lcs [ i ] [ j ] = max ( lcs [ i - 1 ] [ j ] , lcs [ i ] [ j - 1 ] ) NEW_LINE if ( s1 [ i - 1 ] == s2 [ j - 1 ] ) : NEW_LINE INDENT cnt [ i ] [ j ] = cnt [ i - 1 ] [ j - 1 ] + 1 ; NEW_LINE DEDENT if ( cnt [ i ] [ j ] >= k ) : NEW_LINE INDENT for a in range ( k , cnt [ i ] [ j ] + 1 ) : NEW_LINE INDENT lcs [ i ] [ j ] = max ( lcs [ i ] [ j ] , lcs [ i - a ] [ j - a ] + a ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return lcs [ n ] [ m ] NEW_LINE DEDENT
def maxEvenSubarray ( array , N ) : NEW_LINE INDENT ans = 0 NEW_LINE count = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT if array [ i ] % 2 == 0 : NEW_LINE INDENT count += 1 NEW_LINE ans = max ( ans , count ) NEW_LINE DEDENT else : NEW_LINE INDENT count = 0 NEW_LINE DEDENT DEDENT ans = max ( ans , count ) NEW_LINE return ans NEW_LINE DEDENT
def isPalindrome ( n ) : NEW_LINE INDENT if n % 11 == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def CountOfOddSum ( a , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( 2 ) ] for i in range ( n ) ] NEW_LINE cnt = [ [ 0 for i in range ( 2 ) ] for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( 2 ) : NEW_LINE INDENT if ( a [ i ] [ j ] % 2 == 0 ) : NEW_LINE INDENT cnt [ i ] [ 0 ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt [ i ] [ 1 ] += 1 NEW_LINE DEDENT DEDENT DEDENT dp [ 0 ] [ 0 ] = cnt [ 0 ] [ 0 ] NEW_LINE dp [ 0 ] [ 1 ] = cnt [ 0 ] [ 1 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT dp [ i ] [ 0 ] = ( dp [ i - 1 ] [ 0 ] * cnt [ i ] [ 0 ] + dp [ i - 1 ] [ 1 ] * cnt [ i ] [ 1 ] ) NEW_LINE dp [ i ] [ 1 ] = ( dp [ i - 1 ] [ 0 ] * cnt [ i ] [ 1 ] + dp [ i - 1 ] [ 1 ] * cnt [ i ] [ 0 ] ) NEW_LINE DEDENT return dp [ n - 1 ] [ 1 ] NEW_LINE DEDENT
def get_permutation ( arr , n ) : NEW_LINE INDENT arr = sorted ( arr ) NEW_LINE result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT result += abs ( arr [ i ] - ( i + 1 ) ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def xorGivenSetBits ( arr , n , k ) : NEW_LINE INDENT v = [ ] NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( bin ( arr [ i ] ) . count ( '1' ) == k ) : NEW_LINE INDENT v . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT result = v [ 0 ] NEW_LINE for i in range ( 1 , len ( v ) , 1 ) : NEW_LINE INDENT result = result ^ v [ i ] NEW_LINE DEDENT return result NEW_LINE DEDENT
def squarearea ( a , b ) : NEW_LINE INDENT if ( a < 0 or b < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT area = 4 * ( ( ( pow ( a , 2 ) + pow ( b , 2 ) ) / ( pow ( a , 2 ) * pow ( b , 2 ) ) ) ) NEW_LINE return area NEW_LINE DEDENT
def isToOne ( n ) : NEW_LINE INDENT return ( n > 0 ) NEW_LINE DEDENT
def printOrder ( arr , n , k ) : NEW_LINE INDENT a = arr [ 0 : k ] ; NEW_LINE a . sort ( ) ; NEW_LINE b = arr [ k : n ] ; NEW_LINE b . sort ( ) ; NEW_LINE b . reverse ( ) ; NEW_LINE return a + b ; NEW_LINE DEDENT
def maxRowDiff ( mat , m , n ) : NEW_LINE INDENT rowSum = [ 0 ] * m NEW_LINE for i in range ( 0 , m ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT sum += mat [ i ] [ j ] NEW_LINE DEDENT rowSum [ i ] = sum NEW_LINE DEDENT max_diff = rowSum [ 1 ] - rowSum [ 0 ] NEW_LINE min_element = rowSum [ 0 ] NEW_LINE for i in range ( 1 , m ) : NEW_LINE INDENT if ( rowSum [ i ] - min_element > max_diff ) : NEW_LINE INDENT max_diff = rowSum [ i ] - min_element NEW_LINE DEDENT if ( rowSum [ i ] < min_element ) : NEW_LINE INDENT min_element = rowSum [ i ] NEW_LINE DEDENT DEDENT return max_diff NEW_LINE DEDENT
def highestPowerof2 ( n ) : NEW_LINE INDENT res = 0 ; NEW_LINE for i in range ( n , 0 , - 1 ) : NEW_LINE INDENT if ( ( i & ( i - 1 ) ) == 0 ) : NEW_LINE INDENT res = i ; NEW_LINE break ; NEW_LINE DEDENT DEDENT return res ; NEW_LINE DEDENT
def reverse ( k ) : NEW_LINE INDENT s = [ ] NEW_LINE token = k . split ( ) NEW_LINE for word in token : NEW_LINE INDENT s . append ( word ) ; NEW_LINE DEDENT while ( len ( s ) ) : NEW_LINE INDENT print ( s . pop ( ) , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT
def printPattern ( n , m , flag ) : NEW_LINE INDENT print ( m ) NEW_LINE if flag == False and n == m : NEW_LINE INDENT return NEW_LINE DEDENT if flag : NEW_LINE INDENT if m - 5 > 0 : NEW_LINE INDENT printPattern ( n , m - 5 , True ) NEW_LINE DEDENT else : NEW_LINE INDENT printPattern ( n , m - 5 , False ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT printPattern ( n , m + 5 , False ) NEW_LINE DEDENT DEDENT
def oppositeSigns ( x , y ) : NEW_LINE INDENT return ( ( x ^ y ) < 0 ) ; NEW_LINE DEDENT
def product ( ar , n ) : NEW_LINE INDENT result = 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT result = ( result * ar [ i ] ) % MOD NEW_LINE DEDENT return result NEW_LINE DEDENT
def pairs_count ( arr , n , sum ) : NEW_LINE INDENT ans = 0 NEW_LINE arr = sorted ( arr ) NEW_LINE i , j = 0 , n - 1 NEW_LINE while ( i < j ) : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] < sum ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT elif ( arr [ i ] + arr [ j ] > sum ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT x = arr [ i ] NEW_LINE xx = i NEW_LINE while ( i < j and arr [ i ] == x ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT y = arr [ j ] NEW_LINE yy = j NEW_LINE while ( j >= i and arr [ j ] == y ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT if ( x == y ) : NEW_LINE INDENT temp = i - xx + yy - j - 1 NEW_LINE ans += ( temp * ( temp + 1 ) ) // 2 NEW_LINE DEDENT else : NEW_LINE INDENT ans += ( i - xx ) * ( yy - j ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def convolution ( x , h , n , m ) : NEW_LINE INDENT row_vec = [ 0 ] * MAX_SIZE ; NEW_LINE col_vec = [ 0 ] * MAX_SIZE ; NEW_LINE out = [ 0 ] * MAX_SIZE ; NEW_LINE circular_shift_mat = [ [ 0 for i in range ( MAX_SIZE ) ] for j in range ( MAX_SIZE ) ] ; NEW_LINE if ( n > m ) : NEW_LINE INDENT maxSize = n ; NEW_LINE DEDENT else : NEW_LINE INDENT maxSize = m ; NEW_LINE DEDENT for i in range ( maxSize ) : NEW_LINE INDENT if ( i >= n ) : NEW_LINE INDENT row_vec [ i ] = 0 ; NEW_LINE DEDENT else : NEW_LINE INDENT row_vec [ i ] = x [ i ] ; NEW_LINE DEDENT DEDENT for i in range ( maxSize ) : NEW_LINE INDENT if ( i >= m ) : NEW_LINE INDENT col_vec [ i ] = 0 ; NEW_LINE DEDENT else : NEW_LINE INDENT col_vec [ i ] = h [ i ] ; NEW_LINE DEDENT DEDENT k = 0 ; NEW_LINE d = 0 ; NEW_LINE for i in range ( maxSize ) : NEW_LINE INDENT curIndex = k - d ; NEW_LINE for j in range ( maxSize ) : NEW_LINE INDENT circular_shift_mat [ j ] [ i ] =   \ NEW_LINE row_vec [ curIndex % maxSize ] ; NEW_LINE curIndex += 1 ; NEW_LINE DEDENT k = maxSize ; NEW_LINE d += 1 ; NEW_LINE DEDENT for i in range ( maxSize ) : NEW_LINE INDENT for j in range ( maxSize ) : NEW_LINE INDENT out [ i ] += circular_shift_mat [ i ] [ j ] *   \ NEW_LINE INDENT col_vec [ j ] ; NEW_LINE DEDENT DEDENT print ( out [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT
def Area ( b1 , b2 , h ) : NEW_LINE INDENT return ( ( b1 + b2 ) / 2 ) * h NEW_LINE DEDENT
def returnWinner ( s , l ) : NEW_LINE INDENT freq = [ 0 for i in range ( 26 ) ] NEW_LINE for i in range ( 0 , l , 1 ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT cnt = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ( freq [ i ] % 2 != 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT if ( cnt == 0 or cnt & 1 == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 2 NEW_LINE DEDENT DEDENT
def countDivisibles ( arr , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] % arr [ j ] == 0 or arr [ j ] % arr [ i ] == 0 ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
def countDivisibles ( A , B , M ) : NEW_LINE INDENT counter = 0 ; NEW_LINE for i in range ( A , B ) : NEW_LINE INDENT if ( i % M == 0 ) : NEW_LINE INDENT counter = counter + 1 NEW_LINE DEDENT DEDENT return counter NEW_LINE DEDENT
def isPerfectCubeString ( str1 ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( len ( str1 ) ) : NEW_LINE INDENT sum += ord ( str1 [ i ] ) NEW_LINE DEDENT cr = ceil ( ( sum ) ** ( 1 / 3 ) ) NEW_LINE return ( cr * cr * cr == sum ) NEW_LINE DEDENT
def IsPossible ( s ) : NEW_LINE INDENT n = len ( s ) ; NEW_LINE count = set ( ) ; NEW_LINE map = dict . fromkeys ( s , 0 ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT count . add ( s [ i ] ) ; NEW_LINE map [ s [ i ] ] += 1 ; NEW_LINE DEDENT if ( len ( count ) == 1 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT if ( len ( count ) > 2 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT j = 0 NEW_LINE it = list ( count ) [ j ] ; NEW_LINE x = 0 ; y = 0 ; NEW_LINE x = map [ it ] ; NEW_LINE j += 1 NEW_LINE it = list ( count ) [ j ] ; NEW_LINE y = map [ it ] ; NEW_LINE if ( abs ( x - y ) <= 1 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT
def countPoints ( n , m , a , b , x , y ) : NEW_LINE INDENT a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE j , count = 0 , 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT while j < m : NEW_LINE INDENT if a [ i ] + y < b [ j ] : NEW_LINE INDENT break NEW_LINE DEDENT if ( b [ j ] >= a [ i ] - x and b [ j ] <= a [ i ] + y ) : NEW_LINE INDENT count += 1 NEW_LINE j += 1 NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT j += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def findSubsequence ( arr , n ) : NEW_LINE INDENT sign = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT sign [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT sign [ i ] = - 1 NEW_LINE DEDENT DEDENT k = 0 NEW_LINE result = [ 0 ] * n NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT cur = arr [ i ] NEW_LINE j = i NEW_LINE while ( j < n and sign [ i ] == sign [ j ] ) : NEW_LINE INDENT cur = max ( cur , arr [ j ] ) NEW_LINE j += 1 NEW_LINE DEDENT result [ k ] = cur NEW_LINE k += 1 NEW_LINE i = j - 1 NEW_LINE i += 1 NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT print ( result [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def logicOfSequence ( N ) : NEW_LINE INDENT if ( N % 2 == 0 ) : NEW_LINE INDENT N = N * N NEW_LINE DEDENT else : NEW_LINE INDENT N = N * N * N NEW_LINE DEDENT return N NEW_LINE DEDENT
def GetMinSubarrayLength ( a , n ) : NEW_LINE INDENT ans = max ( a [ 0 ] , a [ n - 1 ] ) NEW_LINE lo = 0 NEW_LINE hi = n - 1 NEW_LINE while ( lo < n and a [ lo ] % ans == 0 ) : NEW_LINE INDENT lo += 1 NEW_LINE DEDENT while ( hi > lo and a [ hi ] % ans == 0 ) : NEW_LINE INDENT hi -= 1 NEW_LINE DEDENT return ( hi - lo + 1 ) NEW_LINE DEDENT
def binaryToDecimal ( n ) : NEW_LINE INDENT num = n ; NEW_LINE dec_value = 0 ; NEW_LINE base1 = 1 ; NEW_LINE len1 = len ( num ) ; NEW_LINE for i in range ( len1 - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( num [ i ] == '1' ) : NEW_LINE INDENT dec_value += base1 ; NEW_LINE DEDENT base1 = base1 * 2 ; NEW_LINE DEDENT return dec_value ; NEW_LINE DEDENT
def findAndSum ( arr , n ) : NEW_LINE INDENT Sum = 0 NEW_LINE mul = 1 NEW_LINE for i in range ( 30 ) : NEW_LINE INDENT count_on = 0 NEW_LINE l = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( ( arr [ j ] & ( 1 << i ) ) > 0 ) : NEW_LINE INDENT if ( count_on ) : NEW_LINE INDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_on = 1 NEW_LINE l += 1 NEW_LINE DEDENT DEDENT elif ( count_on ) : NEW_LINE INDENT Sum += ( ( mul * l * ( l + 1 ) ) // 2 ) NEW_LINE count_on = 0 NEW_LINE l = 0 NEW_LINE DEDENT DEDENT if ( count_on ) : NEW_LINE INDENT Sum += ( ( mul * l * ( l + 1 ) ) // 2 ) NEW_LINE count_on = 0 NEW_LINE l = 0 NEW_LINE DEDENT mul *= 2 NEW_LINE DEDENT return Sum NEW_LINE DEDENT
def areaOfKite ( a , b , angle ) : NEW_LINE INDENT angle = angle * PI ; NEW_LINE area = a * b * math . sin ( angle ) ; NEW_LINE return area ; NEW_LINE DEDENT
def areaOfInscribedCircle ( a ) : NEW_LINE INDENT return ( PI / 4 ) * a * a NEW_LINE DEDENT
def printDistinct ( arr , n ) : NEW_LINE INDENT arr . sort ( ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i < n - 1 and arr [ i ] == arr [ i + 1 ] ) : NEW_LINE INDENT while ( i < n - 1 and ( arr [ i ] == arr [ i + 1 ] ) ) : NEW_LINE INDENT i += 1 ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT DEDENT
def countnndSay ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return "1" NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT return "11" NEW_LINE DEDENT s = "11" NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT s += ' $ ' NEW_LINE l = len ( s ) NEW_LINE cnt = 1 NEW_LINE tmp = " " NEW_LINE for j in range ( 1 , l ) : NEW_LINE INDENT if ( s [ j ] != s [ j - 1 ] ) : NEW_LINE INDENT tmp += str ( cnt + 0 ) NEW_LINE tmp += s [ j - 1 ] NEW_LINE cnt = 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT s = tmp NEW_LINE DEDENT return s ; NEW_LINE DEDENT
def countCharacterType ( str ) : NEW_LINE INDENT vowels = 0 NEW_LINE consonant = 0 NEW_LINE specialChar = 0 NEW_LINE digit = 0 NEW_LINE for i in range ( 0 , len ( str ) ) : NEW_LINE INDENT ch = str [ i ] NEW_LINE if ( ( ch >= ' a ' and ch <= ' z ' ) or ( ch >= ' A ' and ch <= ' Z ' ) ) : NEW_LINE INDENT ch = ch . lower ( ) NEW_LINE if ( ch == ' a ' or ch == ' e ' or ch == ' i ' or ch == ' o ' or ch == ' u ' ) : NEW_LINE INDENT vowels += 1 NEW_LINE DEDENT else : NEW_LINE INDENT consonant += 1 NEW_LINE DEDENT DEDENT elif ( ch >= '0' and ch <= '9' ) : NEW_LINE INDENT digit += 1 NEW_LINE DEDENT else : NEW_LINE INDENT specialChar += 1 NEW_LINE DEDENT DEDENT print ( " Vowels : " , vowels ) NEW_LINE print ( " Consonant : " , consonant ) NEW_LINE print ( " Digit : " , digit ) NEW_LINE print ( " Special ▁ Character : " , specialChar ) NEW_LINE DEDENT
def answer ( n ) : NEW_LINE INDENT m = 2 ; NEW_LINE ans = 1 ; NEW_LINE r = 1 ; NEW_LINE while r < n : NEW_LINE INDENT r = ( int ) ( ( pow ( 2 , m ) - 1 ) * ( pow ( 2 , m - 1 ) ) ) ; NEW_LINE if r < n : NEW_LINE INDENT ans = r ; NEW_LINE DEDENT m = m + 1 ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT
def frequency ( a , x ) : NEW_LINE INDENT count = 0 NEW_LINE for i in a : NEW_LINE INDENT if i == x : count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def maxSquareSubsetSum ( A , N ) : NEW_LINE INDENT sub1 = 0 ; sub2 = 0 ; NEW_LINE A . sort ( ) ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( i < ( N // 2 ) - 1 ) : NEW_LINE INDENT sub1 += A [ i ] ; NEW_LINE DEDENT else : NEW_LINE INDENT sub2 += A [ i ] ; NEW_LINE DEDENT DEDENT return sub1 * sub1 + sub2 * sub2 ; NEW_LINE DEDENT
def ReplaceElements ( arr , n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT prev = arr [ 0 ] NEW_LINE arr [ 0 ] = arr [ 0 ] + arr [ 1 ] NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT curr = arr [ i ] NEW_LINE arr [ i ] = prev + arr [ i + 1 ] NEW_LINE prev = curr NEW_LINE DEDENT arr [ n - 1 ] = prev + arr [ n - 1 ] NEW_LINE DEDENT
def reverse ( string , length , l , r ) : NEW_LINE INDENT if ( l < 0 or r >= length or l > r ) : NEW_LINE INDENT return string ; NEW_LINE DEDENT string = list ( string ) NEW_LINE while ( l < r ) : NEW_LINE INDENT c = string [ l ] ; NEW_LINE string [ l ] = string [ r ] ; NEW_LINE string [ r ] = c ; NEW_LINE l += 1 ; NEW_LINE r -= 1 ; NEW_LINE DEDENT return " " . join ( string ) ; NEW_LINE DEDENT
def product ( a , n ) : NEW_LINE INDENT ans = 1 NEW_LINE val = pow ( 2 , n - 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans *= pow ( a [ i ] , val ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def kthgroupsum ( k ) : NEW_LINE INDENT cur = int ( ( k * ( k - 1 ) ) + 1 ) NEW_LINE sum = 0 NEW_LINE while k : NEW_LINE INDENT sum += cur NEW_LINE cur += 2 NEW_LINE k = k - 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def countNumbers ( n ) : NEW_LINE INDENT c = 0 NEW_LINE limit = int ( n ** ( 0.5 ) ) NEW_LINE prime = [ i for i in range ( limit + 1 ) ] NEW_LINE i = 2 NEW_LINE while i * i <= limit : NEW_LINE INDENT if prime [ i ] == i : NEW_LINE INDENT for j in range ( i * i , limit + 1 , i ) : NEW_LINE INDENT if prime [ j ] == j : NEW_LINE INDENT prime [ j ] = i NEW_LINE DEDENT DEDENT DEDENT i += 1 NEW_LINE DEDENT for i in range ( 2 , limit + 1 ) : NEW_LINE INDENT p = prime [ i ] NEW_LINE q = prime [ i // prime [ i ] ] NEW_LINE if p * q == i and q != 1 and p != q : NEW_LINE INDENT c += 1 NEW_LINE DEDENT elif prime [ i ] == i : NEW_LINE INDENT if i ** 8 <= n : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT DEDENT return c NEW_LINE DEDENT
def findFibSubset ( arr , n ) : NEW_LINE INDENT m = max ( arr ) NEW_LINE a = 0 NEW_LINE b = 1 NEW_LINE hash = [ ] NEW_LINE hash . append ( a ) NEW_LINE hash . append ( b ) NEW_LINE while ( b < m ) : NEW_LINE INDENT c = a + b NEW_LINE a = b NEW_LINE b = c NEW_LINE hash . append ( b ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in hash : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def CntDivbyX ( arr , n , x ) : NEW_LINE INDENT number = 0 NEW_LINE count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT number = ( number * 2 + arr [ i ] ) % x NEW_LINE if number == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def findSymPairs ( arr , row ) : NEW_LINE INDENT hM = dict ( ) NEW_LINE for i in range ( row ) : NEW_LINE INDENT first = arr [ i ] [ 0 ] NEW_LINE sec = arr [ i ] [ 1 ] NEW_LINE if ( sec in hM . keys ( ) and hM [ sec ] == first ) : NEW_LINE INDENT print ( " ( " , sec , " , " , first , " ) " ) NEW_LINE DEDENT else : NEW_LINE INDENT hM [ first ] = sec NEW_LINE DEDENT DEDENT DEDENT
def countEle ( s , a , N ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT num = a [ i ] NEW_LINE if num in mp : NEW_LINE INDENT print ( "0" , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT cnt = 0 NEW_LINE while s [ - 1 ] != num : NEW_LINE INDENT mp [ s . pop ( ) ] = True NEW_LINE cnt += 1 NEW_LINE DEDENT s . pop ( ) NEW_LINE cnt += 1 NEW_LINE print ( cnt , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def squareRootExists ( n , p ) : NEW_LINE INDENT n = n % p NEW_LINE for x in range ( 2 , p , 1 ) : NEW_LINE INDENT if ( ( x * x ) % p == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def isPalindrome ( num ) : NEW_LINE INDENT s = str ( num ) NEW_LINE low = 0 NEW_LINE high = len ( s ) - 1 NEW_LINE while ( low < high ) : NEW_LINE INDENT if ( s [ low ] != s [ high ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT low += 1 NEW_LINE high -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT
def removeChar ( s , c ) : NEW_LINE INDENT counts = s . count ( c ) NEW_LINE s = list ( s ) NEW_LINE while counts : NEW_LINE INDENT s . remove ( c ) NEW_LINE counts -= 1 NEW_LINE DEDENT s = ' ' . join ( s ) NEW_LINE print ( s ) NEW_LINE DEDENT
def EvenOddAbsoluteDifference ( arr , n ) : NEW_LINE INDENT even = 0 NEW_LINE odd = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT even = abs ( even - arr [ i ] ) ; NEW_LINE DEDENT else : NEW_LINE INDENT odd = abs ( odd - arr [ i ] ) ; NEW_LINE DEDENT DEDENT print ( " Even ▁ Index ▁ absolute ▁ difference ▁ : " , even ) NEW_LINE print ( " Odd ▁ Index ▁ absolute ▁ difference ▁ : " , odd ) NEW_LINE DEDENT
def findSubString ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE dist_count = len ( set ( [ x for x in str ] ) ) NEW_LINE curr_count = defaultdict ( lambda : 0 ) NEW_LINE for j in range ( n ) : NEW_LINE INDENT curr_count [ str [ j ] ] += 1 NEW_LINE if curr_count [ str [ j ] ] == 1 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if count == dist_count : NEW_LINE INDENT while curr_count [ str [ start ] ] > 1 : NEW_LINE INDENT if curr_count [ str [ start ] ] > 1 : NEW_LINE INDENT curr_count [ str [ start ] ] -= 1 NEW_LINE DEDENT start += 1 NEW_LINE DEDENT len_window = j - start + 1 NEW_LINE if min_len > len_window : NEW_LINE INDENT min_len = len_window NEW_LINE start_index = start NEW_LINE DEDENT DEDENT DEDENT return str [ start_index : start_index + min_len ] NEW_LINE DEDENT
def minimumSets ( arr , n , key ) : NEW_LINE INDENT arr . sort ( reverse = False ) NEW_LINE j = n - 1 NEW_LINE for i in range ( 0 , j + 1 , 1 ) : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] <= key ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT DEDENT return i + 1 NEW_LINE DEDENT
def shuffle ( N , key ) : NEW_LINE INDENT NO_OF_BITS = N NEW_LINE reverse_num = 0 NEW_LINE for i in range ( NO_OF_BITS ) : NEW_LINE INDENT temp = ( key & ( 1 << i ) ) NEW_LINE if ( temp ) : NEW_LINE INDENT reverse_num |= ( 1 << ( ( NO_OF_BITS - 1 ) - i ) ) NEW_LINE DEDENT DEDENT print ( reverse_num ) NEW_LINE DEDENT
def pentagon_pyramidal ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT p = ( 3 * i * i - i ) / 2 NEW_LINE sum = sum + p NEW_LINE DEDENT return sum NEW_LINE DEDENT
def printFactorialNums ( n ) : NEW_LINE INDENT fact = 1 NEW_LINE x = 2 NEW_LINE while fact <= n : NEW_LINE INDENT print ( fact , end = " ▁ " ) NEW_LINE fact = fact * x NEW_LINE x += 1 NEW_LINE DEDENT DEDENT
def printNumber ( holes ) : NEW_LINE INDENT if ( holes == 0 ) : NEW_LINE INDENT print ( "1" ) NEW_LINE DEDENT elif ( holes == 1 ) : NEW_LINE INDENT print ( "0" , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT rem = 0 NEW_LINE quo = 0 NEW_LINE rem = holes % 2 NEW_LINE quo = holes // 2 NEW_LINE if ( rem == 1 ) : NEW_LINE INDENT print ( "4" , end = " " ) NEW_LINE DEDENT for i in range ( quo ) : NEW_LINE INDENT print ( "8" , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def printPascal ( n : int ) : NEW_LINE INDENT arr = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] NEW_LINE for line in range ( 0 , n ) : NEW_LINE INDENT for i in range ( 0 , line + 1 ) : NEW_LINE INDENT if ( i is 0 or i is line ) : NEW_LINE INDENT arr [ line ] [ i ] = 1 NEW_LINE print ( arr [ line ] [ i ] , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT arr [ line ] [ i ] = ( arr [ line - 1 ] [ i - 1 ] + arr [ line - 1 ] [ i ] ) NEW_LINE print ( arr [ line ] [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( " \n " , end = " " ) NEW_LINE DEDENT DEDENT
def numberOfWays ( x ) : NEW_LINE INDENT if x == 0 or x == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ( numberOfWays ( x - 1 ) + ( x - 1 ) * numberOfWays ( x - 2 ) ) NEW_LINE DEDENT DEDENT
def count9s ( number ) : NEW_LINE INDENT n = len ( number ) NEW_LINE d = [ 0 for i in range ( 9 ) ] NEW_LINE d [ 0 ] = 1 NEW_LINE result = 0 NEW_LINE mod_sum = 0 NEW_LINE continuous_zero = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ord ( number [ i ] ) - ord ( '0' ) == 0 ) : NEW_LINE INDENT continuous_zero += 1 NEW_LINE DEDENT else : NEW_LINE INDENT continuous_zero = 0 NEW_LINE DEDENT mod_sum += ord ( number [ i ] ) - ord ( '0' ) NEW_LINE mod_sum %= 9 NEW_LINE result += d [ mod_sum ] NEW_LINE d [ mod_sum ] += 1 NEW_LINE result -= continuous_zero NEW_LINE DEDENT return result NEW_LINE DEDENT
def longestAlternating ( arr , n ) : NEW_LINE INDENT count = [ None ] * n NEW_LINE count [ n - 1 ] = 1 NEW_LINE i = n - 2 NEW_LINE while i >= 0 : NEW_LINE INDENT if ( arr [ i ] * arr [ i + 1 ] < 0 ) : NEW_LINE INDENT count [ i ] = count [ i + 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT count [ i ] = 1 ; NEW_LINE DEDENT i = i - 1 NEW_LINE DEDENT i = 0 NEW_LINE while i < n : NEW_LINE INDENT print ( count [ i ] , end = " ▁ " ) NEW_LINE i = i + 1 NEW_LINE DEDENT DEDENT
def minSteps ( str ) : NEW_LINE INDENT count = 0 NEW_LINE i = 0 NEW_LINE while i < len ( str ) - 2 : NEW_LINE INDENT if str [ i ] == '0' : NEW_LINE INDENT if ( str [ i + 1 ] == '1' ) : NEW_LINE INDENT if ( str [ i + 2 ] == '0' ) : NEW_LINE INDENT count = count + 1 NEW_LINE i = i + 2 NEW_LINE DEDENT DEDENT DEDENT i = i + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def getIndex ( a , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ptrL = 0 NEW_LINE ptrR = n - 1 NEW_LINE sumL = a [ 0 ] NEW_LINE sumR = a [ n - 1 ] NEW_LINE while ( ptrR - ptrL > 1 ) : NEW_LINE INDENT if ( sumL < sumR ) : NEW_LINE INDENT ptrL += 1 NEW_LINE sumL += a [ ptrL ] NEW_LINE DEDENT elif ( sumL > sumR ) : NEW_LINE INDENT ptrR -= 1 NEW_LINE sumR += a [ ptrR ] NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return ptrL NEW_LINE DEDENT
def checkBisymmetric ( m , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , i ) : NEW_LINE INDENT if ( m [ i ] [ j ] != m [ j ] [ i ] ) : NEW_LINE INDENT return false NEW_LINE DEDENT DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n - i ) : NEW_LINE INDENT if ( m [ i ] [ j ] != m [ n - j - 1 ] [ n - i - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True ; NEW_LINE DEDENT
def findSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE i = 1 NEW_LINE while ( ( 1 << i ) < n ) : NEW_LINE INDENT for j in range ( 0 , i ) : NEW_LINE INDENT num = ( 1 << i ) + ( 1 << j ) NEW_LINE if ( num <= n ) : NEW_LINE INDENT sum += num NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def solve ( n , x , y ) : NEW_LINE INDENT length = ceil ( log2 ( n + 2 ) ) - 1 ; NEW_LINE rank = n - ( 1 << length ) + 1 ; NEW_LINE left = " " ; right = " " ; NEW_LINE for i in range ( length - 1 , - 1 , - 1 ) : NEW_LINE INDENT mask = ( 1 << i ) ; NEW_LINE bit = ( mask & rank ) ; NEW_LINE if ( bit ) : NEW_LINE INDENT left += y ; NEW_LINE right += y ; NEW_LINE DEDENT else : NEW_LINE INDENT left += x ; NEW_LINE right += x ; NEW_LINE DEDENT DEDENT right = right [ : : - 1 ] ; NEW_LINE res = left + right ; NEW_LINE return res ; NEW_LINE DEDENT
def findpair ( l , r ) : NEW_LINE INDENT c = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , r + 1 ) : NEW_LINE INDENT if ( j % i == 0 and j != i ) : NEW_LINE INDENT print ( i , " , ▁ " , j ) NEW_LINE c = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( c == 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT
def gcdExtended ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b , 0 , 1 NEW_LINE DEDENT gcd , x1 , y1 = gcdExtended ( b % a , a ) NEW_LINE x = y1 - ( b // a ) * x1 NEW_LINE y = x1 NEW_LINE return gcd , x , y NEW_LINE DEDENT
def lcs ( X , Y , m , n , dp ) : NEW_LINE INDENT if ( m == 0 or n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ m - 1 ] [ n - 1 ] != - 1 ) : NEW_LINE INDENT return dp [ m - 1 ] [ n - 1 ] NEW_LINE DEDENT if ( X [ m - 1 ] == Y [ n - 1 ] ) : NEW_LINE INDENT dp [ m - 1 ] [ n - 1 ] = 1 + lcs ( X , Y , m - 1 , n - 1 , dp ) NEW_LINE return dp [ m - 1 ] [ n - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ m - 1 ] [ n - 1 ] = max ( lcs ( X , Y , m , n - 1 , dp ) , lcs ( X , Y , m - 1 , n , dp ) ) NEW_LINE return dp [ m - 1 ] [ n - 1 ] NEW_LINE DEDENT DEDENT
def Diamond ( rows ) : NEW_LINE INDENT n = 0 NEW_LINE for i in range ( 1 , rows + 1 ) : NEW_LINE INDENT for j in range ( 1 , ( rows - i ) + 1 ) : NEW_LINE INDENT print ( end = " ▁ " ) NEW_LINE DEDENT while n != ( 2 * i - 1 ) : NEW_LINE INDENT print ( " * " , end = " " ) NEW_LINE n = n + 1 NEW_LINE DEDENT n = 0 NEW_LINE print ( ) NEW_LINE DEDENT k = 1 NEW_LINE n = 1 NEW_LINE for i in range ( 1 , rows ) : NEW_LINE INDENT for j in range ( 1 , k + 1 ) : NEW_LINE INDENT print ( end = " ▁ " ) NEW_LINE DEDENT k = k + 1 NEW_LINE while n <= ( 2 * ( rows - i ) - 1 ) : NEW_LINE INDENT print ( " * " , end = " " ) NEW_LINE n = n + 1 NEW_LINE DEDENT n = 1 NEW_LINE print ( ) NEW_LINE DEDENT DEDENT
def isPossibleToZero ( a , n ) : NEW_LINE INDENT num = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT num = num * 10 + a [ i ] ; NEW_LINE DEDENT return ( num % 11 == 0 ) ; NEW_LINE DEDENT
def two_way_sort ( arr , arr_len ) : NEW_LINE INDENT l , r = 0 , arr_len - 1 NEW_LINE k = 0 NEW_LINE while ( l < r ) : NEW_LINE INDENT while ( arr [ l ] % 2 != 0 ) : NEW_LINE INDENT l += 1 NEW_LINE k += 1 NEW_LINE DEDENT while ( arr [ r ] % 2 == 0 and l < r ) : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT if ( l < r ) : NEW_LINE INDENT arr [ l ] , arr [ r ] = arr [ r ] , arr [ l ] NEW_LINE DEDENT DEDENT odd = arr [ : k ] NEW_LINE even = arr [ k : ] NEW_LINE odd . sort ( reverse = True ) NEW_LINE even . sort ( ) NEW_LINE odd . extend ( even ) NEW_LINE return odd NEW_LINE DEDENT
def check_last ( arr , n , p ) : NEW_LINE INDENT _sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT _sum = _sum + arr [ i ] NEW_LINE DEDENT if p == 1 : NEW_LINE INDENT if _sum % 2 == 0 : NEW_LINE INDENT return " ODD " NEW_LINE DEDENT else : NEW_LINE INDENT return " EVEN " NEW_LINE DEDENT DEDENT return " EVEN " NEW_LINE DEDENT
def findPattern ( n ) : NEW_LINE INDENT prev = n % 2 NEW_LINE n = n // 2 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT curr = n % 2 NEW_LINE if ( curr == prev ) : NEW_LINE INDENT return False NEW_LINE DEDENT prev = curr NEW_LINE n = n // 2 NEW_LINE DEDENT return True NEW_LINE DEDENT
def countFact ( low , high ) : NEW_LINE INDENT fact = 1 NEW_LINE x = 1 NEW_LINE while ( fact < low ) : NEW_LINE INDENT fact = fact * x NEW_LINE x += 1 NEW_LINE DEDENT res = 0 NEW_LINE while ( fact <= high ) : NEW_LINE INDENT res += 1 NEW_LINE fact = fact * x NEW_LINE x += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
def dodecahedral_num ( n ) : NEW_LINE INDENT return n * ( 3 * n - 1 ) * ( 3 * n - 2 ) // 2 NEW_LINE DEDENT
def floorAndCeil ( arr , n , x ) : NEW_LINE INDENT fDist = sys . maxsize NEW_LINE cDist = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] >= x and cDist > ( arr [ i ] - x ) ) : NEW_LINE INDENT cInd = i NEW_LINE cDist = arr [ i ] - x NEW_LINE DEDENT if ( arr [ i ] <= x and fDist > ( x - arr [ i ] ) ) : NEW_LINE INDENT fInd = i NEW_LINE fDist = x - arr [ i ] NEW_LINE DEDENT DEDENT if ( fDist == sys . maxsize ) : NEW_LINE INDENT print ( " Floor ▁ doesn ' t ▁ exist ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Floor ▁ is ▁ " + str ( arr [ fInd ] ) ) NEW_LINE DEDENT if ( cDist == sys . maxsize ) : NEW_LINE INDENT print ( " Ceil ▁ doesn ' t ▁ exist ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Ceil ▁ is ▁ " + str ( arr [ cInd ] ) ) NEW_LINE DEDENT DEDENT
def findMinSwaps ( arr , n ) : NEW_LINE INDENT noOfZeroes = [ 0 ] * n NEW_LINE count = 0 NEW_LINE noOfZeroes [ n - 1 ] = 1 - arr [ n - 1 ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT noOfZeroes [ i ] = noOfZeroes [ i + 1 ] NEW_LINE if ( arr [ i ] == 0 ) : NEW_LINE INDENT noOfZeroes [ i ] = noOfZeroes [ i ] + 1 NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT count = count + noOfZeroes [ i ] NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def findGreater ( a , b ) : NEW_LINE INDENT x = a * ( math . log ( b ) ) ; NEW_LINE y = b * ( math . log ( a ) ) ; NEW_LINE if ( y > x ) : NEW_LINE INDENT print ( " a ^ b ▁ is ▁ greater " ) ; NEW_LINE DEDENT elif ( y < x ) : NEW_LINE INDENT print ( " b ^ a ▁ is ▁ greater " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Both ▁ are ▁ equal " ) ; NEW_LINE DEDENT DEDENT
def findMaxNum ( arr , n ) : NEW_LINE INDENT arr . sort ( reverse = True ) NEW_LINE num = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT num = num * 10 + arr [ i ] NEW_LINE DEDENT return num NEW_LINE DEDENT
def findS ( s ) : NEW_LINE INDENT _sum = 0 NEW_LINE n = 1 NEW_LINE while ( _sum < s ) : NEW_LINE INDENT _sum += n NEW_LINE n += 1 NEW_LINE DEDENT n -= 1 NEW_LINE if _sum == s : NEW_LINE INDENT return n NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def oddDays ( N ) : NEW_LINE INDENT hund1 = N // 100 NEW_LINE hund4 = N // 400 NEW_LINE leap = N >> 2 NEW_LINE ordd = N - leap NEW_LINE if ( hund1 ) : NEW_LINE INDENT ordd += hund1 NEW_LINE leap -= hund1 NEW_LINE DEDENT if ( hund4 ) : NEW_LINE INDENT ordd -= hund4 NEW_LINE leap += hund4 NEW_LINE DEDENT days = ordd + leap * 2 NEW_LINE odd = days % 7 NEW_LINE return odd NEW_LINE DEDENT
def printMaxSum ( arr , n ) : NEW_LINE INDENT dp = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp [ i ] = arr [ i ] NEW_LINE maxi = 0 NEW_LINE for j in range ( 1 , int ( ( i + 1 ) ** 0.5 ) + 1 ) : NEW_LINE INDENT if ( ( i + 1 ) % j == 0 and ( i + 1 ) != j ) : NEW_LINE INDENT if ( dp [ j - 1 ] > maxi ) : NEW_LINE INDENT maxi = dp [ j - 1 ] NEW_LINE DEDENT if ( dp [ ( i + 1 ) // j - 1 ] > maxi and j != 1 ) : NEW_LINE INDENT maxi = dp [ ( i + 1 ) // j - 1 ] NEW_LINE DEDENT DEDENT DEDENT dp [ i ] += maxi NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( dp [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT
def check ( arr , n ) : NEW_LINE INDENT modify = 0 NEW_LINE if ( arr [ n - 1 ] >= arr [ n - 2 ] ) : NEW_LINE INDENT arr [ n - 1 ] = arr [ n - 2 ] - 1 NEW_LINE modify += 1 NEW_LINE DEDENT if ( arr [ 0 ] <= arr [ 1 ] ) : NEW_LINE INDENT arr [ 0 ] = arr [ 0 ] + 1 NEW_LINE modify += 1 NEW_LINE DEDENT for i in range ( n - 2 , 0 , - 1 ) : NEW_LINE INDENT if ( arr [ i - 1 ] <= arr [ i ] and arr [ i + 1 ] <= arr [ i ] ) or   \ NEW_LINE ( arr [ i - 1 ] >= arr [ i ] and arr [ i + 1 ] >= arr [ i ] ) : NEW_LINE INDENT arr [ i ] = ( arr [ i - 1 ] + arr [ i + 1 ] ) // 2 NEW_LINE modify += 1 NEW_LINE if ( arr [ i ] == arr [ i - 1 ] or arr [ i ] == arr [ i + 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT if ( modify > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT
def changeTheArray ( arr , n ) : NEW_LINE INDENT minEle = min ( arr ) NEW_LINE maxEle = max ( arr ) NEW_LINE minOperations = sys . maxsize NEW_LINE for num in range ( minEle , maxEle + 1 ) : NEW_LINE INDENT operations = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] != num : NEW_LINE INDENT operations += ( abs ( num - arr [ i ] ) - 1 ) NEW_LINE DEDENT DEDENT minOperations = min ( minOperations , operations ) NEW_LINE DEDENT return minOperations NEW_LINE DEDENT
def arePermutation ( str1 , str2 ) : NEW_LINE INDENT n1 = len ( str1 ) NEW_LINE n2 = len ( str2 ) NEW_LINE if ( n1 != n2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT a = sorted ( str1 ) NEW_LINE str1 = " ▁ " . join ( a ) NEW_LINE b = sorted ( str2 ) NEW_LINE str2 = " ▁ " . join ( b ) NEW_LINE for i in range ( 0 , n1 , 1 ) : NEW_LINE INDENT if ( str1 [ i ] != str2 [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def findSum ( n ) : NEW_LINE INDENT ans = 0 ; temp = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if temp < n : NEW_LINE INDENT temp = i - 1 NEW_LINE num = 1 NEW_LINE while temp < n : NEW_LINE INDENT if temp + i <= n : NEW_LINE INDENT ans += i * num NEW_LINE DEDENT else : NEW_LINE INDENT ans += ( n - temp ) * num NEW_LINE DEDENT temp += i NEW_LINE num += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def possible ( n ) : NEW_LINE INDENT if ( n > 3 ) : NEW_LINE INDENT sum = ( n * ( n + 1 ) ) // 2 ; NEW_LINE if ( sum % 3 == 0 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT return False ; NEW_LINE DEDENT
def alternate ( a , b , x ) : NEW_LINE INDENT x = a ^ b ^ x NEW_LINE print ( " After ▁ exchange " ) NEW_LINE print ( " x ▁ is " , x ) NEW_LINE DEDENT
def solve ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE if ( k == 1 and arr [ n - 2 ] != arr [ n - 1 ] ) : NEW_LINE INDENT print ( arr [ n - 1 ] ) NEW_LINE return NEW_LINE DEDENT count = 1 NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] == arr [ i + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count = 1 NEW_LINE DEDENT if ( count == k and ( i == 0 or ( arr [ i - 1 ] != arr [ i ] ) ) ) : NEW_LINE INDENT print ( arr [ i ] ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( " No ▁ such ▁ element " ) NEW_LINE DEDENT
def findLength ( s , k ) : NEW_LINE INDENT ans = 10 ** 9 NEW_LINE l = 0 NEW_LINE r = 0 NEW_LINE cnt_zero = 0 NEW_LINE cnt_one = 0 NEW_LINE while ( l < len ( s ) and r <= len ( s ) ) : NEW_LINE INDENT if ( cnt_zero >= k and cnt_one >= 1 ) : NEW_LINE INDENT ans = min ( ans , r - l ) NEW_LINE l += 1 NEW_LINE if ( s [ l - 1 ] == '0' ) : NEW_LINE INDENT cnt_zero -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt_one -= 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( r == len ( s ) ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( s [ r ] == '0' ) : NEW_LINE INDENT cnt_zero += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt_one += 1 NEW_LINE DEDENT r += 1 NEW_LINE DEDENT DEDENT if ( ans == 10 ** 9 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def twistedTOH ( n , first , middle , last ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT print ( " Move ▁ disk " , n , " from ▁ rod " , first , " to " , middle , " and ▁ then ▁ to " , last ) NEW_LINE return NEW_LINE DEDENT twistedTOH ( n - 1 , first , middle , last ) NEW_LINE print ( " Move ▁ disk " , n , " from ▁ rod " , first , " to " , middle ) NEW_LINE twistedTOH ( n - 1 , last , middle , first ) NEW_LINE print ( " Move ▁ disk " , n , " from ▁ rod " , middle , " to " , last ) NEW_LINE twistedTOH ( n - 1 , first , middle , last ) NEW_LINE DEDENT
def nthTermOfTheSeries ( n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT nthTerm = pow ( n - 1 , 2 ) + n NEW_LINE DEDENT else : NEW_LINE INDENT nthTerm = pow ( n + 1 , 2 ) + n NEW_LINE DEDENT return nthTerm NEW_LINE DEDENT
def PrintNumber ( N , Original , K , flag ) : NEW_LINE INDENT print ( N , end = " ▁ " ) NEW_LINE if ( N <= 0 ) : NEW_LINE INDENT if ( flag == 0 ) : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT else : NEW_LINE INDENT flag = 0 NEW_LINE DEDENT DEDENT if ( N == Original and ( not ( flag ) ) ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( flag == True ) : NEW_LINE INDENT PrintNumber ( N - K , Original , K , flag ) NEW_LINE return NEW_LINE DEDENT if ( not ( flag ) ) : NEW_LINE INDENT PrintNumber ( N + K , Original , K , flag ) ; NEW_LINE return NEW_LINE DEDENT DEDENT
def angleequichord ( z ) : NEW_LINE INDENT print ( " The ▁ angle ▁ subtended ▁ at " , " the ▁ center ▁ is " , z , " degrees " ) ; NEW_LINE DEDENT
def maxOR ( arr , n ) : NEW_LINE INDENT maxVal = 0 ; NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT maxVal = max ( maxVal , arr [ i ] | arr [ j ] ) ; NEW_LINE DEDENT DEDENT return maxVal ; NEW_LINE DEDENT
def minOperation ( S , N , K ) : NEW_LINE INDENT if N % K : NEW_LINE INDENT print ( " Not ▁ Possible " ) NEW_LINE return NEW_LINE DEDENT count = [ 0 ] * 26 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT count [ ord ( S [ i ] ) - 97 ] += 1 NEW_LINE DEDENT E = N // K NEW_LINE greaterE = [ ] NEW_LINE lessE = [ ] NEW_LINE for i in range ( 0 , 26 ) : NEW_LINE INDENT if count [ i ] < E : NEW_LINE INDENT lessE . append ( E - count [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT greaterE . append ( count [ i ] - E ) NEW_LINE DEDENT DEDENT greaterE . sort ( ) NEW_LINE lessE . sort ( ) NEW_LINE mi = float ( ' inf ' ) NEW_LINE for i in range ( 0 , K + 1 ) : NEW_LINE INDENT set1 , set2 = i , K - i NEW_LINE if ( len ( greaterE ) >= set1 and len ( lessE ) >= set2 ) : NEW_LINE INDENT step1 , step2 = 0 , 0 NEW_LINE for j in range ( 0 , set1 ) : NEW_LINE INDENT step1 += greaterE [ j ] NEW_LINE DEDENT for j in range ( 0 , set2 ) : NEW_LINE INDENT step2 += lessE [ j ] NEW_LINE DEDENT mi = min ( mi , max ( step1 , step2 ) ) NEW_LINE DEDENT DEDENT print ( mi ) NEW_LINE DEDENT
def FindMinNum ( arr , n ) : NEW_LINE INDENT pre = [ 0 for i in range ( n ) ] NEW_LINE pre [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n , 1 ) : NEW_LINE INDENT pre [ i ] = pre [ i - 1 ] + arr [ i ] NEW_LINE DEDENT k = sys . maxsize NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT rightSum = pre [ n - 1 ] - pre [ i ] NEW_LINE if ( rightSum >= pre [ i ] ) : NEW_LINE INDENT k = min ( k , rightSum - pre [ i ] ) NEW_LINE DEDENT DEDENT if ( k != sys . maxsize ) : NEW_LINE INDENT return k NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def countSubstr ( str , n , x , y ) : NEW_LINE INDENT tot_count = 0 NEW_LINE count_x = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if str [ i ] == x : NEW_LINE INDENT count_x += 1 NEW_LINE DEDENT if str [ i ] == y : NEW_LINE INDENT tot_count += count_x NEW_LINE DEDENT DEDENT return tot_count NEW_LINE DEDENT
def extractMaximum ( ss ) : NEW_LINE INDENT num , res = 0 , 0 NEW_LINE for i in range ( len ( ss ) ) : NEW_LINE INDENT if ss [ i ] >= "0" and ss [ i ] <= "9" : NEW_LINE INDENT num = num * 10 + int ( int ( ss [ i ] ) - 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT res = max ( res , num ) NEW_LINE num = 0 NEW_LINE DEDENT DEDENT return max ( res , num ) NEW_LINE DEDENT
def myCopy ( s1 , s2 ) : NEW_LINE INDENT for i in range ( len ( s1 ) ) : NEW_LINE INDENT s2 [ i ] = s1 [ i ] ; NEW_LINE DEDENT DEDENT
def replaceRemove ( s , X , Y , Z ) : NEW_LINE INDENT s = list ( s ) ; NEW_LINE start = 0 ; NEW_LINE end = len ( s ) - 1 ; NEW_LINE while ( start <= end ) : NEW_LINE INDENT if ( s [ start ] == Z ) : NEW_LINE INDENT while ( end >= 0 and s [ end ] == Z ) : NEW_LINE INDENT end -= 1 ; NEW_LINE DEDENT if ( end > start ) : NEW_LINE INDENT s [ start ] , s [ end ] = s [ end ] , s [ start ] NEW_LINE if ( s [ start ] == X ) : NEW_LINE INDENT s [ start ] = Y ; NEW_LINE DEDENT start += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( s [ start ] == X ) : NEW_LINE INDENT s [ start ] = Y ; NEW_LINE DEDENT start += 1 ; NEW_LINE DEDENT DEDENT while ( len ( s ) > 0 and s [ len ( s ) - 1 ] == Z ) : NEW_LINE INDENT s . pop ( ) ; NEW_LINE DEDENT return " " . join ( s ) NEW_LINE DEDENT
def stringPalindrome ( A , B ) : NEW_LINE INDENT countA = [ 0 ] * MAX_CHAR NEW_LINE countB = [ 0 ] * MAX_CHAR NEW_LINE l1 = len ( A ) NEW_LINE l2 = len ( B ) NEW_LINE for i in range ( l1 ) : NEW_LINE INDENT countA [ ord ( A [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( l2 ) : NEW_LINE INDENT countB [ ord ( B [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT if ( ( countA [ i ] > 1 and countB [ i ] == 0 ) ) : NEW_LINE INDENT return ' A ' NEW_LINE DEDENT DEDENT return ' B ' NEW_LINE DEDENT
def catalan ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT catalan = [ 0 for i in range ( n + 1 ) ] NEW_LINE catalan [ 0 ] = 1 NEW_LINE catalan [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT catalan [ i ] = 0 NEW_LINE for j in range ( i ) : NEW_LINE INDENT catalan [ i ] = catalan [ i ] + catalan [ j ] * catalan [ i - j - 1 ] NEW_LINE DEDENT DEDENT return catalan [ n ] NEW_LINE DEDENT
def evenDecimalValue ( str , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( str [ i ] == '0' ) : NEW_LINE INDENT result += ( n - i ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def circle ( x1 , y1 , x2 , y2 , r1 , r2 ) : NEW_LINE INDENT distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ; NEW_LINE radSumSq = ( r1 + r2 ) * ( r1 + r2 ) ; NEW_LINE if ( distSq == radSumSq ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( distSq > radSumSq ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT
def xorOfArray ( arr , n ) : NEW_LINE INDENT xor_arr = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT xor_arr = xor_arr ^ arr [ i ] NEW_LINE DEDENT return xor_arr NEW_LINE DEDENT
def sieve ( ) : NEW_LINE INDENT position [ 0 ] = - 1 NEW_LINE position [ 1 ] = - 1 NEW_LINE pos = 0 NEW_LINE for i in range ( 2 , limit + 1 ) : NEW_LINE INDENT if ( position [ i ] == 0 ) : NEW_LINE INDENT pos += 1 NEW_LINE position [ i ] = pos NEW_LINE for j in range ( i * 2 , limit + 1 , i ) : NEW_LINE INDENT position [ j ] = - 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT
def ReuleauxArea ( a ) : NEW_LINE INDENT if a < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return 0.70477 * pow ( a , 2 ) NEW_LINE DEDENT
def RSF ( n ) : NEW_LINE INDENT while ( n >= 10 ) : NEW_LINE INDENT x = n ; NEW_LINE l = 0 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT n = n // 10 ; NEW_LINE l += 1 ; NEW_LINE DEDENT a = [ 0 ] * l ; NEW_LINE i = l - 1 ; NEW_LINE while ( x > 0 ) : NEW_LINE INDENT a [ i ] = x % 10 ; NEW_LINE x = x // 10 ; NEW_LINE i -= 1 ; NEW_LINE DEDENT for j in range ( 0 , l - 1 ) : NEW_LINE INDENT n = n * 10 + abs ( a [ j ] - a [ j + 1 ] ) ; NEW_LINE DEDENT DEDENT return n ; NEW_LINE DEDENT
def findRealAndImag ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE i = 0 NEW_LINE if ( s . find ( ' + ' ) != - 1 ) : NEW_LINE INDENT i = s . find ( ' + ' ) NEW_LINE DEDENT else : NEW_LINE INDENT i = s . find ( ' - ' ) ; NEW_LINE DEDENT real = s [ : i ] NEW_LINE imaginary = s [ i + 1 : l - 1 ] NEW_LINE print ( " Real ▁ part : " , real ) NEW_LINE print ( " Imaginary ▁ part : " , imaginary ) NEW_LINE DEDENT
def sumOfSeries ( n ) : NEW_LINE INDENT return 0.0246 * ( math . pow ( 10 , n ) - 1 - ( 9 * n ) ) NEW_LINE DEDENT
def generateString ( A , B ) : NEW_LINE INDENT rt = " " NEW_LINE while ( 0 < A or 0 < B ) : NEW_LINE INDENT if ( A < B ) : NEW_LINE INDENT if ( 0 < B ) : NEW_LINE INDENT rt = rt + ' b ' NEW_LINE B -= 1 NEW_LINE DEDENT if ( 0 < B ) : NEW_LINE INDENT rt += ' b ' NEW_LINE B -= 1 NEW_LINE DEDENT if ( 0 < A ) : NEW_LINE INDENT rt += ' a ' NEW_LINE A -= 1 NEW_LINE DEDENT DEDENT elif ( B < A ) : NEW_LINE INDENT if ( 0 < A ) : NEW_LINE INDENT rt += ' a ' NEW_LINE A -= 1 NEW_LINE DEDENT if ( 0 < A ) : NEW_LINE INDENT rt += ' a ' NEW_LINE A -= 1 NEW_LINE DEDENT if ( 0 < B ) : NEW_LINE INDENT rt += ' b ' NEW_LINE B -= 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( 0 < A ) : NEW_LINE INDENT rt += ' a ' NEW_LINE A -= 1 NEW_LINE DEDENT if ( 0 < B ) : NEW_LINE INDENT rt += ' b ' NEW_LINE B -= 1 NEW_LINE DEDENT DEDENT DEDENT print ( rt ) NEW_LINE DEDENT
def maximumChars ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE res = - 1 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( str [ i ] == str [ j ] ) : NEW_LINE INDENT res = max ( res , abs ( j - i - 1 ) ) NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
def mostFrequent ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE max_count = 1 ; res = arr [ 0 ] ; curr_count = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] == arr [ i - 1 ] ) : NEW_LINE INDENT curr_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( curr_count > max_count ) : NEW_LINE INDENT max_count = curr_count NEW_LINE res = arr [ i - 1 ] NEW_LINE DEDENT curr_count = 1 NEW_LINE DEDENT DEDENT if ( curr_count > max_count ) : NEW_LINE INDENT max_count = curr_count NEW_LINE res = arr [ n - 1 ] NEW_LINE DEDENT return res NEW_LINE DEDENT
def printLines ( n , k ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( k * ( 6 * i + 1 ) , k * ( 6 * i + 2 ) , k * ( 6 * i + 3 ) , k * ( 6 * i + 5 ) ) NEW_LINE DEDENT DEDENT
def swap ( xp , yp ) : NEW_LINE INDENT xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] NEW_LINE yp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] NEW_LINE xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] NEW_LINE DEDENT
def calculateSum ( n ) : NEW_LINE INDENT return ( 2 * ( n * ( n + 1 ) * ( 2 * n + 1 ) // 6 ) + n * ( n + 1 ) // 2 + 2 * ( n ) ) NEW_LINE DEDENT
def printQueries ( n , a , q , qry ) : NEW_LINE INDENT occ = dict ( ) NEW_LINE suffixCount = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT occ [ a [ i ] ] = 1 NEW_LINE suffixCount [ i + 1 ] = len ( occ ) NEW_LINE DEDENT for i in range ( q ) : NEW_LINE INDENT print ( suffixCount [ qry [ i ] ] ) NEW_LINE DEDENT DEDENT
def missingNumber ( arr1 , arr2 , n ) : NEW_LINE INDENT mnum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT mnum = mnum ^ arr1 [ i ] NEW_LINE DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT mnum = mnum ^ arr2 [ i ] NEW_LINE DEDENT return mnum NEW_LINE DEDENT
def sumOfTheSeries ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += 1.0 / ( i * ( i + 1 ) ) ; NEW_LINE DEDENT return sum NEW_LINE DEDENT
def countNum ( N , K ) : NEW_LINE INDENT sumPF = [ 0 ] * MAX ; NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT if ( sumPF [ i ] == 0 ) : NEW_LINE INDENT for j in range ( i , N , i ) : NEW_LINE INDENT sumPF [ j ] += i ; NEW_LINE DEDENT DEDENT DEDENT count = 0 ; NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT if ( sumPF [ i ] == K ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT
def minJumps ( arr , n ) : NEW_LINE INDENT jumps = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT jumps [ i ] = float ( ' inf ' ) NEW_LINE DEDENT elif ( arr [ i ] >= n - i - 1 ) : NEW_LINE INDENT jumps [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT min = float ( ' inf ' ) NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( j <= arr [ i ] + i ) : NEW_LINE INDENT if ( min > jumps [ j ] ) : NEW_LINE INDENT min = jumps [ j ] NEW_LINE DEDENT DEDENT DEDENT if ( min != float ( ' inf ' ) ) : NEW_LINE INDENT jumps [ i ] = min + 1 NEW_LINE DEDENT else : NEW_LINE INDENT jumps [ i ] = min NEW_LINE DEDENT DEDENT DEDENT return jumps [ 0 ] NEW_LINE DEDENT
def ceilSearch ( arr , low , high , x ) : NEW_LINE INDENT if x <= arr [ low ] : NEW_LINE INDENT return low NEW_LINE DEDENT if x > arr [ high ] : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = ( low + high ) / 2 ; NEW_LINE if arr [ mid ] == x : NEW_LINE INDENT return mid NEW_LINE DEDENT elif arr [ mid ] < x : NEW_LINE INDENT if mid + 1 <= high and x <= arr [ mid + 1 ] : NEW_LINE INDENT return mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ceilSearch ( arr , mid + 1 , high , x ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if mid - 1 >= low and x > arr [ mid - 1 ] : NEW_LINE INDENT return mid NEW_LINE DEDENT else : NEW_LINE INDENT return ceilSearch ( arr , low , mid - 1 , x ) NEW_LINE DEDENT DEDENT DEDENT
def deleteElements ( arr , n , k ) : NEW_LINE INDENT st = [ ] NEW_LINE st . append ( arr [ 0 ] ) NEW_LINE top = 0 NEW_LINE count = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT while ( len ( st ) != 0 and count < k and st [ top ] < arr [ i ] ) : NEW_LINE INDENT st . pop ( ) NEW_LINE count += 1 NEW_LINE top -= 1 NEW_LINE DEDENT st . append ( arr [ i ] ) NEW_LINE top += 1 NEW_LINE DEDENT for i in range ( 0 , len ( st ) ) : NEW_LINE INDENT print ( st [ i ] , " ▁ " , end = " " ) NEW_LINE DEDENT DEDENT
def CountPair ( L , R ) : NEW_LINE INDENT x = ( R - L + 1 ) NEW_LINE print ( x // 2 ) NEW_LINE DEDENT
def findsum ( arr , N ) : NEW_LINE INDENT mp = collections . defaultdict ( int ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT sum = 0 NEW_LINE for i in mp : NEW_LINE INDENT if ( mp [ i ] % 2 != 0 ) : NEW_LINE INDENT sum += ( i * mp [ i ] ) NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def maxOR ( L , R ) : NEW_LINE INDENT if ( L == R ) : NEW_LINE INDENT return L ; NEW_LINE DEDENT ans = 0 ; NEW_LINE for i in range ( MAX - 1 , - 1 , - 1 ) : NEW_LINE INDENT p = 1 << i ; NEW_LINE lbit = ( L >> i ) & 1 ; NEW_LINE rbit = ( R >> i ) & 1 ; NEW_LINE if ( ( rbit == 1 ) and ( lbit == 0 ) ) : NEW_LINE INDENT ans += ( p << 1 ) - 1 ; NEW_LINE break ; NEW_LINE DEDENT if ( rbit == 1 ) : NEW_LINE INDENT ans += p ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT
def countStrings ( n ) : NEW_LINE INDENT a = [ 0 for i in range ( n ) ] NEW_LINE b = [ 0 for i in range ( n ) ] NEW_LINE a [ 0 ] = b [ 0 ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT a [ i ] = a [ i - 1 ] + b [ i - 1 ] NEW_LINE b [ i ] = a [ i - 1 ] NEW_LINE DEDENT return a [ n - 1 ] + b [ n - 1 ] NEW_LINE DEDENT
def isEven ( n ) : NEW_LINE INDENT return ( n % 2 == 0 ) NEW_LINE DEDENT
def nextPowerOf2 ( n ) : NEW_LINE INDENT n -= 1 NEW_LINE n |= n >> 1 NEW_LINE n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 8 NEW_LINE n |= n >> 16 NEW_LINE n += 1 NEW_LINE return n NEW_LINE DEDENT
def swapThree ( a , b , c ) : NEW_LINE INDENT a [ 0 ] = a [ 0 ] ^ b [ 0 ] ^ c [ 0 ] NEW_LINE b [ 0 ] = a [ 0 ] ^ b [ 0 ] ^ c [ 0 ] NEW_LINE c [ 0 ] = a [ 0 ] ^ b [ 0 ] ^ c [ 0 ] NEW_LINE a [ 0 ] = a [ 0 ] ^ b [ 0 ] ^ c [ 0 ] NEW_LINE DEDENT
def minCost ( cost ) : NEW_LINE INDENT dist = [ 0 for i in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT dist [ i ] = INF NEW_LINE DEDENT dist [ 0 ] = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( dist [ j ] > dist [ i ] + cost [ i ] [ j ] ) : NEW_LINE INDENT dist [ j ] = dist [ i ] + cost [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return dist [ N - 1 ] NEW_LINE DEDENT
def summation ( n ) : NEW_LINE INDENT return int ( ( pow ( 10 , n + 1 ) - 10 - ( 9 * n ) ) / 81 ) ; NEW_LINE DEDENT
def solve ( arr , n , i , pos ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( LAS [ i ] [ pos ] ) : NEW_LINE INDENT return LAS [ i ] [ pos ] ; NEW_LINE DEDENT inc = 0 ; exc = 0 ; NEW_LINE if ( arr [ i ] > 0 and pos == True ) : NEW_LINE INDENT pos = False ; NEW_LINE inc = 1 + solve ( arr , n , i + 1 , pos ) ; NEW_LINE DEDENT elif ( arr [ i ] < 0 and pos == False ) : NEW_LINE INDENT pos = True ; NEW_LINE inc = 1 + solve ( arr , n , i + 1 , pos ) ; NEW_LINE DEDENT exc = solve ( arr , n , i + 1 , pos ) ; NEW_LINE LAS [ i ] [ pos ] = max ( inc , exc ) ; NEW_LINE return LAS [ i ] [ pos ] ; NEW_LINE DEDENT
def previousFibonacci ( n ) : NEW_LINE INDENT a = n / ( ( 1 + sqrt ( 5 ) ) / 2.0 ) NEW_LINE return round ( a ) NEW_LINE DEDENT
def trianglearea ( l , b ) : NEW_LINE INDENT if ( l < 0 or b < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT area = ( l * b ) / 2 NEW_LINE return area NEW_LINE DEDENT
def maxWeight ( arr , n , w1_r , w2_r , i ) : NEW_LINE INDENT if i == n : NEW_LINE INDENT return 0 NEW_LINE DEDENT if dp [ i ] [ w1_r ] [ w2_r ] != - 1 : NEW_LINE INDENT return dp [ i ] [ w1_r ] [ w2_r ] NEW_LINE DEDENT fill_w1 , fill_w2 , fill_none = 0 , 0 , 0 NEW_LINE if w1_r >= arr [ i ] : NEW_LINE INDENT fill_w1 = arr [ i ] + maxWeight ( arr , n , w1_r - arr [ i ] , w2_r , i + 1 ) NEW_LINE DEDENT if w2_r >= arr [ i ] : NEW_LINE INDENT fill_w2 = arr [ i ] + maxWeight ( arr , n , w1_r , w2_r - arr [ i ] , i + 1 ) NEW_LINE DEDENT fill_none = maxWeight ( arr , n , w1_r , w2_r , i + 1 ) NEW_LINE dp [ i ] [ w1_r ] [ w2_r ] = max ( fill_none , max ( fill_w1 , fill_w2 ) ) NEW_LINE return dp [ i ] [ w1_r ] [ w2_r ] NEW_LINE DEDENT
def maxOR ( L , R ) : NEW_LINE INDENT maximum = - 10 ** 9 NEW_LINE for i in range ( L , R ) : NEW_LINE INDENT for j in range ( i + 1 , R + 1 ) : NEW_LINE INDENT maximum = max ( maximum , ( i | j ) ) NEW_LINE DEDENT DEDENT return maximum NEW_LINE DEDENT
def findSplTripletsSum ( a , b , c , p , q , r ) : NEW_LINE INDENT summ = 0 NEW_LINE for i in range ( p ) : NEW_LINE INDENT for j in range ( q ) : NEW_LINE INDENT for k in range ( r ) : NEW_LINE INDENT if ( a [ i ] <= b [ j ] and c [ k ] <= b [ j ] ) : NEW_LINE INDENT summ += ( a [ i ] + b [ j ] ) * ( b [ j ] + c [ k ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return summ NEW_LINE DEDENT
def findSmallest ( s ) : NEW_LINE INDENT length = len ( s ) ; NEW_LINE loccur = [ - 1 ] * 26 ; NEW_LINE for i in range ( length - 1 , - 1 , - 1 ) : NEW_LINE INDENT chI = ord ( s [ i ] ) - ord ( ' a ' ) ; NEW_LINE if ( loccur [ chI ] == - 1 ) : NEW_LINE INDENT loccur [ chI ] = i ; NEW_LINE DEDENT DEDENT sorted_s = s ; NEW_LINE sorted_s . sort ( ) ; NEW_LINE for i in range ( length ) : NEW_LINE INDENT if ( s [ i ] != sorted_s [ i ] ) : NEW_LINE INDENT chI = ord ( sorted_s [ i ] ) - ord ( ' a ' ) ; NEW_LINE last_occ = loccur [ chI ] ; NEW_LINE s [ i ] , s [ last_occ ] = s [ last_occ ] , s [ i ] NEW_LINE break ; NEW_LINE DEDENT DEDENT return " " . join ( s ) ; NEW_LINE DEDENT
def count_of_ways ( n ) : NEW_LINE INDENT count = 0 NEW_LINE count = ( n + 1 ) * ( n + 2 ) // 2 NEW_LINE return count NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return 3 * pow ( n , 2 ) + 2 * n - 5 NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return 4 * pow ( n , 2 ) - 3 * n + 2 NEW_LINE DEDENT
def Count_subarray ( arr , n ) : NEW_LINE INDENT total_sum = 0 ; NEW_LINE count = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT total_sum += arr [ i ] ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT subarray_sum = 0 ; NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT subarray_sum += arr [ j ] ; NEW_LINE remaining_sum = total_sum - subarray_sum ; NEW_LINE if ( subarray_sum > remaining_sum ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT DEDENT return count ; NEW_LINE DEDENT
def nDigitPalindromes ( n ) : NEW_LINE INDENT return ( 9 * pow ( 10 , ( n - 1 ) // 2 ) ) ; NEW_LINE DEDENT
def calculate ( N ) : NEW_LINE INDENT length = len ( N ) NEW_LINE l = int ( ( length ) / 2 ) NEW_LINE count = 0 NEW_LINE for i in range ( l + 1 ) : NEW_LINE INDENT s = N [ 0 : 0 + i ] NEW_LINE l1 = len ( s ) NEW_LINE t = N [ i : l1 + i ] NEW_LINE try : NEW_LINE INDENT if s [ 0 ] == '0' or t [ 0 ] == '0' : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT except : NEW_LINE INDENT continue NEW_LINE DEDENT if s == t : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def printPattern ( N ) : NEW_LINE INDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( i - 1 if i % 2 == 0 else i + 1 , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def countNonDecreasing ( n ) : NEW_LINE INDENT N = 10 NEW_LINE count = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT count = int ( count * ( N + i - 1 ) ) NEW_LINE count = int ( count / i ) NEW_LINE DEDENT return count NEW_LINE DEDENT
def isTriangular ( num ) : NEW_LINE INDENT if ( num < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT sum , n = 0 , 1 NEW_LINE while ( sum <= num ) : NEW_LINE INDENT sum = sum + n NEW_LINE if ( sum == num ) : NEW_LINE INDENT return True NEW_LINE DEDENT n += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT
def check ( n , k , a , b ) : NEW_LINE INDENT a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE fl = False NEW_LINE ind = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] != b [ i ] ) : NEW_LINE INDENT if ( fl == True ) : NEW_LINE INDENT return False NEW_LINE DEDENT fl = True NEW_LINE ind = i NEW_LINE DEDENT DEDENT if ( ind == - 1 or abs ( a [ ind ] - b [ ind ] ) <= k ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def getLargestSum ( N ) : NEW_LINE INDENT max_sum = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , N + 1 , 1 ) : NEW_LINE INDENT if ( i * j % ( i + j ) == 0 ) : NEW_LINE INDENT max_sum = max ( max_sum , i + j ) NEW_LINE DEDENT DEDENT DEDENT return max_sum NEW_LINE DEDENT
def findNumOfPair ( a , n ) : NEW_LINE INDENT a = sorted ( a ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] <= 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT j = lower_bound ( a , - a [ i ] + 1 ) NEW_LINE ans += i - j NEW_LINE DEDENT return ans NEW_LINE DEDENT
def ceilSearch ( arr , low , high , x ) : NEW_LINE INDENT if x <= arr [ low ] : NEW_LINE INDENT return low NEW_LINE DEDENT i = low NEW_LINE for i in range ( high ) : NEW_LINE INDENT if arr [ i ] == x : NEW_LINE INDENT return i NEW_LINE DEDENT if arr [ i ] < x and arr [ i + 1 ] >= x : NEW_LINE INDENT return i + 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def countWays ( i , j , x , arr ) : NEW_LINE INDENT if ( i == n or j == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT x = ( x & arr [ i ] [ j ] ) NEW_LINE if ( x == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( i == n - 1 and j == n - 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( v [ i ] [ j ] [ x ] ) : NEW_LINE INDENT return dp [ i ] [ j ] [ x ] NEW_LINE DEDENT v [ i ] [ j ] [ x ] = 1 NEW_LINE dp [ i ] [ j ] [ x ] = countWays ( i + 1 , j , x , arr ) +   \ NEW_LINE INDENT countWays ( i , j + 1 , x , arr ) ; NEW_LINE DEDENT return dp [ i ] [ j ] [ x ] NEW_LINE DEDENT
def TotalWays ( n , s , k ) : NEW_LINE INDENT dp = [ 0 ] * n NEW_LINE dp [ s - 1 ] = 1 NEW_LINE for i in range ( s , n ) : NEW_LINE INDENT idx = max ( s - 1 , i - k ) NEW_LINE for j in range ( idx , i ) : NEW_LINE INDENT dp [ i ] += dp [ j ] NEW_LINE DEDENT DEDENT return dp [ n - 1 ] NEW_LINE DEDENT
def findMaxValue ( ) : NEW_LINE INDENT res = 2 ; NEW_LINE fact = 2 ; NEW_LINE while ( True ) : NEW_LINE INDENT if ( fact < 0 or fact > sys . maxsize ) : NEW_LINE INDENT break ; NEW_LINE DEDENT res += 1 ; NEW_LINE fact = fact * res ; NEW_LINE DEDENT return res - 1 ; NEW_LINE DEDENT
def nCr ( n , r ) : NEW_LINE INDENT fac = list ( ) NEW_LINE fac . append ( 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fac . append ( fac [ i - 1 ] * i ) NEW_LINE DEDENT ans = fac [ n ] / ( fac [ n - r ] * fac [ r ] ) NEW_LINE return ans NEW_LINE DEDENT
def isPossible ( A , n , k ) : NEW_LINE INDENT countOfTwo = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( A [ i ] % 2 == 0 ) : NEW_LINE INDENT countOfTwo += 1 NEW_LINE DEDENT DEDENT if ( k == 0 and countOfTwo == n ) : NEW_LINE INDENT print ( " NO \n " ) NEW_LINE DEDENT elif ( countOfTwo >= k ) : NEW_LINE INDENT print ( " Yes \n " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No \n " ) NEW_LINE DEDENT DEDENT
def sum_of_series ( n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT result = result - pow ( i , 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT result = result + pow ( i , 2 ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def count ( n , x ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if i <= x : NEW_LINE INDENT if x // i <= n and x % i == 0 : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT
def printOriginalMatrix ( a , b , mat ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == 1 ) : NEW_LINE INDENT print ( min ( a [ i ] , b [ j ] ) , end = " ▁ " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT
def countPairs ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] == arr [ j ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def solve ( A , B , n ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT if ( bin ( A [ i ] | A [ j ] ) . count ( '1' ) == B [ j ] ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT
def findseason ( M ) : NEW_LINE INDENT list1 = [ [ 12 , 1 , 2 ] , [ 3 , 4 , 5 ] , [ 6 , 7 , 8 ] , [ 9 , 10 , 11 ] ] NEW_LINE if M in list1 [ 0 ] : NEW_LINE INDENT print ( " WINTER " ) NEW_LINE DEDENT elif M in list1 [ 1 ] : NEW_LINE INDENT print ( " SPRING " ) NEW_LINE DEDENT elif M in list1 [ 2 ] : NEW_LINE INDENT print ( " SUMMER " ) NEW_LINE DEDENT elif M in list1 [ 3 ] : NEW_LINE INDENT print ( " AUTUMN " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Invalid ▁ Month ▁ Number " ) NEW_LINE DEDENT DEDENT
def atMostSum ( arr , n , k ) : NEW_LINE INDENT _sum = 0 NEW_LINE cnt = 0 NEW_LINE maxcnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( _sum + arr [ i ] ) <= k ) : NEW_LINE INDENT _sum += arr [ i ] NEW_LINE cnt += 1 NEW_LINE DEDENT elif ( sum != 0 ) : NEW_LINE INDENT _sum = _sum - arr [ i - cnt ] + arr [ i ] NEW_LINE DEDENT maxcnt = max ( cnt , maxcnt ) NEW_LINE DEDENT return maxcnt NEW_LINE DEDENT
def countSubstringWithEqualEnds ( s ) : NEW_LINE INDENT result = 0 ; NEW_LINE n = len ( s ) ; NEW_LINE count = [ 0 ] * MAX_CHAR ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 ; NEW_LINE DEDENT for i in range ( MAX_CHAR ) : NEW_LINE INDENT result += ( count [ i ] * ( count [ i ] + 1 ) / 2 ) ; NEW_LINE DEDENT return result ; NEW_LINE DEDENT
def printDuplicates ( arr ) : NEW_LINE INDENT dict = { } NEW_LINE for ele in arr : NEW_LINE INDENT try : NEW_LINE INDENT dict [ ele ] += 1 NEW_LINE DEDENT except : NEW_LINE INDENT dict [ ele ] = 1 NEW_LINE DEDENT DEDENT for item in dict : NEW_LINE INDENT if ( dict [ item ] > 1 ) : NEW_LINE INDENT print ( item , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( " \n " ) NEW_LINE DEDENT
def multiply ( num1 , num2 ) : NEW_LINE INDENT len1 = len ( num1 ) NEW_LINE len2 = len ( num2 ) NEW_LINE if len1 == 0 or len2 == 0 : NEW_LINE INDENT return "0" NEW_LINE DEDENT result = [ 0 ] * ( len1 + len2 ) NEW_LINE i_n1 = 0 NEW_LINE i_n2 = 0 NEW_LINE for i in range ( len1 - 1 , - 1 , - 1 ) : NEW_LINE INDENT carry = 0 NEW_LINE n1 = ord ( num1 [ i ] ) - 48 NEW_LINE i_n2 = 0 NEW_LINE for j in range ( len2 - 1 , - 1 , - 1 ) : NEW_LINE INDENT n2 = ord ( num2 [ j ] ) - 48 NEW_LINE summ = n1 * n2 + result [ i_n1 + i_n2 ] + carry NEW_LINE carry = summ // 10 NEW_LINE result [ i_n1 + i_n2 ] = summ % 10 NEW_LINE i_n2 += 1 NEW_LINE DEDENT if ( carry > 0 ) : NEW_LINE INDENT result [ i_n1 + i_n2 ] += carry NEW_LINE DEDENT i_n1 += 1 NEW_LINE DEDENT i = len ( result ) - 1 NEW_LINE while ( i >= 0 and result [ i ] == 0 ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT if ( i == - 1 ) : NEW_LINE INDENT return "0" NEW_LINE DEDENT s = " " NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT s += chr ( result [ i ] + 48 ) NEW_LINE i -= 1 NEW_LINE DEDENT return s NEW_LINE DEDENT
def getElements ( a , arr , n ) : NEW_LINE INDENT elements = [ 1 for i in range ( n + 1 ) ] NEW_LINE elements [ 0 ] = a NEW_LINE for i in range ( n ) : NEW_LINE INDENT elements [ i + 1 ] = arr [ i ] ^ elements [ i ] NEW_LINE DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT print ( elements [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def min_index ( p , n ) : NEW_LINE INDENT ans = 0 ; NEW_LINE mini = INT_MAX ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( p [ i ] <= mini ) : NEW_LINE INDENT mini = p [ i ] ; NEW_LINE DEDENT if ( mini == p [ i ] ) : NEW_LINE INDENT ans += 1 ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT
def innerCirclearea ( radius ) : NEW_LINE INDENT if ( radius < 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT r = radius / 2 ; NEW_LINE Area = ( 3.14 * pow ( r , 2 ) ) ; NEW_LINE return Area ; NEW_LINE DEDENT
def sizeSubSet ( a , k , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE s = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] % k != 0 or a [ i ] // k not in s ) : NEW_LINE INDENT s . add ( a [ i ] ) NEW_LINE DEDENT DEDENT return len ( s ) NEW_LINE DEDENT
def maxSum ( arr , n , k ) : NEW_LINE INDENT if ( n < k ) : NEW_LINE INDENT print ( " Invalid " ) NEW_LINE return - 1 NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT res += arr [ i ] NEW_LINE DEDENT curr_sum = res NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT curr_sum += arr [ i ] - arr [ i - k ] NEW_LINE res = max ( res , curr_sum ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def countSubArrays ( arr , x , n ) : NEW_LINE INDENT count = 0 ; NEW_LINE start = - 1 ; end = - 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] < x ) : NEW_LINE INDENT if ( start == - 1 ) : NEW_LINE INDENT start = i ; NEW_LINE end = i ; NEW_LINE DEDENT else : NEW_LINE INDENT end = i ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( start != - 1 and end != - 1 ) : NEW_LINE INDENT length = end - start + 1 ; NEW_LINE count = count + ( ( length * ( length + 1 ) ) / 2 ) ; NEW_LINE DEDENT start = - 1 ; NEW_LINE end = - 1 ; NEW_LINE DEDENT DEDENT if ( start != - 1 and end != - 1 ) : NEW_LINE INDENT length = end - start + 1 ; NEW_LINE count = count + ( ( length * ( length + 1 ) ) / 2 ) ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT
def squareSide ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT x = 0.423 * a NEW_LINE return x NEW_LINE DEDENT
def recaman ( n ) : NEW_LINE INDENT if ( n <= 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT print ( 0 , " , " , end = ' ' ) NEW_LINE s = set ( [ ] ) NEW_LINE s . add ( 0 ) NEW_LINE prev = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT curr = prev - i NEW_LINE if ( curr < 0 or curr in s ) : NEW_LINE INDENT curr = prev + i NEW_LINE DEDENT s . add ( curr ) NEW_LINE print ( curr , " , " , end = ' ' ) NEW_LINE prev = curr NEW_LINE DEDENT DEDENT
def find_distinct ( a , n , q , queries ) : NEW_LINE INDENT check = [ 0 ] * MAX ; NEW_LINE idx = [ 0 ] * MAX ; NEW_LINE cnt = 1 ; NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( check [ a [ i ] ] == 0 ) : NEW_LINE INDENT idx [ i ] = cnt ; NEW_LINE check [ a [ i ] ] = 1 ; NEW_LINE cnt += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT idx [ i ] = cnt - 1 ; NEW_LINE DEDENT DEDENT for i in range ( 0 , q ) : NEW_LINE INDENT m = queries [ i ] ; NEW_LINE print ( idx [ m ] , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT
def printPattern ( radius ) : NEW_LINE INDENT for i in range ( ( 2 * radius ) + 1 ) : NEW_LINE INDENT for j in range ( ( 2 * radius ) + 1 ) : NEW_LINE INDENT dist = math . sqrt ( ( i - radius ) * ( i - radius ) + ( j - radius ) * ( j - radius ) ) NEW_LINE if ( dist > radius - 0.5 and dist < radius + 0.5 ) : NEW_LINE INDENT print ( " * " , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " ▁ " , end = " " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT
def countPairs ( arr , n ) : NEW_LINE INDENT map = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT map [ arr [ i ] - i ] = map . get ( arr [ i ] - i , 0 ) + 1 NEW_LINE DEDENT res = 0 NEW_LINE for x in map : NEW_LINE INDENT cnt = map [ x ] NEW_LINE res += ( ( cnt * ( cnt - 1 ) ) // 2 ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def firstLetterWord ( str ) : NEW_LINE INDENT result = " " NEW_LINE v = True NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == ' ▁ ' ) : NEW_LINE INDENT v = True NEW_LINE DEDENT elif ( str [ i ] != ' ▁ ' and v == True ) : NEW_LINE INDENT result += ( str [ i ] ) NEW_LINE v = False NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def printAnagramsTogether ( words ) : NEW_LINE INDENT groupedWords = defaultdict ( list ) NEW_LINE for word in words : NEW_LINE INDENT groupedWords [ " " . join ( sorted ( word ) ) ] . append ( word ) NEW_LINE DEDENT for group in groupedWords . values ( ) : NEW_LINE INDENT print ( " ▁ " . join ( group ) ) NEW_LINE DEDENT DEDENT
def sum ( n ) : NEW_LINE INDENT i = 1 NEW_LINE s = 0.0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT s = s + 1 / i ; NEW_LINE DEDENT return s ; NEW_LINE DEDENT
def isDivisible ( s , m ) : NEW_LINE INDENT mp = dict . fromkeys ( CHARS , 0 ) ; NEW_LINE for i in range ( DIGITS ) : NEW_LINE INDENT mp [ CHARS [ i ] ] = i ; NEW_LINE DEDENT r = 0 ; NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT r = ( r * 16 + mp [ s [ i ] ] ) % m ; NEW_LINE DEDENT if ( not r ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT
def smallestX ( n ) : NEW_LINE INDENT temp = [ 0 ] * 10 NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT count = 0 NEW_LINE x = 1 NEW_LINE while ( count < 10 ) : NEW_LINE INDENT y = x * n NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( temp [ y % 10 ] == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE temp [ y % 10 ] = 1 NEW_LINE DEDENT y = int ( y / 10 ) NEW_LINE DEDENT x += 1 NEW_LINE DEDENT return x - 1 NEW_LINE DEDENT
def sumNth ( A , B , m , n ) : NEW_LINE INDENT res = 0 ; NEW_LINE if ( n == 1 ) : NEW_LINE INDENT for i in range ( m ) : NEW_LINE INDENT res = res + A [ i ] ; NEW_LINE DEDENT DEDENT elif ( n == 2 ) : NEW_LINE INDENT for i in range ( m ) : NEW_LINE INDENT res = res + B [ i ] * m ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT f = [ 0 ] * n ; NEW_LINE f [ 0 ] = 0 ; NEW_LINE f [ 1 ] = 1 ; NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT f [ i ] = f [ i - 1 ] + f [ i - 2 ] ; NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT res = ( res + ( m * ( B [ i ] * f [ n - 1 ] ) ) + ( m * ( A [ i ] * f [ n - 2 ] ) ) ) ; NEW_LINE DEDENT DEDENT return res ; NEW_LINE DEDENT
def isValid ( string , length ) : NEW_LINE INDENT for i in range ( 1 , length ) : NEW_LINE INDENT if string [ i ] == string [ i - 1 ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def findMaxRec ( A , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return A [ 0 ] NEW_LINE DEDENT return max ( A [ n - 1 ] , findMaxRec ( A , n - 1 ) ) NEW_LINE DEDENT
def findRemainders ( n ) : NEW_LINE INDENT vc = dict ( ) NEW_LINE for i in range ( 1 , ceil ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT vc [ n // i ] = 1 NEW_LINE DEDENT for i in range ( n // ceil ( sqrt ( n ) ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT vc [ i ] = 1 NEW_LINE DEDENT for it in sorted ( vc ) : NEW_LINE INDENT print ( it , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def countWays ( n ) : NEW_LINE INDENT counter = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT for k in range ( j , n ) : NEW_LINE INDENT for l in range ( k , n ) : NEW_LINE INDENT if ( i + j + k + l == n ) : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return counter NEW_LINE DEDENT
def findDelta ( a , b , c , d ) : NEW_LINE INDENT return int ( ( b * c - a * d ) / ( d - c ) ) ; NEW_LINE DEDENT
def Maxsum ( c1 , c2 , c3 , c4 ) : NEW_LINE INDENT sum = 0 NEW_LINE two34 = min ( c2 , min ( c3 , c4 ) ) NEW_LINE sum = two34 * 234 NEW_LINE c2 -= two34 NEW_LINE sum += min ( c2 , c1 ) * 12 NEW_LINE return sum NEW_LINE DEDENT
def reversDigits ( num ) : NEW_LINE INDENT global rev_num NEW_LINE global base_pos NEW_LINE if ( num > 0 ) : NEW_LINE INDENT reversDigits ( ( int ) ( num / 10 ) ) NEW_LINE rev_num += ( num % 10 ) * base_pos NEW_LINE base_pos *= 10 NEW_LINE DEDENT return rev_num NEW_LINE DEDENT
def findMinimumOperation ( n , d , arrays ) : NEW_LINE INDENT cnt = 0 NEW_LINE first = - 10 ** 9 NEW_LINE end = 10 ** 9 NEW_LINE while ( n ) : NEW_LINE INDENT arr = [ arrays [ cnt ] [ 0 ] , arrays [ cnt ] [ 1 ] ] NEW_LINE arr = sorted ( arr ) NEW_LINE first = max ( first , arr [ 0 ] ) NEW_LINE end = min ( end , arr [ 1 ] ) NEW_LINE cnt += 1 NEW_LINE n -= 1 NEW_LINE DEDENT if ( first > end ) : NEW_LINE INDENT print ( " - 1" , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( d >= first and d <= end ) : NEW_LINE INDENT print ( "0" , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( min ( abs ( first - d ) , abs ( d - end ) ) , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def minStepToDeleteString ( str ) : NEW_LINE INDENT N = len ( str ) NEW_LINE dp = [ [ 0 for x in range ( N + 1 ) ] for y in range ( N + 1 ) ] NEW_LINE for l in range ( 1 , N + 1 ) : NEW_LINE INDENT i = 0 NEW_LINE j = l - 1 NEW_LINE while j < N : NEW_LINE INDENT if ( l == 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i + 1 ] [ j ] NEW_LINE if ( str [ i ] == str [ i + 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( 1 + dp [ i + 2 ] [ j ] , dp [ i ] [ j ] ) NEW_LINE DEDENT for K in range ( i + 2 , j + 1 ) : NEW_LINE INDENT if ( str [ i ] == str [ K ] ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i + 1 ] [ K - 1 ] + dp [ K + 1 ] [ j ] , dp [ i ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT i += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return dp [ 0 ] [ N - 1 ] NEW_LINE DEDENT
def KthMinValAfterMconcatenate ( A , N , M , K ) : NEW_LINE INDENT V = [ ] NEW_LINE for i in range ( 0 , M ) : NEW_LINE INDENT for j in range ( 0 , N ) : NEW_LINE INDENT V . append ( A [ j ] ) NEW_LINE DEDENT DEDENT V . sort ( ) NEW_LINE return V [ K - 1 ] NEW_LINE DEDENT
